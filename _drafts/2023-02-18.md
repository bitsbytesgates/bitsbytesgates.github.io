---
layout: post
title: Automating Bare-Metal Software-Driven Tests with PSS
---

As a technologist, it's tempting to focus on what is new 
(at least, new to me) -- especially when choosing what to write about.
I'm periodically reminded that there is immense value in returning
to topics. Returning to a topic might raise awareness with a different
set of readers, but it's also highly likely that I'll learn something
new about the topic, or how to think about it, in the process.

This post marks the beginning of just such a "back to basics" series
that focuses on the [Accellera Portable Test and Stimulus](https://www.accellera.org/downloads/standards/portable-stimulus) 
(PSS) language. PSS is a specification language for modeling behavior 
to test. It specifically focuses on providing features that help 
in creating bare-metal software-driven system-level tests. Consequently,
this 'Intro to PSS' series will focus on the task of the bare-metal
software-driven test writer, and the value PSS provides.

## Programming Languages - General Purpose and Domain Specific
When it comes to programming languages, there are two big 
categories: general-purpose programming languages and domain-specific
programming languages. General-purpose programming languages such
as C/C++, Java, Python, and Rust are designed to be able to 
implement any algorithm or behavior. The "any..." part comes 
with a caveat, of course: any algorithm or behavior given sufficient
expertise and time. 

There are classes of problems that have such
well-defined expert solutions that it's considered wasteful
to actually apply large amounts of expert-programmer 
resource to re-solve them each time. This is where domain-specific 
languages (DSL) come into play. A domain-specific language provides a way to
capture a problem in a way that a domain expert finds familiar, along with 
enough information to enable a synthesis tool to prodce an optimal
implementation in a general-purpose language.


## Cases where DSLs shine
As you may have guessed, PSS is a domain-specific language targeted at 
capturing system-level test behavior in terms familiar to a domain expert.
Let's take a look at another very popular applcation for domain-specific
languages to better understand the value and tradeoffs that they provide.

An excellent example of an application of domain-specific languages 
is building lexical analyzers (lexers) and parsers.  People that 
define languages think in terms of language grammars -- typically
captured in Baucus-Naur Format (BNF). For example, here is a snippet 
of BNF grammar from the PSS language-reference manual.

```
action_body_item ::=
 activity_declaration
 | override_declaration
 | constraint_declaration
 | action_field_declaration
```

Coding a parser by hand from this description involves a fair amount of 
analysis to, for example, identify the keywords that would cause a parser
to proceed down one branch vs another, and how many tokens of
'lookahead' are needed in each case to disambiguate choices. While these
are critical implementation decisions, they're difficult for a human to
make by hand since they often involve 'global' thinking about the whole
of a sizable language grammar. 


```
action_body_item:
 activity_declaration
 | override_declaration
 | constraint_declaration
 | action_field_declaration
 ;
```

Re-expressing the BNF in the terms of a domain-specific language is an
almost-trivial exercise for a domain expert in language design. There 
are a few changes in format, and a few things that are conveyed 
typographically in a printed language grammar are conveyed in a way to
enable easier programmatic processing.

By capturing our language grammar in a domain-specific language format,
we're able to make use of a parser/lexer builder tool to derive an 
efficient implementation of a language parser for this language. The 
parser-builder tool is able to easily and quickly make high-quality
global optimizations that would have been very time consuming and 
error-prone for a human to make. And, if we change the grammar at 
some point, we only need to re-run the the parser-builder tool to derive
a new (and still optimal) parser implementation.

Looking at a few domain-speific languages, they tend to shine when:
- There exists a natural (innate or acquired) way for a domain expert to 
  capture a domain problem.
- Deterministic, automatable methods exist to derive an optimized 
  implementation from the domain-specific description
- There is a significant difference between the best way to describe a 
  problem and the best way to implement it in a general-purpose 
  programming language
- Achieving a good implementation requires global and/or concurrent 
  optimization.

# Where, When, Why does Bare-Metal Testing fit? 
With that in mind, let's look back at our target application for PSS:
creation of bare-metal software-driven tests. In a typical 
system-development flow, development and verification of hardware and
software proceed on different paths up to a point. Of course, there 
can be some cross-over in the process, but the time when software
really starts to run on the hardware for which it is intended is
once the hardware system is assembled and verified.

[ Diagram ]

Once a stable hardware-like representation of the hardware system 
exists, the integration team can really get started on completing
software for the system. Note that I said "hardware-like". In many
cases, the representation of the hardware system will be a hardware
emulator, or an FPGA prototype. The key is that the representation
have sufficient stability and performance to support 
software-development efforts. 

Two key factors to a successful hardware/software integration process are 
maximizing the stability of the hardware platform and having an efficient
path to reproduce and produce minimized testcases for any bugs found
by the integration team. The quality, quantity, and flexibility of the
bare-metal tests used to verify the system-level hardware platform has
a huge impact on success here.

# What are Bare-Metal Tests?
In order to appreciate some of the key benefits that PSS has to offer 
in creating bare-metal software-driven tests, it's useful to understand
a bit more about about their characteristics.


# Our Target User -- The Bare-Metal Software-Driven Test Writer

- Where it fits in the process
- Purpose -- ensure stability of the total hardware platform before
  beginning to run real software.
  - Real OS-driver development is done on a high-speed platform, such
    as a hardware emulator or FPGA prototype.
    - Building a hardware image for these platforms is time consuming,
          
  - 

# Characteristics/challenges of Bare-Metal Testing
- Mentioned that bare-metal tests are simple by design. This is only
  partially true. Bare-metal tests must be able to exercise complex
  hardware behaviors without the complexities introduced by having
  an underlying OS.
  - No OS process scheduler
  - No dynamic memory allocation
  - No device drivers that enable multiple software processes to safely
    share access to hardware devices.
- But, want tests that scale from exercising very simple hardware
  interactions to quite complex ones, with the goal of handing off
  a stable hardware platform to software.
  - Want a controllably amount of randomness
  - Need to run parallel behavior
  - Need to emulate harware interactions that the software 
    will eventually provoke.

- Means the test writer needs to handle things like:
  - Scheduling behavior to run on different processors. With bare-metal
    tests, this means creating per-core test programs that coordinate 
    activity.
  - Managing memory allocation statically. So, each piece of test behavior
    pre-computes its test
  - Need to 
  - Need to introduce some degree of variability using random generation

# Conclusion
- Close on how PSS' domain-specific description can help
  - Raise productivity by creating more tests more quickly
  - Ease task of minimizing failing cases such that they can be 
    investigated on slower/greater-visibility platforms

# Big picture: what is PSS and how does it help?
- Declarative description insulates the test writer from some of the
  more-onerous challenges of bare metal tests
- Get benefits of randomization and functional coverage, transformed
  to what can be supported 

# Setup for next post about multi-core tests

