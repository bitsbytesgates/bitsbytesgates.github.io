Toward A Pythonic Hardware Development Flow

- Code-centric with 'tooling' largely automatic
- Separate interface language from implementation
- Rich tool infrastructure

Results:
- Very easy to get started
- Very easy to use external content
- Stay focused on the code, since very little configuration is needed for build/test infrastructure

Compare this to 

Of course, Python is software and hardware is different. But, fundamentally, that 
doesn't mean that we can't achieve the same developer experience.

- Special markers to identify the hardware model. Keep it modular, and keep it pure Python!
  - Base types
  - Decorators
- Leverage Python dynamic nature
  - Powerful on-the-fly construction of types
  - Programmatically construct the model
  - Programmatically specify binding
- Model is separate from implementation, and need not be implementation
  - Ex: bind map
  -> Might connect two data objects
  -> Might introduce 
- Model can be processed in multiple ways (including reconfiguring how regions are processed)
  - Create a pure-Python implementation of the model and test. Nearly instantaneous transform. Slow execution
  - Implement as a Verilog model running on a hardware simulator
    - 
  - 
- Processing-flow automation derived from Model structure
  - Dependencies
  - Transformations that can be concurrent
- Model acts as a front-end / interface to different implementations -- derived and existing
  - Existing Verilog
  - Derived Verilog, high-speed model, precompiled simulation image, etc
- Python packaging provides a way to publish and consume content (both primary source and artifact)
  - Core (source) package with optional dependencies
  - Enable model processors to use cached prebuilt artifacts vs deriving on-the-fly


# Drivers
- More-complex designs require more-complex configuration and benefit from 
  higher-level features for capturing the design intent. SystemVerilog
  parameters and generate statements are helpful, but libraries such as
  CHISEL have shown 
- Verification consumes
- Tighter links between hardware 
More-complex designs drive us to not jump directly from spec to RTL
- Increased system focus means we need to consider context in which
  a design will be used up-front
  - Be able to model/predict its eventual operation in the context of the whole system
- 

# It's not just language

- Python language, itself, is very helpful in achieving these goals. But it's
  not the whole story. In general, 

# What does Pythonic Hardware Development Look Like?

- Code-first: very easy to capture and evaluate a model
- Package ecosystem
  - Pull in IP as Python packages
  - Packaged 

- Unified around Python vs fragmented models that we have to worry about integrating
- Works with existing languages where that makes sense 
  - Output Verilog RTL for simulation and synthesis
  - Incorporate 
- Cover abstract modeling, implementation, and verification
- Simplify integration of existing tools and models
- Productivity with a higher-level description
  - Use generative features to automate creation of a design description
  - Explore modeling styles that trivially reduce to standard RTL, but are more concise and faster
- Multi-abstraction modeling
  - Start high level and refine
  - "Checkr
- Tool use falls out of what we do instead of the opposite
- Integration platform that enables 


Want to have this same 

Three things:
- Modeling language that covers high level all the way to RTL
  - What not how
  - Abstract to RTL
  - Ability to extract / checkerboard implementation as needed
  - Ability to use programmatic techniques to build the model
- Ability to derive the right implementation(s)
  - Have many target environments. 
  - Must be able to create env-appropriate implementations when required
    - High-speed abstract models 
    - Verilog for gateware implementation flows
    - Efficient embedded C code for management cores and test
    - 
- Integration platform 
  - Easy to incorporate other technologies
  - For many of us, the simulator is the integration platform
    - VPI/DPI plug-ins
    - Largely system programming in C/C++
    - Generally aimed at a specific type of tightly-coupled simulation helper
    - Now, often interested interacting with systems
      - Interact with a hardware emulator or FPGA prototype
      - Interact with a software emulator like QEMU
      - Workloads generated by running application software
      - Might even want to partition the system model that we're building
        and run the pieces in parallel on multiple cores
      - ...
    - Loosely-coupled extensions that must inter
  - Want a productive, friendlier experience
  - Easily when integrating external tools

- Why now? 
  - 

- Low vs high overhead
  - Python is low-overhead -- no build system, small transition spec->run, simple package management
    - Literally try things out interactively
  - Hardware is high overhead
    - Complex build systems
    - Complex dependency management
  -> But, does it scale? Yes. Because we can partition the design

For me, this all adds up to a Pythonic hardware-development experience. Specifically,
one that centers on the model (code) being developing
- Pythonic developer experience
  - Lots to like about PYthon development process
    - libraries
    - tools
    - ease of writing tests
  - Most is how the code stays central
    - May seem strange, but in many other languages build systems, compilers, etc hold an important place
      - Can't *do* anything until the code has passed through these hoops
      - Creating these structures becomes a pre-req to doing anything with what we're developing
    - Python is very code-centric.

Outcomes
- Design

So, what does a Pythonic hardware development process look like?
- Abstractions ...
- Starts with the code and keeps Python as the central focus
- Create an abstract model (DMA)
- Quickly exercise within Python
- Refine slightly
- 