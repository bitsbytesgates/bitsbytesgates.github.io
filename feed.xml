<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://bitsbytesgates.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bitsbytesgates.com/" rel="alternate" type="text/html" /><updated>2025-11-18T00:42:50+00:00</updated><id>https://bitsbytesgates.com/feed.xml</id><title type="html">Bits, Bytes, and Gates</title><subtitle>There&apos;s oh so much fun to be had. At the leading edge,  at the bleeding edge, at the confluence of bits, bytes, and gates.</subtitle><entry><title type="html">Working with Analysis Ports</title><link href="https://bitsbytesgates.com/pythonuvm/2025/11/16/UvmWithPython__AnalysisPorts.html" rel="alternate" type="text/html" title="Working with Analysis Ports" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/11/16/UvmWithPython__AnalysisPorts</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/11/16/UvmWithPython__AnalysisPorts.html"><![CDATA[<p>For the most part, UVM and SystemVerilog make interactions with a 
dynamically-typed language surprisingly easy. There are a few exceptions
where the developer of the SystemVerilog UVM code must step in to enable
access to certain testbench elements. Analysis ports are one case in point.
Fortunately, there is a relatively non-invasive approach to allow Python
to dynamically interact with UVM analysis ports. Let’s look more closely at 
the details.</p>

<h1 id="working-with-analysis-ports">Working with Analysis Ports</h1>

<p>UVM testbench environments use analysis ports extensively. An <em>analysis port</em> 
publishes data to zero or more listeners, and is used to route transactions 
from interface monitors to scoreboards and other analysis components.</p>

<p>Connecting to analysis ports from Python allows scoreboards and other analysis
components to be implemented in Python. There are two technical requirements
that enable Python to receive transactions published by analysis ports:</p>
<ul>
  <li>Be able to identify a uvm_analysis_port as a distinct type (vs, say, a uvm_object or uvm_component).</li>
  <li>Be able to add a new listener to the analysis port</li>
</ul>

<h1 id="challenges-of-dynamically-using-analysis-ports">Challenges of Dynamically Using Analysis Ports</h1>
<p>Each of these technical requirements poses its own challenge.</p>

<div class="mermaid" align="center">
classDiagram
  uvm_analysis_port_base &lt;|-- uvm_analysis_port
  uvm_tlm_if_base &lt;|-- uvm_analysis_port_base
  uvm_component &lt;|-- uvm_tlm_if_base
  class uvm_analysis_port["uvm_analysis_port #(T)"]
  class uvm_analysis_port_base["uvm_analysis_port_base #(uvm_tlm_if_base #(T,T))"]
  class uvm_tlm_if_base["uvm_tlm_if_base #(T,T)"]
  class uvm_component["uvm_component"]
</div>

<p>SystemVerilog is a statically-typed language that provides minimal 
<em>introspection</em> tools for looking at the internals of user-defined 
classes. This is especially true when it comes to templated types. In 
order to ask whether a given object <em>is an</em> instance of uvm_analysis_port,
we need to ask about a specific specialization of that type – for example,
“uvm_analysis_port #(my_special_transaction)”. As you might expect, this
poses some challenges because the PyHDL-IF library only knows about concrete
types defined by the UVM library, and doesn’t know anything about
the transaction types used within a user’s testbench. As a consequence,
when the PyHDL-IF library looks at an analysis port instance, 
it just sees a <code class="language-plaintext highlighter-rouge">uvm_component</code> instance.</p>

<p>One possible approach to this challenge is to have the user register each 
of the transaction types that they might want to use with analysis ports 
with the PyHDL-IF library. 
For example:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">class</span> <span class="n">my_transaction</span> <span class="k">extends</span> <span class="n">uvm_sequence_item</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="k">endclass</span>

<span class="cp">`pyhdl_uvm_transaction_utils</span><span class="p">(</span><span class="n">my_transaction</span><span class="p">)</span></code></pre></figure>

<p>This would allow the PyHDL-IF library to identify analysis-port instances,
but wouldn’t help with the second challenge of working with 
analysis ports.</p>

<p>The second challenge comes when we want to add a new listener to an 
analysis port. This must be done during <code class="language-plaintext highlighter-rouge">connect_phase</code>, and requires that 
a properly-specialized <code class="language-plaintext highlighter-rouge">uvm_analysis_imp #(T)</code> class instance was 
previously created during the build phase.</p>

<h1 id="making-analysis-ports-visibile">Making Analysis Ports Visibile</h1>

<p>While both of these challenges can be overcome independently, doing so 
would require the user to make two independent sets of changes. 
And, more troubling, wouldn’t provide a good way for VIP developers 
to hide this complexity from users. 
At minimum, the testbench developer would always need to pre-create
<code class="language-plaintext highlighter-rouge">uvm_analysis_imp</code> instances for each analysis port to which they might
subscribe.</p>

<p>Instead, PyHDL-IF provides two classes that supports two paths for making
analysis ports visible and accessible from Python:</p>
<ul>
  <li><em>pyhdl_uvm_analysis_port</em> – An alternative analysis port implementation intended for use by VIP authors</li>
  <li><em>pyhdl_uvm_analysis_imp</em> – An analysis port listener intended to make existing analysis ports available to PyHDL-IF</li>
</ul>

<h2 id="example">Example</h2>

<p>Let’s take a look at an example to understand how analysis ports are made 
accessible to the PyHDL-IF library. The uvm/seq_item_scoreboard example
shows how to make analysis ports accessible as well as how to receive
transactions from analysis ports.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="c1">// Producer component with two analysis ports</span>
  <span class="kt">class</span> <span class="n">dual_producer</span> <span class="k">extends</span> <span class="n">uvm_component</span><span class="p">;</span>
    <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">dual_producer</span><span class="p">)</span>

    <span class="n">pyhdl_uvm_analysis_port</span> <span class="p">#(</span><span class="n">seq_item_a</span><span class="p">)</span> <span class="n">ap_a</span><span class="p">;</span>
    <span class="n">uvm_analysis_port</span> <span class="p">#(</span><span class="n">seq_item_b</span><span class="p">)</span> <span class="n">ap_b</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="kt">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
      <span class="n">ap_a</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"ap_a"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="n">ap_b</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"ap_b"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span></code></pre></figure>

<p>The code snippet above shows how the pyhdl_uvm_analysis_port can be used
instead of uvm_analysis_port to make an analysis port available to the
PyHDL-IF library. The API of this class is identical to uvm_analysis_port,
making this a good choice for VIP authors that want to automatically make 
analysis ports accessible.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="c1">// Environment tying producer to scoreboard</span>
  <span class="kt">class</span> <span class="n">my_env</span> <span class="k">extends</span> <span class="n">uvm_env</span><span class="p">;</span>
    <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">my_env</span><span class="p">)</span>

    <span class="c1">// ...</span>
    <span class="n">pyhdl_uvm_analysis_imp</span> <span class="p">#(</span><span class="n">seq_item_b</span><span class="p">)</span>    <span class="n">ap_b_proxy</span><span class="p">;</span>
    <span class="c1">// ...</span>

    <span class="k">function</span> <span class="kt">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
      <span class="c1">// ...</span>
      <span class="n">ap_b_proxy</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">"ap_b_proxy"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="kt">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="n">connect_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
      <span class="c1">// ...</span>
      <span class="n">prod</span><span class="p">.</span><span class="n">ap_b</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ap_b_proxy</span><span class="p">.</span><span class="n">analysis_export</span><span class="p">);</span>
    <span class="k">endfunction</span>
  <span class="k">endclass</span></code></pre></figure>

<p>Note that <code class="language-plaintext highlighter-rouge">ap_b</code> uses a normal uvm_analysis_port in the VIP. We can 
make this analysis port accessible to the PyHDL-IF library by connecting
an instance of <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_imp</code> to it. While this could be done
anywhere, it’s often done in the environment (as shown above).</p>

<p>The <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_imp</code> instance is connected to the analysis port 
in the same way that any other analysis port subscriber does. Doing 
this allows Python code to receive transactions published by the 
analysis port.</p>

<p>Both <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_port</code> and <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_imp</code> have a <code class="language-plaintext highlighter-rouge">proxy</code>
field inside with a <code class="language-plaintext highlighter-rouge">add_listener</code> method that the Python environment 
uses to register a listener. Let’s look at the Python environment now.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">PyComp</span><span class="p">(</span><span class="n">uvm_component_impl</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">build_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"build_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"connect_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">get_parent</span><span class="p">()</span>
        <span class="n">env</span><span class="p">.</span><span class="n">prod</span><span class="p">.</span><span class="n">ap_a</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">add_listener</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">write_a</span><span class="p">)</span>
        <span class="n">env</span><span class="p">.</span><span class="n">ap_b_proxy</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">add_listener</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">write_b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_a</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"write_a %0s"</span> <span class="o">%</span> <span class="nf">str</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="nf">pack</span><span class="p">()),</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_b</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"write_b %0s"</span> <span class="o">%</span> <span class="nf">str</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="nf">pack</span><span class="p">()),</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p>In this case, the component proxy is a child instance of the <code class="language-plaintext highlighter-rouge">env</code> class
shown above. Consequently, to connect to the analysis ports, we first
need to get a handle to the instance of the <code class="language-plaintext highlighter-rouge">env</code> class (our parent).
After that, we need to access the analysis port <code class="language-plaintext highlighter-rouge">proxy</code> field inside
the <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_port</code> and <code class="language-plaintext highlighter-rouge">pyhdl_uvm_analysis_imp</code> instances.
We can pass any callable Python method or object to the <code class="language-plaintext highlighter-rouge">add_listener</code>
method. In this case, we simply register two class methods. When simulation
runs, <code class="language-plaintext highlighter-rouge">write_a</code> and <code class="language-plaintext highlighter-rouge">write_b</code> will be called whenever the analysis port
that they monitor publishes a transaction.</p>

<h1 id="conclusions-and-next-steps">Conclusions and Next Steps</h1>
<p>The PyHDL-IF library allows analysis ports to be made visible and accessible 
from Python with a small one-time investment. Verification IP (VIP) 
developers can implement this support, allowing all users to benefit. 
Testbench developers can also perform this work for VIP that isn’t pre-instrumented. 
The result is that scoreboards and other analysis components can easily be developed in Python.</p>

<p>Thus far in the series, we’ve seen how to run Python 
behavior from SystemVerilog. We’ve seen how to interact with user-defined 
UVM class fields, and we’ve now seen how to subscribe to analysis ports. 
These technical capabilities make it easy for Python to dynamically interoperate 
with an existing SystemVerilog/UVM testbench. But, thus far, these 
capabilities don’t do much to support Python development tools. In the next
post, we’ll see how the PyHDL-IF library provides a bridge from SystemVerilog/UVM
to help Python development tools understand what is present in the UVM environment
and make us more productive developing Python testbench components.</p>

<h2 id="references">References</h2>
<ul>
  <li>PyHDL-IF library - <a href="https://github.com/fvutils/pyhdl-if">https://github.com/fvutils/pyhdl-if</a></li>
  <li>Analysis port example - <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/seq_item_scoreboard">https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/seq_item_scoreboard</a></li>
</ul>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[For the most part, UVM and SystemVerilog make interactions with a dynamically-typed language surprisingly easy. There are a few exceptions where the developer of the SystemVerilog UVM code must step in to enable access to certain testbench elements. Analysis ports are one case in point. Fortunately, there is a relatively non-invasive approach to allow Python to dynamically interact with UVM analysis ports. Let’s look more closely at the details. Working with Analysis Ports UVM testbench environments use analysis ports extensively. An analysis port publishes data to zero or more listeners, and is used to route transactions from interface monitors to scoreboards and other analysis components. Connecting to analysis ports from Python allows scoreboards and other analysis components to be implemented in Python. There are two technical requirements that enable Python to receive transactions published by analysis ports: Be able to identify a uvm_analysis_port as a distinct type (vs, say, a uvm_object or uvm_component). Be able to add a new listener to the analysis port Challenges of Dynamically Using Analysis Ports Each of these technical requirements poses its own challenge. classDiagram uvm_analysis_port_base &lt;|-- uvm_analysis_port uvm_tlm_if_base &lt;|-- uvm_analysis_port_base uvm_component &lt;|-- uvm_tlm_if_base class uvm_analysis_port["uvm_analysis_port #(T)"] class uvm_analysis_port_base["uvm_analysis_port_base #(uvm_tlm_if_base #(T,T))"] class uvm_tlm_if_base["uvm_tlm_if_base #(T,T)"] class uvm_component["uvm_component"] SystemVerilog is a statically-typed language that provides minimal introspection tools for looking at the internals of user-defined classes. This is especially true when it comes to templated types. In order to ask whether a given object is an instance of uvm_analysis_port, we need to ask about a specific specialization of that type – for example, “uvm_analysis_port #(my_special_transaction)”. As you might expect, this poses some challenges because the PyHDL-IF library only knows about concrete types defined by the UVM library, and doesn’t know anything about the transaction types used within a user’s testbench. As a consequence, when the PyHDL-IF library looks at an analysis port instance, it just sees a uvm_component instance. One possible approach to this challenge is to have the user register each of the transaction types that they might want to use with analysis ports with the PyHDL-IF library. For example: class my_transaction extends uvm_sequence_item; // ... endclass `pyhdl_uvm_transaction_utils(my_transaction) This would allow the PyHDL-IF library to identify analysis-port instances, but wouldn’t help with the second challenge of working with analysis ports. The second challenge comes when we want to add a new listener to an analysis port. This must be done during connect_phase, and requires that a properly-specialized uvm_analysis_imp #(T) class instance was previously created during the build phase. Making Analysis Ports Visibile While both of these challenges can be overcome independently, doing so would require the user to make two independent sets of changes. And, more troubling, wouldn’t provide a good way for VIP developers to hide this complexity from users. At minimum, the testbench developer would always need to pre-create uvm_analysis_imp instances for each analysis port to which they might subscribe. Instead, PyHDL-IF provides two classes that supports two paths for making analysis ports visible and accessible from Python: pyhdl_uvm_analysis_port – An alternative analysis port implementation intended for use by VIP authors pyhdl_uvm_analysis_imp – An analysis port listener intended to make existing analysis ports available to PyHDL-IF Example Let’s take a look at an example to understand how analysis ports are made accessible to the PyHDL-IF library. The uvm/seq_item_scoreboard example shows how to make analysis ports accessible as well as how to receive transactions from analysis ports. // Producer component with two analysis ports class dual_producer extends uvm_component; `uvm_component_utils(dual_producer) pyhdl_uvm_analysis_port #(seq_item_a) ap_a; uvm_analysis_port #(seq_item_b) ap_b; function new(string name, uvm_component parent); super.new(name, parent); endfunction function void build_phase(uvm_phase phase); super.build_phase(phase); ap_a = new("ap_a", this); ap_b = new("ap_b", this); endfunction The code snippet above shows how the pyhdl_uvm_analysis_port can be used instead of uvm_analysis_port to make an analysis port available to the PyHDL-IF library. The API of this class is identical to uvm_analysis_port, making this a good choice for VIP authors that want to automatically make analysis ports accessible. // Environment tying producer to scoreboard class my_env extends uvm_env; `uvm_component_utils(my_env) // ... pyhdl_uvm_analysis_imp #(seq_item_b) ap_b_proxy; // ... function void build_phase(uvm_phase phase); super.build_phase(phase); // ... ap_b_proxy = new("ap_b_proxy", this); endfunction function void connect_phase(uvm_phase phase); super.connect_phase(phase); // ... prod.ap_b.connect(ap_b_proxy.analysis_export); endfunction endclass Note that ap_b uses a normal uvm_analysis_port in the VIP. We can make this analysis port accessible to the PyHDL-IF library by connecting an instance of pyhdl_uvm_analysis_imp to it. While this could be done anywhere, it’s often done in the environment (as shown above). The pyhdl_uvm_analysis_imp instance is connected to the analysis port in the same way that any other analysis port subscriber does. Doing this allows Python code to receive transactions published by the analysis port. Both pyhdl_uvm_analysis_port and pyhdl_uvm_analysis_imp have a proxy field inside with a add_listener method that the Python environment uses to register a listener. Let’s look at the Python environment now. class PyComp(uvm_component_impl): def build_phase(self, phase): print("build_phase", flush=True) def connect_phase(self, phase): print("connect_phase", flush=True) env = self.proxy.get_parent() env.prod.ap_a.proxy.add_listener(self.write_a) env.ap_b_proxy.proxy.add_listener(self.write_b) def write_a(self, t): print("write_a %0s" % str(t.pack()), flush=True) def write_b(self, t): print("write_b %0s" % str(t.pack()), flush=True) In this case, the component proxy is a child instance of the env class shown above. Consequently, to connect to the analysis ports, we first need to get a handle to the instance of the env class (our parent). After that, we need to access the analysis port proxy field inside the pyhdl_uvm_analysis_port and pyhdl_uvm_analysis_imp instances. We can pass any callable Python method or object to the add_listener method. In this case, we simply register two class methods. When simulation runs, write_a and write_b will be called whenever the analysis port that they monitor publishes a transaction. Conclusions and Next Steps The PyHDL-IF library allows analysis ports to be made visible and accessible from Python with a small one-time investment. Verification IP (VIP) developers can implement this support, allowing all users to benefit. Testbench developers can also perform this work for VIP that isn’t pre-instrumented. The result is that scoreboards and other analysis components can easily be developed in Python. Thus far in the series, we’ve seen how to run Python behavior from SystemVerilog. We’ve seen how to interact with user-defined UVM class fields, and we’ve now seen how to subscribe to analysis ports. These technical capabilities make it easy for Python to dynamically interoperate with an existing SystemVerilog/UVM testbench. But, thus far, these capabilities don’t do much to support Python development tools. In the next post, we’ll see how the PyHDL-IF library provides a bridge from SystemVerilog/UVM to help Python development tools understand what is present in the UVM environment and make us more productive developing Python testbench components. References PyHDL-IF library - https://github.com/fvutils/pyhdl-if Analysis port example - https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/seq_item_scoreboard]]></summary></entry><entry><title type="html">Accessing User-Defined SV Data from Python</title><link href="https://bitsbytesgates.com/pythonuvm/2025/11/08/UvmWithPython__UserDefinedData.html" rel="alternate" type="text/html" title="Accessing User-Defined SV Data from Python" /><published>2025-11-08T00:00:00+00:00</published><updated>2025-11-08T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/11/08/UvmWithPython__UserDefinedData</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/11/08/UvmWithPython__UserDefinedData.html"><![CDATA[<p>We’ve seen how the <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> library makes it simple to implement UVM sequences 
and components in Python, and how Python can call back into SystemVerilog. But,
a significant part of a testbench deals with user-defined data, ranging from 
named UVM instances, transaction fields in sequence items and control knobs on 
sequences. Fortunately, UVM provides features that <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> uses to provide 
dynamic and Pythonic access to user-defined data in UVM.</p>

<!--more-->

<h1 id="two-kinds-of-user-defined-data">Two Kinds of User-Defined Data</h1>

<p>There are two key kinds of user-defined data that we care about in our UVM 
environment: named UVM instances, and data fields. In both of these cases,
a SystemVerilog environment typically references the named field directly.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
      <span class="n">uvm_status_e</span>   <span class="n">status</span><span class="p">;</span>
      <span class="n">uvm_reg_data_t</span> <span class="n">rd</span><span class="p">;</span>

      <span class="c1">// Program CTRL / CLKDIV / SS</span>
      <span class="n">m_env</span><span class="p">.</span><span class="n">m_reg</span><span class="p">.</span><span class="n">CTRL</span><span class="p">.</span><span class="n">enable</span><span class="p">.</span><span class="nb">write</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">m_env</span><span class="p">.</span><span class="n">m_reg</span><span class="p">.</span><span class="n">CTRL</span><span class="p">.</span><span class="n">master</span><span class="p">.</span><span class="nb">write</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">m_env</span><span class="p">.</span><span class="n">m_reg</span><span class="p">.</span><span class="n">CLKDIV</span><span class="p">.</span><span class="n">div</span><span class="p">.</span><span class="nb">write</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="mh">16'h0004</span><span class="p">);</span>
      <span class="n">m_env</span><span class="p">.</span><span class="n">m_reg</span><span class="p">.</span><span class="n">SS</span><span class="p">.</span><span class="n">ss_mask</span><span class="p">.</span><span class="nb">write</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="mh">4'h1</span><span class="p">);</span>

      <span class="c1">// ...</span>
    <span class="k">endtask</span></code></pre></figure>

<p>An example of using named instance fields, using registers, is shown
above.  Our goal is to be able to access these fields just as easily in 
Python, as well as plain data fields.</p>

<h2 id="named-uvm-instances">Named UVM Instances</h2>

<p>Named UVM instances are UVM objects registered with the UVM library using a name.
User code typically accesses these objects via the SystemVerilog instance 
fields, but they can also be obtained using UVM API methods. Fortunately, 
Python provides specific functionality to enable us to do this.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="kt">class</span> <span class="n">spi_reg_block</span> <span class="k">extends</span> <span class="n">uvm_reg_block</span><span class="p">;</span>
    <span class="cp">`uvm_object_utils</span><span class="p">(</span><span class="n">spi_reg_block</span><span class="p">)</span>

    <span class="k">rand</span> <span class="n">reg_CTRL</span>   <span class="n">CTRL</span><span class="p">;</span>
    <span class="k">rand</span> <span class="n">reg_STATUS</span> <span class="n">STATUS</span><span class="p">;</span>
    <span class="c1">// ...</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="o">=</span><span class="s">"spi_reg_block"</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">UVM_NO_COVERAGE</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="kt">virtual</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">build</span><span class="p">();</span>
      <span class="c1">// ...</span>

      <span class="n">CTRL</span>   <span class="o">=</span> <span class="n">reg_CTRL</span>  <span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"CTRL"</span><span class="p">);</span>
      <span class="n">STATUS</span> <span class="o">=</span> <span class="n">reg_STATUS</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"STATUS"</span><span class="p">);</span>
      <span class="c1">// ...</span>

      <span class="n">CTRL</span>  <span class="p">.</span><span class="n">configure</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
      <span class="n">STATUS</span><span class="p">.</span><span class="n">configure</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
      <span class="c1">// ...</span>
    <span class="k">endfunction</span>

  <span class="k">endclass</span></code></pre></figure>

<p>Registers and register fields provide a good example of UVM named 
instances. As shown above, register blocks (and registers) usually
provide named SystemVerilog fields to represent registers and fields.
But, the <code class="language-plaintext highlighter-rouge">configure</code> method also registers the object with the UVM
API such that it can be found by name. In the case of the register
block, the <code class="language-plaintext highlighter-rouge">get_registers</code> function returns a list of register objects.</p>

<p>The Python <code class="language-plaintext highlighter-rouge">__getattr__</code> method allows us to access UVM named instances
from Python just as easily as in SystemVerilog.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="o">@</span><span class="n">api</span>
<span class="kt">class</span> <span class="n">uvm_reg_block</span><span class="p">(</span><span class="n">uvm_object</span><span class="p">)</span><span class="o">:</span>

    <span class="n">def</span> <span class="mi">__</span><span class="n">init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
        <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span> <span class="o">=</span> <span class="n">None</span>

    <span class="p">#</span> <span class="p">...</span>
    <span class="o">@</span><span class="n">imp</span>
    <span class="n">def</span> <span class="n">get_registers</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">uvm_reg_p</span><span class="p">]</span><span class="o">:</span>
        <span class="n">raise</span> <span class="n">NotImplementedError</span><span class="p">()</span>
    
    <span class="n">def</span> <span class="mi">__</span><span class="n">getattr__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span> <span class="n">is</span> <span class="n">None</span><span class="o">:</span>
            <span class="n">regs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">get_registers</span><span class="p">()</span>
            <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span> <span class="o">=</span> <span class="o">{}</span>
            <span class="k">for</span> <span class="n">r</span> <span class="n">in</span> <span class="n">regs</span><span class="o">:</span>
                <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">get_name</span><span class="p">()]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">name</span> <span class="n">in</span> <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="mf">._</span><span class="n">reg_m</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="nl">else:</span>
            <span class="n">raise</span> <span class="n">AttributeError</span><span class="p">(</span><span class="s">"No register %s in block %s"</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">get_name</span><span class="p">()))</span></code></pre></figure>

<p>The Python code snippet above shows how this is implemented for the 
<code class="language-plaintext highlighter-rouge">uvm_reg_block</code> class. Python calls the <code class="language-plaintext highlighter-rouge">__getattr__</code> class method
any time an unknown class attribute is referenced. In a <code class="language-plaintext highlighter-rouge">uvm_reg_block</code>
class, we build a map of the named register fields and return the
proper one if it is available.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">PyRegSeq</span><span class="p">(</span><span class="n">uvm_sequence_impl</span><span class="p">):</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># Obtain the register model from the sequencer
</span>        <span class="n">seqr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">m_sequencer</span>
        <span class="n">_</span><span class="p">,</span><span class="n">spi_regs</span> <span class="o">=</span> <span class="n">seqr</span><span class="p">.</span><span class="nf">get_config_object</span><span class="p">(</span><span class="s">"spi_regs"</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="s">"spi_regs: %s"</span> <span class="o">%</span> <span class="nf">str</span><span class="p">(</span><span class="n">spi_regs</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">spi_regs</span><span class="p">.</span><span class="n">CTRL</span><span class="p">.</span><span class="n">enable</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">spi_regs</span><span class="p">.</span><span class="n">CTRL</span><span class="p">.</span><span class="n">master</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">spi_regs</span><span class="p">.</span><span class="n">CTRL</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>

        <span class="n">spi_regs</span><span class="p">.</span><span class="n">CLKDIV</span><span class="p">.</span><span class="n">div</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="mh">0x4</span><span class="p">)</span>
        <span class="n">spi_regs</span><span class="p">.</span><span class="n">SS</span><span class="p">.</span><span class="n">ss_mask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">spi_regs</span><span class="p">.</span><span class="n">CLKDIV</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">spi_regs</span><span class="p">.</span><span class="n">SS</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>

        <span class="k">await</span> <span class="n">spi_regs</span><span class="p">.</span><span class="n">TXDATA</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="mh">0xA5</span><span class="p">)</span></code></pre></figure>

<p>Connecting <code class="language-plaintext highlighter-rouge">__getattr__</code> to a search of named UVM fields enables a 
Python-implemented UVM sequence to access registers and register fields
directly, as shown above.</p>

<h2 id="plain-data-fields">Plain-Data Fields</h2>

<p>Accessing UVM named-instance fields is useful in some cases, but there
are many other cases where the fields are not named instances. UVM 
sequence-item fields are a great example. Python code may wish to
both read and write the value of these fields. While the path to accessing
the value of these fields is a bit less direct, UVM absolutely provides
a path for doing so.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">class</span> <span class="n">seq_item</span> <span class="k">extends</span> <span class="n">uvm_sequence_item</span><span class="p">;</span>
    <span class="kt">bit</span>              <span class="n">ctrl_addr_page</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>         <span class="n">addr_page</span><span class="p">;</span>

    <span class="k">rand</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>   <span class="n">addr</span><span class="p">;</span>
    <span class="k">rand</span> <span class="kt">bit</span>         <span class="nb">write</span><span class="p">;</span> <span class="c1">// 1=write, 0=read</span>
    <span class="k">rand</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>  <span class="n">data</span><span class="p">;</span>
    <span class="k">rand</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>   <span class="n">tid</span><span class="p">;</span>

    <span class="c1">// ...</span>

    <span class="cp">`uvm_object_utils_begin</span><span class="p">(</span><span class="n">seq_item</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="n">ctrl_addr_page</span><span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="n">addr_page</span><span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="n">addr</span> <span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="nb">write</span><span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="n">data</span> <span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
        <span class="cp">`uvm_field_int</span><span class="p">(</span><span class="n">tid</span>  <span class="p">,</span> <span class="n">UVM_ALL_ON</span><span class="p">)</span>
    <span class="cp">`uvm_object_utils_end</span>
    <span class="c1">// ...</span>
<span class="k">endclass</span></code></pre></figure>

<p>The code snippet above shows a typical UVM sequence item with random fields.
This sequence item uses the UVM field macros (eg uvm_field_int) to register
the user-defined fields with the UVM library. This enables the UVM library
to automatically implement several pieces of functionality, such as 
comparing the value of two objects and copying the field values of an object.
Users can also implement these functions by hand-implementing methods such 
as <code class="language-plaintext highlighter-rouge">do_copy</code> and <code class="language-plaintext highlighter-rouge">do_compare</code>, but that results in quite a bit of hand-created
code and an increased risk of introducing errors.</p>

<p>There are three key elements of functionality that the <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> library uses
to enable user-defined data fields to be accessed from Python:</p>
<ul>
  <li><strong>sprint</strong> – Converts the class and its fields to a string representation</li>
  <li><strong>pack_int</strong> – Packs the field values to an array of unsigned ints</li>
  <li><strong>unpack_int</strong> – Sets the field values from an array of unsigned ints</li>
</ul>

<p>Used together, these three methods provide the <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> library everything
it needs to allow Python to easily get and set the value of user-defined
fields. If you’re interested in the details of how it works, see the
<code class="language-plaintext highlighter-rouge">mk</code> method of the <a href="https://github.com/fvutils/pyhdl-if/blob/main/src/hdl_if/uvm/wrap/object_rgy.py">uvm_object_rgy</a>
class.</p>

<p>The short version is that type information is built each time a new type of 
UVM object is passed from SystemVerilog to Python. The field names and
types are extracted using the string representation provided by <code class="language-plaintext highlighter-rouge">sprint</code>.
The field names and types are used to dynamically define a Python type.
When Python code calls the <code class="language-plaintext highlighter-rouge">pack</code> method, an instance of this Python 
type is constructed with field values provided by packing the SystemVerilog 
field values. Setting the value of the SystemVerilog fields is done 
by calling <code class="language-plaintext highlighter-rouge">unpack</code> in Python. Let’s see how it is used.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">PyRandSeq</span><span class="p">(</span><span class="n">uvm_sequence_impl</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># ...
</span>
        <span class="c1"># Now, exercise each page in turn 
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">req</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">create_req</span><span class="p">()</span>
            
            <span class="c1"># Get the current values
</span>            <span class="n">val</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">pack</span><span class="p">()</span>
            <span class="n">val</span><span class="p">.</span><span class="n">ctrl_addr_page</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">val</span><span class="p">.</span><span class="n">addr_page</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># Set the field values
</span>            <span class="n">req</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="c1"># Randomize with control knobs
</span>            <span class="n">req</span><span class="p">.</span><span class="nf">randomize</span><span class="p">()</span>
            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span></code></pre></figure>

<p>The example above shows how to use both the <code class="language-plaintext highlighter-rouge">pack</code> and <code class="language-plaintext highlighter-rouge">unpack</code> methods to 
control randomization from Python using randomization control knobs. In this
case, we want to control the address “page” – its upper bits. To do this,
the sequence creates an instance of the request object, then calls <code class="language-plaintext highlighter-rouge">pack</code>
to obtain a Python object containing the field values of the SystemVerilog
sequence item. After setting the desired address page, the <code class="language-plaintext highlighter-rouge">unpack</code> 
method is called to set the value of the SystemVerilog fields. Finally, 
the standard <code class="language-plaintext highlighter-rouge">start_item</code>, <code class="language-plaintext highlighter-rouge">randomize</code>, <code class="language-plaintext highlighter-rouge">finish_item</code> sequence of calls
is made to execute the sequence item on the driver.</p>

<h1 id="conclusion">Conclusion</h1>
<p>The <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> library allows Python code to easily access both named UVM
instance fields and data fields. This significantly enhances the type 
of test and analysis behavior that can easily be implemented in Python.</p>

<p>Thus far in this series of posts, we’ve seen how to launch Python behavior
from SystemVerilog, interact with UVM APIs, and access fields declared in 
SystemVerilog UVM classes. Next, we’ll take a look at UVM analysis ports.
Analysis ports are critical for obtaining transactions for scoreboards and
other analysis components. Working with them in a generic fashion is tricky.
Next time, we’ll see how the <a href="http://github.com/fvutils/pyhdl-if">PyHDL-IF</a> library makes them easily accessible
from Python.</p>

<h1 id="references">References</h1>
<ul>
  <li>PyHDL-IF library: <a href="https://github.com/fvutils/pyhdl-if">https://github.com/fvutils/pyhdl-if</a></li>
  <li>Example: spi_reg_seq: <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/spi_reg_seq">https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/spi_reg_seq</a></li>
  <li>Example: sequence-item knobs: <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/sequence_item_knobs">https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm/sequence_item_knobs</a></li>
</ul>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[We’ve seen how the PyHDL-IF library makes it simple to implement UVM sequences and components in Python, and how Python can call back into SystemVerilog. But, a significant part of a testbench deals with user-defined data, ranging from named UVM instances, transaction fields in sequence items and control knobs on sequences. Fortunately, UVM provides features that PyHDL-IF uses to provide dynamic and Pythonic access to user-defined data in UVM.]]></summary></entry><entry><title type="html">The Mechanics of UVM/Python Cross-Calling</title><link href="https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics.html" rel="alternate" type="text/html" title="The Mechanics of UVM/Python Cross-Calling" /><published>2025-11-01T00:00:00+00:00</published><updated>2025-11-01T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics.html"><![CDATA[<p>It’s not necessary to understand very much about how PyHDL-IF implements
the bridge between Python and UVM, but useful to understand a bit. Doing 
so helps to understand what this library is and is not intended to do,
and how you can best use it in your verification environment.</p>

<!--more-->

<h1 id="an-interface-not-a-uvm-library">An Interface, not a UVM Library</h1>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/11/pyhdl_if_uvm_wrapper.png" />
</p>

<p>One important thing to understand is that PyHDL-IF is an interface library,
and not a full testbench library. The UVM portion of PyHDL-IF is intended to 
make it easy to call SystemVerilog/UVM APIs from Python, and vice versa. 
Consequently, it is only
useful if a SystemVerilog/UVM testbench is a part of your verification environment.
If you want to create a UVM testbench in Python, the <a href="https://github.com/pyuvm/pyuvm">pyuvm</a>
library is more likely to be what you’re looking for. You can even use 
<code class="language-plaintext highlighter-rouge">pyuvm</code> with PyHDL-IF to provide structure to the Python portion of the testbench
that leverages your existing UVM-SV testbench.</p>

<p>Limiting the scope in this way has its advantages, though. While the UVM library
is quite large, the APIs that test writers and scoreboard developers use is 
a much smaller subset. Prioritizing this much-smaller subset very quickly 
provides an interface library that covers a large percentage of usecases.</p>

<h1 id="initiating-behavior-from-uvm">Initiating Behavior from UVM</h1>

<p>One implication of PyHDL-IF being an interface library is that all 
PyHDL-IF UVM objects are wrappers to access SystemVerilog UVM objects. 
While it is possible (and common!) to create instances of UVM objects
from Python, what happens under the hood as the following:</p>
<ul>
  <li>Python (via the PyHDL-IF library) calls a UVM method, creating a new UVM object</li>
  <li>The PyHDL-IF library creates a SystemVerilog and Python object pair with a handle to the UVM object</li>
  <li>This ‘wrapper’ Python object is returned to the caller.</li>
</ul>

<p>So, how do we initiate Python behavior from a UVM testbench? There are 
two special PyHDL-IF “proxy” classes that provide a Python implementation
for <code class="language-plaintext highlighter-rouge">uvm_component</code> and <code class="language-plaintext highlighter-rouge">uvm_sequence</code>: <code class="language-plaintext highlighter-rouge">pyhdl_uvm_component_proxy</code> and <code class="language-plaintext highlighter-rouge">pyhdl_uvm_sequence_proxy</code>.</p>

<h1 id="interface-structure">Interface Structure</h1>

<p>The PyHDL-IF library provides infrastructure that connects a Python object and 
a SystemVerilog object via method calls. Specially-decorated classes define
the shared API. For example, the code snippet below defines the API of the 
UvmSequenceProxy:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@api</span>
<span class="k">class</span> <span class="nc">UvmSequenceProxy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@exp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">get_userdata</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">create_req</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">create_rsp</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">start_item</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span> <span class="p">:</span> <span class="nb">object</span><span class="p">):</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">finish_item</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span> <span class="p">:</span> <span class="nb">object</span><span class="p">):</span> <span class="p">...</span></code></pre></figure>

<p><strong>exp</strong> methods are ones that will be implemented in Python and will
be called from SystemVerilog. Likewise, <strong>imp</strong> methods will be implemented
in SystemVerilog and called from Python.</p>

<p>The PyHDL-IF code generator creates a SystemVerilog class that implements
this protocol – calling the Python method when an <strong>exp</strong> method is
called in SystemVerilog and calling a SystemVerilog when an <strong>imp</strong> method
is called in Python.</p>

<p>When a new instance of the generated SystemVerilog is created, it results 
in a pair of objects: one in SystemVerilog and a connected peer Python object.</p>

<h1 id="initiating-behavior">Initiating Behavior</h1>

<p>Starting Python behavior from a UVM-SV environment is as simple as selecting
the right <code class="language-plaintext highlighter-rouge">proxy</code> class, creating an instance, and using the <code class="language-plaintext highlighter-rouge">proxy</code> class
object within the UVM-SV environment as if it were a regular UVM object.</p>

<p>Let’s look at an example that implements a UVM sequence in Python.
Let’s look at the Python class before seeing how it is used. The
code below is from the <code class="language-plaintext highlighter-rouge">uvm/sequence_rand_item</code> example:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">hdl_if.uvm</span> <span class="kn">import</span> <span class="n">uvm_sequence_impl</span>

<span class="k">class</span> <span class="nc">PyRandSeq</span><span class="p">(</span><span class="n">uvm_sequence_impl</span><span class="p">):</span> 

    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># Send a small burst of randomized items
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="n">req</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">create_req</span><span class="p">()</span>
            <span class="c1"># Randomize sequence item
</span>            <span class="n">req</span><span class="p">.</span><span class="nf">randomize</span><span class="p">()</span>

            <span class="c1"># Optional visibility
</span>            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">sprint</span><span class="p">()</span>
            <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">"&lt;no sprint available&gt;"</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"PyRandSeq: sending item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span></code></pre></figure>

<p>On a side note, I’ve been finding that AI assistants like Copilot and 
Cline are extremely helpful in creating tests and examples. I created
the code above, along with the rest of the example, using 
<a href="https://cline.bot/">Cline</a>. While the current set of models 
(GPT-5 in this case) does well with many types of code, the only 
mistakes I had to hand-correct were in the SystemVerilog code.</p>

<p>If you look closely, there are two APIs used here that aren’t 
technically UVM APIs: <code class="language-plaintext highlighter-rouge">randomize</code> and <code class="language-plaintext highlighter-rouge">create_req</code>. All the other APIs 
are standard UVM.</p>

<p>Now let’s see how we launch this code from UVM.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="kt">class</span> <span class="n">base_test</span> <span class="k">extends</span> <span class="n">uvm_test</span><span class="p">;</span>
        <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">base_test</span><span class="p">)</span>
        <span class="c1">// ...</span>

        <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="c1">// Python-driven sequence proxy</span>
            <span class="k">typedef</span> <span class="n">pyhdl_uvm_sequence_proxy</span> <span class="p">#(</span>
                <span class="p">.</span><span class="n">REQ</span><span class="p">(</span><span class="n">seq_item</span><span class="p">))</span> <span class="n">py_seq_t</span><span class="p">;</span>
            <span class="n">py_seq_t</span> <span class="n">seq</span><span class="p">;</span>

            <span class="n">phase</span><span class="p">.</span><span class="n">raise_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">py_seq_t</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"seq"</span><span class="p">);</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">pyclass</span> <span class="o">=</span> <span class="s">"pyseq::PyRandSeq"</span><span class="p">;</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_env</span><span class="p">.</span><span class="n">m_seqr</span><span class="p">);</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">drop_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="k">endtask</span>
    <span class="k">endclass</span></code></pre></figure>

<p>In the abbreviated snippet above, the test <code class="language-plaintext highlighter-rouge">run_phase</code> task creates an
instance of <code class="language-plaintext highlighter-rouge">pyhdl_uvm_sequence_proxy</code> that is properly specialized
for the request sequence item type and the Python class, then starts 
the sequence on the sequencer. UVM’s object-oriented nature lets us 
create and use a sequence without caring whether it’s implemented in
Python or SystemVerilog.</p>

<h1 id="pyhdl-if-uvm-api-specifics">PYHDL-IF UVM API Specifics</h1>

<p>Let’s use this example to look more closely at the API exposed by
PYHDL-IF. There are three core categories:</p>
<ul>
  <li>UVM methods that are exposed to Python as-is</li>
  <li>UVM methods whose signature is slightly altered</li>
  <li>Utility methods that are not part of UVM</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">get_name</code> method is an example of a UVM method that is exposed
to Python as-is.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="kt">string</span> <span class="n">get_name</span><span class="p">();</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="p">...</span></code></pre></figure>

<p>While there are a few cosmetic differences, these functions are
practically identical: same user-specified parameters and same 
return type.</p>

<p>The <code class="language-plaintext highlighter-rouge">get_config_object</code> method is an example of a UVM method that
is exposed to Python with slight alterations due to the language.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="kt">bit</span> <span class="n">get_config_object</span><span class="p">(</span><span class="kt">string</span> <span class="n">field_name</span><span class="p">,</span>
                               <span class="kt">inout</span> <span class="n">uvm_object</span> <span class="n">value</span><span class="p">,</span>
                               <span class="kt">input</span> <span class="kt">bit</span> <span class="n">clone</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_config_object</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> 
    <span class="n">field_name</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">clone</span> <span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">UvmObject</span><span class="p">]:</span></code></pre></figure>

<p>The key differences are in the return type and whether in-out
parameters are used. Python discourages returning values via
reference parameters, while this is a common pattern in SystemVerilog.
We follow the Python pattern to better-align with common practice there.</p>

<p>The final category are utility methods that aren’t present in UVM 
at all. Two examples are the <code class="language-plaintext highlighter-rouge">randomize</code> method and the <code class="language-plaintext highlighter-rouge">create_req</code>
method in the UVM sequence Python class. While <code class="language-plaintext highlighter-rouge">randomize</code> isn’t 
part of the UVM API, Python test content benefits from having it.
<code class="language-plaintext highlighter-rouge">create_req</code> exists for similar reasons. In SystemVerilog, we could
refer to the <code class="language-plaintext highlighter-rouge">REQ</code> type parameter of the sequence class to create 
a new request sequence item. In Python, it makes sense to expose
this functionality via a method.</p>

<h1 id="beyond-uvm-methods">Beyond UVM Methods</h1>

<p>The combination of exposing UVM-defined methods to Python, along with and 
two <code class="language-plaintext highlighter-rouge">proxy</code> classes to initiate behavior, makes it simple to run Python 
behavior and interact with the UVM testbench.</p>

<p>One thing you’ve probably noticed about the examples is that user-defined
data isn’t accessed from Python. While we call the <code class="language-plaintext highlighter-rouge">randomize</code> method from 
Python, we aren’t directly controlling the sequence-item fields. In the next 
post, we’ll take a look at how we can get and set the value of SystemVerilog
class fields from Python.</p>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[It’s not necessary to understand very much about how PyHDL-IF implements the bridge between Python and UVM, but useful to understand a bit. Doing so helps to understand what this library is and is not intended to do, and how you can best use it in your verification environment.]]></summary></entry><entry><title type="html">Unlocking the Combined Strength of UVM and Python</title><link href="https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength.html" rel="alternate" type="text/html" title="Unlocking the Combined Strength of UVM and Python" /><published>2025-10-04T00:00:00+00:00</published><updated>2025-10-04T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength.html"><![CDATA[<p>UVM and Python are often positioned as rivals when it comes to their role in 
functional verification, with teams picking one or the other as the basis 
for a verification environments. Each have strengths, though, and using them 
together produces much stronger results. In fact, building on the popularity
of UVM and the availability of UVM verification components provides a 
significant boost to the process of introducing Python to an existing UVM 
environment.</p>

<!--more-->

<h1 id="assessing-languages-for-functional-verification">Assessing Languages for Functional Verification</h1>
<p>Using object-oriented languages to develop hardware verification environments
for simulation and hardware emulation is a longstanding practice. This is 
enabled by the fact that dynamic verification of hardware has a lot in common
with testing software. Aside from constrained randomization, tests for hardware look
very similar to tests for software. Likewise, scoreboards and other analytics
components organize, filter, and categorize data in very software-centric ways.</p>

<p>SystemVerilog is a commonly-used object-oriented language that is 
often used alongside UVM. But, C/C++, Java, and Python have all been used for 
verification for many years with and without UVM.</p>

<p>There are many factors to consider when selecting the languages to use for 
verification. It’s important to consider the features provided by the language, 
the size of its library ecosystem, and the size of the community. All of these 
contribute to the perceived ease with which new content can be developed using 
the language. Given the popularity of AI assistants, it’s also important to consider 
how ‘AI friendly’ the language is.</p>

<p>The Python language ranks highly on these criteria. It is the most popular software
language by several measures, and has been for some time. Development in Python 
is supported by a sizable collection of development tools and libraries. And,
it offers superior results with AI assistants due to the availability of large
volumes of training data for large language models (LLMs).</p>

<h1 id="ease-of-integration-and-reuse">Ease of Integration and Reuse</h1>

<p>But, for hardware verification, two of the most important factors to consider 
are ease of integration into a simulation environment and how readily existing
collateral can be reused. Both of these are critical in assessing how easily
a new language can be incrementally added to existing environments.</p>

<p>When it comes to ease of integration with simulation environments, Python also 
ranks very highly. The <a href="https://www.cocotb.org">cocotb</a> library is a well-known 
and well-maintained library that implements a dynamic integration with simulation 
environments at the signal level using the VPI API. This allows Python-driven tests 
to easily interact with a design at the signal level.</p>

<p>When it comes to reuse of existing infrastructure, the picture with Python is a bit 
more mixed. <code class="language-plaintext highlighter-rouge">cocotb</code> only supports integration at the signal level, which prevents 
reuse of existing SystemVerilog object-oriented collateral.</p>

<p>Having a strong reuse strategy is critical to the success of bringing a new 
verification language into an existing environment. It’s likely that many thousands
of person hours have been applied to building up the verification collateral in
a verification environment. Not only is it prohibitively expensive to re-develop
this in a new language, doing so risks the introduction of instability through
new bugs.</p>

<p>The <code class="language-plaintext highlighter-rouge">pyhdl-if</code> library enables the use of Python with existing SystemVerilog 
classes through the use of generated wrappers. This opens up significant new 
possibilities for reuse, but does come with a cost. In the worst case, each
and every VIP in a verification environment will require a task-based interface
to be designed and developed. This forces teams to be selective in which 
components are exposed to Python which, in turn, limits adoption of Python.</p>

<p>Ideally, we want the best of both when it comes to integration and reuse. 
We want a low-effort integration that also supports seamless reuse of existing
SystemVerilog object-oriented verification collateral.</p>

<h1 id="focusing-on-uvm">Focusing on UVM</h1>

<p>Fortunately, UVM helps to suggest a solution. Because of the popularity of UVM, 
focusing on enabling easy integration with UVM environments is a good 80+% solution.
Recent enhancements to the <code class="language-plaintext highlighter-rouge">pyhdl-if</code> library provide a ready-made integration with
UVM classes, enabling Python behavior to be initiated from UVM and UVM components 
to be used from Python. All without any custom wrapper code.</p>

<p>UVM provides several key areas of functionality, all of which are supported by APIs:</p>
<ul>
  <li>Component structure</li>
  <li>Sequences and sequencers</li>
  <li>Register model</li>
  <li>Configuration database</li>
  <li>Factory</li>
</ul>

<p>In addition to having access to these APIs, we also need to address two challenges:</p>
<ul>
  <li>How to work with user-defined types and data</li>
  <li>How to initiate Python behavior</li>
</ul>

<h1 id="example">Example</h1>

<p>Over the next few posts, we’ll dig into all the details of how this works from a
technical perspective. For now, let’s take a look at a simple example that highlights
just how easy it is to add Python behavior to a UVM environment by leveraging the
UVM API.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/10/pyhdl_uvm_component_proxy.png" />
</p>

<p>This example shows how we can use a <em>component proxy</em> class in SystemVerilog 
to initiate Python behavior from our UVM testbench. As the diagram suggests, 
we will add a new component instance in SystemVerilog that will act as a 
proxy for a UVM component implementation in Python.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">package</span> <span class="n">top_pkg</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">uvm_pkg</span><span class="o">::*</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">pyhdl_uvm</span><span class="o">::*</span><span class="p">;</span>

    <span class="c1">// Test</span>
    <span class="kt">class</span> <span class="n">base_test</span> <span class="k">extends</span> <span class="n">uvm_test</span><span class="p">;</span>

        <span class="n">pyhdl_uvm_component_proxy</span>   <span class="n">m_pycomp</span><span class="p">;</span>

        <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">base_test</span><span class="p">)</span>

        <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"base_test"</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span><span class="p">);</span>
            <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">endfunction</span>

        <span class="k">function</span> <span class="kt">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
            <span class="n">m_pycomp</span> <span class="o">=</span> <span class="n">pyhdl_uvm_component_proxy</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"m_pycomp"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
            <span class="n">m_pycomp</span><span class="p">.</span><span class="n">pyclass</span> <span class="o">=</span> <span class="s">"pycomp::PyComp"</span><span class="p">;</span>
        <span class="k">endfunction</span>

        <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"--&gt; test run_phase"</span><span class="p">);</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">raise_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="c1">// Test stimulus would go here</span>
            <span class="p">#</span><span class="mi">100</span><span class="p">;</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">drop_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"&lt;-- test run_phase"</span><span class="p">);</span>
        <span class="k">endtask</span>
    <span class="k">endclass</span>

<span class="k">endpackage</span></code></pre></figure>

<p>The additions to the SystemVerilog portion of the testbench are minimal. Specifically:</p>
<ul>
  <li>New field for the component proxy</li>
  <li>Construction of the component proxy in the <em>build_phase</em>.</li>
  <li>Specification of the Python class that implements the component</li>
</ul>

<p>Now let’s look at the Python class:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">hdl_if.uvm</span> <span class="kn">import</span> <span class="n">UvmComponentProxy</span>

<span class="k">class</span> <span class="nc">PyComp</span><span class="p">(</span><span class="n">UvmComponentProxy</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">build_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"-- build_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"-- connect_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">run_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Hello from PyComp run_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p>The implementation must inherit from the <em>UvmComponentProxy</em> base class. The
<em>build_phase</em>, <em>connect_phase</em>, and <em>run_phase</em> methods will be invoked by 
the SystemVerilog UVM environment.</p>

<p>And, that’s it. No need to generate API interface classes, and just a few
lines a code needed to get something running.</p>

<p>If you’re interested, you can look at the full code <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm">here</a>.</p>

<h1 id="conclusions-and-next-steps">Conclusions and Next Steps</h1>

<p>Of course, the example above only shows how to get started. 
Over the next few posts, we’ll dive into more detail on the capabilities of the
<code class="language-plaintext highlighter-rouge">pyhdl-if</code> library UVM integration. We’ll also look at usecases for Python in 
a verification environment.</p>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[UVM and Python are often positioned as rivals when it comes to their role in functional verification, with teams picking one or the other as the basis for a verification environments. Each have strengths, though, and using them together produces much stronger results. In fact, building on the popularity of UVM and the availability of UVM verification components provides a significant boost to the process of introducing Python to an existing UVM environment.]]></summary></entry><entry><title type="html">Zuspec: Pythonic Model-Driven Hardware Development</title><link href="https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment.html" rel="alternate" type="text/html" title="Zuspec: Pythonic Model-Driven Hardware Development" /><published>2025-09-22T00:00:00+00:00</published><updated>2025-09-22T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment.html"><![CDATA[<p>Designing and implementing hardware is challenging, and is getting more 
difficult each year as systems become more complex. Design and verification 
teams are looking to boost productivity as a way to keep pace, 
while also looking for ways to provide models of the design behavior to 
software teams earlier. The fragmented and esoteric nature of the languages 
and methodologies used for design and verification only make this more difficult. 
Zuspec aspires to provide a unified, extensible Pythonic framework for multi-abstraction 
hardware modeling that simplifies the design and verification process and 
enables traditional and AI-driven automation.</p>

<!-- more -->

<p>The abstraction gap and model fragmentation are two key drivers of hardware
design-flow complexity. The abstraction difference between a 
natural-language design specification and the register-transfer-level (RTL) 
model that implements it is enormous, and only increasing as designs 
become larger and more complex. It’s natural to prioritize the 
RTL model, since that is required to get to implementation. However, 
because RTL models are detailed and execute slowly, they don’t do a good job of
meeting the needs of adjacent disciplines, such as firmware. 
This delays how early software teams obtain access to a representation of the design,
and limits the platforms on which they can work to fast hardware emulation
or prototyping environments.</p>

<p>Over time, new requirements have resulted in the development of new 
domain-specific languages and language-like class libraries. SystemVerilog, 
PSS, UPF, IP-XACT, SystemC, and others all provide features that address pain 
points of hardware development.  Unfortunately, this has also led to a very 
fragmented ecosystem with loosely-integrated languages and methodologies and 
complex build flows.</p>

<h1 id="considering-the-ecosystem">Considering the Ecosystem</h1>

<p>All of these innovations have primarily come from a hardware-design 
perspective, and focus on enabling hardware-design flows. That,
in itself, is a challenge given the relative sizes of the 
hardware- and software-engineering ecosystems. While it’s 
difficult to find accurate detailed data, US Bureau of Labor 
Statistics reports a labor-market size of 76,800 for hardware 
engineers vs a labor-market size of 1,534,790 for software 
engineers (inclusive of all sub-disciplines in both cases).</p>

<p>Given that the collective challenge is a combined hardware and 
software system, getting buy-in from both disciplines is critical.
It seems quite unlikely that a language created to serve the unique
requirements of the ecosystem’s minority can serve the combined
needs and gain the acceptance of the majority.</p>

<h1 id="zuspec">Zuspec</h1>

<p>Zuspec<a href="https://zuspec.github.io/">1</a> adopts Python as its starting 
point, and embeds hardware semantics into that ecosystem. The result 
is a platform that is familiar to software engineers, offers 
high productivity for hardware engineering, and has the goal of 
increasing the ability to share artifacts across the disciplines.</p>

<h2 id="why-python">Why Python?</h2>

<p>Many factors are involved in selecting a language for any purpose: 
key language features, tool ecosystem, relevant libraries, as well
as the community around the language. Applying an existing language to the 
semantics of another  domains raises another factor to consider: 
flexibility of the language.</p>

<h3 id="popularity-can-be-self-reinforcing">Popularity can be Self-Reinforcing</h3>

<p>Python is a popular language overall, holding the top spot in many
rankings for several consecutive years, and being ranked highly 
for many years before that. Language popularity may not seem relevant
compared to the technical features of a language. Not only it is 
relevant, popularity has a direct bearing on language technical
features. TIOBE [2])(https://www.tiobe.com/tiobe-index/), for example, 
measures language rank in terms of searches via a range of internet 
search engines <a href="https://en.wikipedia.org/wiki/TIOBE_index">3</a>. This is, 
of course, a rough measure a the size of a language’s community. Larger
communities produce more ideas for using a language and, thus,
a a larger library ecosystem. Larger communities more-rapidly
produce and refine adjacent technologies, such as code 
development and package management tools, and new language features.</p>

<p>Popularity often builds upon itself, and there is evidence that 
AI is acting as a driver of Python’s popularity.
Specifically, AI assistants are often reported to be more 
effective with Python than with other languages <a href="https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA">4</a>.
This has the effect of drawing more developers to Python, which
increases the available code in Python, which more-rapidly
increases the quality of results with Python.</p>

<p>But, language popularity is only relevant for the set of languages
that can be used to capture relevant domain semantics. Fortunately,
Python measures up very well here again.</p>

<h3 id="technical-arguments-for-python">Technical Arguments for Python</h3>

<p>There are strong technical arguments for the Python language as well.
As a dynamic language, Python provides excellent facilities for 
introspecting and manipulating a Python description.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">SendPacket</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Struct</span><span class="p">):</span>
  <span class="n">sz</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span>

  <span class="nd">@zdc.constraint</span>
  <span class="k">def</span> <span class="nf">valid_sz</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">sz</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
</code></pre></div></div>

<p>Python <code class="language-plaintext highlighter-rouge">decorators</code> can be used to annotate elements of the description,
identifying specific semantics to be applied to an element or attaching
special processing instructions. For example, the <code class="language-plaintext highlighter-rouge">constraint</code> decorator
above marks the body of the <code class="language-plaintext highlighter-rouge">valid_sz</code> method as having constraint 
semantics.</p>

<p>Python also allows inheritance relationships to be inspected at any
point in time. The base type controls capabilities and restrictions
of the derived type.</p>

<p>While Python can be used as a purely dynamically-typed language, it 
also provides the ability to associate type “hints” with variables. 
The <code class="language-plaintext highlighter-rouge">sz</code> field in the example above specifies that it is an unsigned
8-bit field. This enables the modeler to control how data in the
model will be represented in the implementation.</p>

<p>Finally, Python supports AST introspection and transformation. This 
capability allows tools to access the raw AST for code, such as 
the constraint method above, without needing to use tricks like 
operator overloading.</p>

<p>Statically-typed languages often provide some introspection facilities
that are available during the compilation phase. In contrast, Python 
allows these facilities to be applied to a Python description at any 
point in time, providing much more flexibility in processing flows. 
Effectively, Python allows libraries like Zuspec to act as a compiler
within the Python interpreter.</p>

<p>Python also offers a strong set of system-programming features.
Combined with Python’s dynamic language features, these dramatically
simplify the process of integrating external tools and systems.</p>

<p>Python also specifies a package specification and provides tools
for producing, discovering, and consuming packages.</p>

<p>Together, these capabilities make Python a very compelling platform 
for developing, verifying, and publishing hardware models.</p>

<h1 id="what-does-this-look-like">What does this look like?</h1>

<p>All languages are a combination of syntax and semantics. Syntax 
governs the lexical aspects of a language: the keywords, operators,
and legal ways of arranging them. Semantics governs the meanings of
those statements – for example, whether <code class="language-plaintext highlighter-rouge">a = b</code> changes the value
of the <code class="language-plaintext highlighter-rouge">a</code> variable, changes the <code class="language-plaintext highlighter-rouge">a</code> variable to reference
the <code class="language-plaintext highlighter-rouge">b</code> variable, or something entirely different. Zuspec proposes
a way to adopt full Python syntax, while identifying key regions
in which different semantics apply to this syntax. These new semantics
are always more restrictive than native Python semantics, allowing
existing code checkers (eg mypy) to work unmodified.</p>

<p>Zuspec divides a Python description into two core region kinds:</p>

<ul>
  <li>Pure Python regions</li>
  <li>Python regions with domain-specific semantics</li>
</ul>

<p>Even a simple binary counter highlights several unique semantics that 
a hardware description must capture:</p>

<ul>
  <li>Bit width of the <code class="language-plaintext highlighter-rouge">count</code> field</li>
  <li>When the count should be incremented</li>
  <li>Hardware-specific notions like reset</li>
</ul>

<p>Zuspec identifies regions with these semantics using a combination of
Python <code class="language-plaintext highlighter-rouge">decorators</code> and base classes. The example below shows a 
32-bit counter modeled using the Zuspec library.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Component</span><span class="p">):</span>
  <span class="n">clock</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">input</span><span class="p">()</span>
  <span class="n">reset</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">input</span><span class="p">()</span>
  <span class="n">count</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">output</span><span class="p">()</span>

  <span class="nd">@zdc.sync</span><span class="p">(</span><span class="n">clock</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">reset</span><span class="p">)</span> 
  <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">reset</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> example above illustrates these two regions. By default,
pure Python semantics are used. Consequently, the <code class="language-plaintext highlighter-rouge">import</code> statement
at the top uses pure Python semantics.</p>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> class inherits from the Zuspec <code class="language-plaintext highlighter-rouge">Component</code> class, which
designates it as a class with specific capabilities.  The <code class="language-plaintext highlighter-rouge">inc</code> method
is decorated with the <code class="language-plaintext highlighter-rouge">sync</code> decorator. This marks it as a method that
is automatically evaluated on the active edge of the specified 
clock or reset signals, and a method where deferred assignment is used.
It also marks it as a method that may not be invoked directly.</p>

<p>A class domain with special semantics is a model of implementation, 
and cannot be used directly. Instead, a <code class="language-plaintext highlighter-rouge">Transformer</code> class 
must first be used to create an implementation. In this case, the 
implementation could be pure-Python, Verilog, or something entirely 
different like documentation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">from</span> <span class="n">zuspec.be.py</span> <span class="kn">import</span> <span class="n">ComponentFactory</span>
<span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">CountTB</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Component</span><span class="p">):</span>
  <span class="n">clkrst</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">ClockReset</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="p">{</span><span class="n">period</span><span class="o">=</span><span class="mi">10</span><span class="p">})</span>
  <span class="n">counter</span> <span class="p">:</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">field</span><span class="p">(</span>
      <span class="n">bind</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:{</span>
          <span class="n">s</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">clock</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span>
          <span class="n">s</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">reset</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="n">reset</span>
      <span class="p">})</span>

<span class="k">def</span> <span class="nf">test_smoke</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
  <span class="n">tb</span> <span class="o">=</span> <span class="nc">ComponentFactory</span><span class="p">(</span><span class="n">CountTB</span><span class="p">)</span>
  <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="nf">do_reset</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">tb</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">tb</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">10</span>
</code></pre></div></div>

<p>The example above shows a small testbench around the <code class="language-plaintext highlighter-rouge">Counter</code> 
component with a simple <code class="language-plaintext highlighter-rouge">Pytest</code> unit test. The type transformer 
creates a Python object that is used to dynamically evaluate
the model. While the interface is Python, the implementation
may or may not be Python. For example, the transformer might, 
instead, transform the model to Verilog and create a Verilator 
<a href="https://www.veripool.org/verilator/">5</a>
simulator executable that evaluates the model much faster than
a pure-Python implementation, while still exposing a Python 
interface to the signals.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">Counter</span><span class="p">(</span>
    <span class="kt">input</span>            <span class="n">clock</span><span class="p">,</span>
    <span class="kt">input</span>            <span class="n">reset</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">count</span><span class="p">);</span>

    <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span> <span class="kt">or</span> <span class="kt">posedge</span> <span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="mi">32</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></div></div>

<p>Another transformer might convert the model to the synthesizable
Verilog shown above to be used as input to existing 
synthesis or simulation flows.</p>

<h1 id="the-user-extensible-language">The User-Extensible Language</h1>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> example is quite simple, and at the register-transfer level (RTL).
Zuspec is designed to be able to capture a broad range of 
hardware-centric semantics that cover:</p>

<ul>
  <li>Verification
    <ul>
      <li>Constrained randomization and functional coverage</li>
      <li>Portable test and stimulus (PSS)</li>
      <li>Assertions (SVA)</li>
    </ul>
  </li>
  <li>Hardware design
    <ul>
      <li>RTL</li>
      <li>Medium-level synthesis</li>
      <li>Transaction-level modeling (TLM)</li>
      <li>Register modeling</li>
      <li>Clock and power domains</li>
      <li>Physical design</li>
    </ul>
  </li>
  <li>Firmware
    <ul>
      <li>Register interface</li>
      <li>Specialized memory management</li>
    </ul>
  </li>
</ul>

<p>Zuspec brings a new approach to domain-specific languages that leverages the 
popularity and ecosystem of Python, and embeds domain-specific semantics from
hardware design, verification, and firmware. The big “bet” is that educating
humans and LLMs on the delta between a Python and a set of domain-specific
semantics is far easier than doing the same with a completely new language.</p>

<p>While Zuspec models are captured in Python, processing tools may transform Zuspec 
models into appropriate non-Python implementations such as embedded C or 
synthesizable Verilog.  Zuspec encourages a Pythonic development process for 
hardware that is code-centric, AI-friendly, and nimble. And, most importantly, 
Zuspec provides togetherness: a common environment in which new language 
innovations can be explored along with integrated existing technologies.</p>

<h3 id="references">References</h3>
<ol>
  <li>https://zuspec.github.io</li>
  <li>https://www.tiobe.com/tiobe-index/</li>
  <li>https://en.wikipedia.org/wiki/TIOBE_index</li>
  <li>https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA</li>
  <li>https://www.veripool.org/verilator/</li>
</ol>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[Designing and implementing hardware is challenging, and is getting more difficult each year as systems become more complex. Design and verification teams are looking to boost productivity as a way to keep pace, while also looking for ways to provide models of the design behavior to software teams earlier. The fragmented and esoteric nature of the languages and methodologies used for design and verification only make this more difficult. Zuspec aspires to provide a unified, extensible Pythonic framework for multi-abstraction hardware modeling that simplifies the design and verification process and enables traditional and AI-driven automation. The abstraction gap and model fragmentation are two key drivers of hardware design-flow complexity. The abstraction difference between a natural-language design specification and the register-transfer-level (RTL) model that implements it is enormous, and only increasing as designs become larger and more complex. It’s natural to prioritize the RTL model, since that is required to get to implementation. However, because RTL models are detailed and execute slowly, they don’t do a good job of meeting the needs of adjacent disciplines, such as firmware. This delays how early software teams obtain access to a representation of the design, and limits the platforms on which they can work to fast hardware emulation or prototyping environments. Over time, new requirements have resulted in the development of new domain-specific languages and language-like class libraries. SystemVerilog, PSS, UPF, IP-XACT, SystemC, and others all provide features that address pain points of hardware development. Unfortunately, this has also led to a very fragmented ecosystem with loosely-integrated languages and methodologies and complex build flows. Considering the Ecosystem All of these innovations have primarily come from a hardware-design perspective, and focus on enabling hardware-design flows. That, in itself, is a challenge given the relative sizes of the hardware- and software-engineering ecosystems. While it’s difficult to find accurate detailed data, US Bureau of Labor Statistics reports a labor-market size of 76,800 for hardware engineers vs a labor-market size of 1,534,790 for software engineers (inclusive of all sub-disciplines in both cases). Given that the collective challenge is a combined hardware and software system, getting buy-in from both disciplines is critical. It seems quite unlikely that a language created to serve the unique requirements of the ecosystem’s minority can serve the combined needs and gain the acceptance of the majority. Zuspec Zuspec1 adopts Python as its starting point, and embeds hardware semantics into that ecosystem. The result is a platform that is familiar to software engineers, offers high productivity for hardware engineering, and has the goal of increasing the ability to share artifacts across the disciplines. Why Python? Many factors are involved in selecting a language for any purpose: key language features, tool ecosystem, relevant libraries, as well as the community around the language. Applying an existing language to the semantics of another domains raises another factor to consider: flexibility of the language. Popularity can be Self-Reinforcing Python is a popular language overall, holding the top spot in many rankings for several consecutive years, and being ranked highly for many years before that. Language popularity may not seem relevant compared to the technical features of a language. Not only it is relevant, popularity has a direct bearing on language technical features. TIOBE [2])(https://www.tiobe.com/tiobe-index/), for example, measures language rank in terms of searches via a range of internet search engines 3. This is, of course, a rough measure a the size of a language’s community. Larger communities produce more ideas for using a language and, thus, a a larger library ecosystem. Larger communities more-rapidly produce and refine adjacent technologies, such as code development and package management tools, and new language features. Popularity often builds upon itself, and there is evidence that AI is acting as a driver of Python’s popularity. Specifically, AI assistants are often reported to be more effective with Python than with other languages 4. This has the effect of drawing more developers to Python, which increases the available code in Python, which more-rapidly increases the quality of results with Python. But, language popularity is only relevant for the set of languages that can be used to capture relevant domain semantics. Fortunately, Python measures up very well here again. Technical Arguments for Python There are strong technical arguments for the Python language as well. As a dynamic language, Python provides excellent facilities for introspecting and manipulating a Python description. import zuspec.dataclasses as zdc @zdc.dataclass class SendPacket(zdc.Struct): sz : zdc.Bit[8] = zdc.rand() @zdc.constraint def valid_sz(self): self.sz in [1, 2, 4, 8, 16] Python decorators can be used to annotate elements of the description, identifying specific semantics to be applied to an element or attaching special processing instructions. For example, the constraint decorator above marks the body of the valid_sz method as having constraint semantics. Python also allows inheritance relationships to be inspected at any point in time. The base type controls capabilities and restrictions of the derived type. While Python can be used as a purely dynamically-typed language, it also provides the ability to associate type “hints” with variables. The sz field in the example above specifies that it is an unsigned 8-bit field. This enables the modeler to control how data in the model will be represented in the implementation. Finally, Python supports AST introspection and transformation. This capability allows tools to access the raw AST for code, such as the constraint method above, without needing to use tricks like operator overloading. Statically-typed languages often provide some introspection facilities that are available during the compilation phase. In contrast, Python allows these facilities to be applied to a Python description at any point in time, providing much more flexibility in processing flows. Effectively, Python allows libraries like Zuspec to act as a compiler within the Python interpreter. Python also offers a strong set of system-programming features. Combined with Python’s dynamic language features, these dramatically simplify the process of integrating external tools and systems. Python also specifies a package specification and provides tools for producing, discovering, and consuming packages. Together, these capabilities make Python a very compelling platform for developing, verifying, and publishing hardware models. What does this look like? All languages are a combination of syntax and semantics. Syntax governs the lexical aspects of a language: the keywords, operators, and legal ways of arranging them. Semantics governs the meanings of those statements – for example, whether a = b changes the value of the a variable, changes the a variable to reference the b variable, or something entirely different. Zuspec proposes a way to adopt full Python syntax, while identifying key regions in which different semantics apply to this syntax. These new semantics are always more restrictive than native Python semantics, allowing existing code checkers (eg mypy) to work unmodified. Zuspec divides a Python description into two core region kinds: Pure Python regions Python regions with domain-specific semantics Even a simple binary counter highlights several unique semantics that a hardware description must capture: Bit width of the count field When the count should be incremented Hardware-specific notions like reset Zuspec identifies regions with these semantics using a combination of Python decorators and base classes. The example below shows a 32-bit counter modeled using the Zuspec library. import zuspec.dataclasses as zdc @zdc.dataclass class Counter(zdc.Component): clock : zdc.Bit = zdc.input() reset : zdc.Bit = zdc.input() count : zdc.Bit[32] = zdc.output() @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset) def inc(self): if self.reset: self.count = 0 else: self.count += 1 The Counter example above illustrates these two regions. By default, pure Python semantics are used. Consequently, the import statement at the top uses pure Python semantics. The Counter class inherits from the Zuspec Component class, which designates it as a class with specific capabilities. The inc method is decorated with the sync decorator. This marks it as a method that is automatically evaluated on the active edge of the specified clock or reset signals, and a method where deferred assignment is used. It also marks it as a method that may not be invoked directly. A class domain with special semantics is a model of implementation, and cannot be used directly. Instead, a Transformer class must first be used to create an implementation. In this case, the implementation could be pure-Python, Verilog, or something entirely different like documentation. import asyncio from zuspec.be.py import ComponentFactory import zuspec.dataclasses as zdc @zdc.dataclass class CountTB(zdc.Component): clkrst : zdc.ClockReset = zdc.field(init={period=10}) counter : Counter = zdc.field( bind=lambda s:{ s.counter.clock : s.clkrst.clock, s.counter.reset : s.clkrst.reset }) def test_smoke(self): tb = ComponentFactory(CountTB) asyncio.run(tb.clkrst.do_reset(count=10)) assert tb.counter.count == 0 asyncio.run(tb.clkrst.wait(count=10)) assert tb.counter.count == 10 The example above shows a small testbench around the Counter component with a simple Pytest unit test. The type transformer creates a Python object that is used to dynamically evaluate the model. While the interface is Python, the implementation may or may not be Python. For example, the transformer might, instead, transform the model to Verilog and create a Verilator 5 simulator executable that evaluates the model much faster than a pure-Python implementation, while still exposing a Python interface to the signals. module Counter( input clock, input reset, output reg[31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= {32{1'b0}}; end else begin count &lt;= count + 1; end end endmodule Another transformer might convert the model to the synthesizable Verilog shown above to be used as input to existing synthesis or simulation flows. The User-Extensible Language The Counter example is quite simple, and at the register-transfer level (RTL). Zuspec is designed to be able to capture a broad range of hardware-centric semantics that cover: Verification Constrained randomization and functional coverage Portable test and stimulus (PSS) Assertions (SVA) Hardware design RTL Medium-level synthesis Transaction-level modeling (TLM) Register modeling Clock and power domains Physical design Firmware Register interface Specialized memory management Zuspec brings a new approach to domain-specific languages that leverages the popularity and ecosystem of Python, and embeds domain-specific semantics from hardware design, verification, and firmware. The big “bet” is that educating humans and LLMs on the delta between a Python and a set of domain-specific semantics is far easier than doing the same with a completely new language. While Zuspec models are captured in Python, processing tools may transform Zuspec models into appropriate non-Python implementations such as embedded C or synthesizable Verilog. Zuspec encourages a Pythonic development process for hardware that is code-centric, AI-friendly, and nimble. And, most importantly, Zuspec provides togetherness: a common environment in which new language innovations can be explored along with integrated existing technologies. References https://zuspec.github.io https://www.tiobe.com/tiobe-index/ https://en.wikipedia.org/wiki/TIOBE_index https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA https://www.veripool.org/verilator/]]></summary></entry><entry><title type="html">AI: Instigating a Developer Docs Renaissance?</title><link href="https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance.html" rel="alternate" type="text/html" title="AI: Instigating a Developer Docs Renaissance?" /><published>2025-08-30T00:00:00+00:00</published><updated>2025-08-30T00:00:00+00:00</updated><id>https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance</id><content type="html" xml:base="https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance.html"><![CDATA[<p>There’s been lots of discussion about the future of writing in the AI age.
LLMs have shown their potential as a tool by helping authors of many genres 
brainstorm ideas, rough out content, and more. But, this automation comes
with questions attached. If writing can be automated, 
what is the writer’s role? If LLMs only deliver the illusion of
producing useful content, are we about to experience a deluge of 
unintelligible <a href="https://simonwillison.net/2024/May/8/slop/">slop</a> 
masquerading as useful documentation? I’ve done my share of 
hand wringing while reviewing AI-created code commands and documentation 
that had the form of useful information, but little insightful content. 
A recent coding experience has me seeing an opportunity for a 
developer-docs renaissance driven by the needs of LLMs.</p>

<!-- more -->

<h1 id="developer-docs-and-why-we-dont-create-them">Developer Docs and why we don’t create them</h1>

<p>I define developer docs as the set of documentation that helps a
developer navigate a technical project and understand things like:</p>
<ul>
  <li>How to build the project from source</li>
  <li>How to run tests on the project</li>
  <li>Basic structure and architecture of the project</li>
  <li>Examples of how to interact with the API</li>
  <li>Any special structures used by the project</li>
</ul>

<p>Notes like this have several possible audiences</p>
<ul>
  <li>Colleagues</li>
  <li>Open source project: potential contributors</li>
  <li>Future you</li>
</ul>

<p>I suspect most of us agree that this information is useful,
and don’t truly feel that our code is self-documenting. 
But, it always seems difficult to devote time to writing good 
developer documentation. Why? I think it’s because, 
no matter the audience, developer docs are for the future – 
a future colleague, future collaborator, or future you. And
it’s always tempting to prioritize the ‘now’ when it comes
to choosing between ‘now’ and ‘future’.</p>

<p>LLMs shift that equation by making developer docs immediately 
actionable, and I’m optimistic that this may actually shift 
our behavior.</p>

<h1 id="working-with-complex-projects">Working with Complex Projects</h1>

<p>I was recently working on one of my open source projects. The structure
is a bit complicated due to some of the requirements. Specifically,
I have library projects that consist of:</p>
<ul>
  <li>C++ API consisting of pure-virtual interface classes</li>
  <li>Core implementation in C++</li>
  <li>A Cython wrapper API implemented in terms of the pure-virtual interface classes</li>
</ul>

<p>This structure enables the libraries to be used effiently from C++ and Python,
and allows the library native code to interact directly whether called from
C++ or Python. The downside, of course, is that adding a new class or method
involves changes across several source locations: C++ interface, C++ implementation,
and several locations across the Python interface.</p>

<p>I’ve been using AI assistants (Cline, Copilot) to make modifications to 
this codebase with varying success. On one hand, the results were quite
good given that the only data it had was the code. On the other hand,
there were many cases where the model (gpt-4.1 in this case) would only 
perform a subset of the required changes. In one case, it decided to 
create a new Cython extension file entirely.</p>

<h1 id="developer-docs-as-llm-instructions">Developer Docs as LLM Instructions</h1>

<p>I had independently started to write down some notes about the structure 
of this code. You can find the notes <a href="https://github.com/zuspec/zuspec-dev-docs/blob/main/docs/python_ext_structure.md">here</a>
if you’re interested. Not too complicated, and much more needed of course.</p>

<p>But, when I included this as context for the LLM, the results from the AI assistant
improved dramatically. Still not perfect, but sufficiently better that
I feel more motivated to start a task by writing out some notes. Because,
after all, these notes will be immediately useful as I start working on
the implementation.</p>

<h1 id="looking-forward">Looking Forward</h1>

<p>Writing developer docs and writing code is too-often seen as a zero-sum game:
I can write code <em>or</em> I can write developer documentation. LLMs change this 
by blurring the line between writing docs and code. Writing docs, in fact,
may provide greater leverage by allowing you to drive automation of the 
more-tedious aspects of writing code directly from developer docs.</p>

<p>Looking forward, I’m very interested in what standardization emerges around
capturing and curating context documentation intended for LLMs. Specifically,
I’m watching <a href="https://agents.md/">Agents.md</a> and <a href="https://llmstxt.org/">llms.txt</a>.</p>

<p>Even more immediately, I’m revisiting how I build out the Zuspec Python-embedded
language. I’m planning to take a documentation-first approach, and am interested
to evaluate the impact this has on the development process itself and my ability
to leverage AI assistants along the way.</p>

<p>.</p>]]></content><author><name></name></author><category term="AI" /><summary type="html"><![CDATA[There’s been lots of discussion about the future of writing in the AI age. LLMs have shown their potential as a tool by helping authors of many genres brainstorm ideas, rough out content, and more. But, this automation comes with questions attached. If writing can be automated, what is the writer’s role? If LLMs only deliver the illusion of producing useful content, are we about to experience a deluge of unintelligible slop masquerading as useful documentation? I’ve done my share of hand wringing while reviewing AI-created code commands and documentation that had the form of useful information, but little insightful content. A recent coding experience has me seeing an opportunity for a developer-docs renaissance driven by the needs of LLMs. Developer Docs and why we don’t create them I define developer docs as the set of documentation that helps a developer navigate a technical project and understand things like: How to build the project from source How to run tests on the project Basic structure and architecture of the project Examples of how to interact with the API Any special structures used by the project Notes like this have several possible audiences Colleagues Open source project: potential contributors Future you I suspect most of us agree that this information is useful, and don’t truly feel that our code is self-documenting. But, it always seems difficult to devote time to writing good developer documentation. Why? I think it’s because, no matter the audience, developer docs are for the future – a future colleague, future collaborator, or future you. And it’s always tempting to prioritize the ‘now’ when it comes to choosing between ‘now’ and ‘future’. LLMs shift that equation by making developer docs immediately actionable, and I’m optimistic that this may actually shift our behavior. Working with Complex Projects I was recently working on one of my open source projects. The structure is a bit complicated due to some of the requirements. Specifically, I have library projects that consist of: C++ API consisting of pure-virtual interface classes Core implementation in C++ A Cython wrapper API implemented in terms of the pure-virtual interface classes This structure enables the libraries to be used effiently from C++ and Python, and allows the library native code to interact directly whether called from C++ or Python. The downside, of course, is that adding a new class or method involves changes across several source locations: C++ interface, C++ implementation, and several locations across the Python interface. I’ve been using AI assistants (Cline, Copilot) to make modifications to this codebase with varying success. On one hand, the results were quite good given that the only data it had was the code. On the other hand, there were many cases where the model (gpt-4.1 in this case) would only perform a subset of the required changes. In one case, it decided to create a new Cython extension file entirely. Developer Docs as LLM Instructions I had independently started to write down some notes about the structure of this code. You can find the notes here if you’re interested. Not too complicated, and much more needed of course. But, when I included this as context for the LLM, the results from the AI assistant improved dramatically. Still not perfect, but sufficiently better that I feel more motivated to start a task by writing out some notes. Because, after all, these notes will be immediately useful as I start working on the implementation. Looking Forward Writing developer docs and writing code is too-often seen as a zero-sum game: I can write code or I can write developer documentation. LLMs change this by blurring the line between writing docs and code. Writing docs, in fact, may provide greater leverage by allowing you to drive automation of the more-tedious aspects of writing code directly from developer docs. Looking forward, I’m very interested in what standardization emerges around capturing and curating context documentation intended for LLMs. Specifically, I’m watching Agents.md and llms.txt. Even more immediately, I’m revisiting how I build out the Zuspec Python-embedded language. I’m planning to take a documentation-first approach, and am interested to evaluate the impact this has on the development process itself and my ability to leverage AI assistants along the way. .]]></summary></entry><entry><title type="html">Re-Evaluating EDA DSLs: Becoming the Compiler</title><link href="https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler.html" rel="alternate" type="text/html" title="Re-Evaluating EDA DSLs: Becoming the Compiler" /><published>2025-08-23T00:00:00+00:00</published><updated>2025-08-23T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler.html"><![CDATA[<p>A key benefit of full languages is having full control over processing
the language: being the compiler.  Having full control over language
processing is exactly what enables us target simulation and FPGA bitstream
with the same SystemVerilog source simply by specifying the same source
to different toolchains. Fortunately, Python’s dynamic nature gives us 
all the tools we need to “become the compiler” for portions of the 
Python description that we care about.</p>

<!-- more -->

<h1 id="a-simple-counter">A Simple Counter</h1>

<p>Let’s start with an example. The code below represents the behavior of 
a very simple counter in Verilog:</p>

<figure class="highlight"><pre><code class="language-systenverilog" data-lang="systenverilog">module counter(
  input             clock,
  input             reset,
  output reg[31:0]  count);

  always @(posedge clock or posedge reset) begin
    if (reset) begin
      count &lt;= {32{1'b0}};
    end else begin
      count &lt;= count + 1;
    end
  end

endmodule</code></pre></figure>

<p>When we process this description to create an implementation, there
are a few things that we need to know:</p>

<ul>
  <li>The region of interest – what is a class, module, interface, etc?</li>
  <li>Data member types and kinds – local data vs port with directionality</li>
  <li>Logic/behavior inside the region and when it’s activated</li>
</ul>

<p>A Verilog-based tool establishes these key attributes by lexically processing
the input text.</p>

<p>Let’s create an equivalent representation in Python using our Zuspec 
library.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.reset, reset=lambda s:s.clock):
    def inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1</code></pre></figure>

<p>From one perspective, this is just a Python class that conforms to
the Python’s syntactic and semantic rules. But, we’ve also encoded
some special domain-specific information:</p>

<ul>
  <li>The base class is <code class="language-plaintext highlighter-rouge">Component</code>. A processing tool can identify the “kind” 
of region based on the base type.</li>
  <li>We have typed fields that have direction information attached to them.</li>
  <li>We have tagged a method with a <code class="language-plaintext highlighter-rouge">decorator</code> named “sync”. This identifies
the method as being evaluated with synchronous semantics.</li>
</ul>

<p>You might be asking how this is any different from a class library,
such as SystemC or pyuvm. This is exactly the right question to ask, since
it’s at the crux of how this approach is different.</p>

<h1 id="becoming-the-compiler">Becoming the Compiler</h1>

<p>If we were implementing the Zuspec library as a class library, we would have
each of the key elements above (Component, @sync, input, output) construct
a portion of a description that we could execute. For example, we might 
create an implementation to generate Verilog source. But, committing to 
an implementation is limiting. What if we, instead, wanted to test the 
Python model by simulating it in Python? We would probably need a 
different class library implementation. We’ll definitely want to use 
different implementations for different modules in the system across the
design cycle. Managing which class library implementation each module 
uses gets complicated very quickly.</p>

<p>How else can we approach this problem? Like a compiler, of course. And, Python’s
dynamic programming aspects make this much more straightforward than any other
language that I’m currently aware of.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/08/model_transform.png" /> 
</p>

<p>So, what does this look like?</p>
<ul>
  <li>Treat user input (Counter class above) as having no implementation</li>
  <li>Doing something with the input requires a transformation – a “compiler”</li>
  <li>Transformers take the user-specified class as input and return
    <ul>
      <li>Another Python class type</li>
      <li>A Python data structure with information about a non-Python implementation</li>
    </ul>
  </li>
</ul>

<p>Using this approach allows different transformations to be used for 
different modules in the design.</p>

<h1 id="anatomy-of-a-type-transformer">Anatomy of a Type Transformer</h1>

<p>Type transformers typically use the visitor pattern, using a visitor that
is aware of key elements of the domain-specific specification.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    class MyTransform(api.Visitor):
        _result : str = ""

        def transform(self, t) -&gt; str:
            self._result = ""
            self.visit(t)
            return self._result

        def visitComponentType(self, t):
            self.print("MyV.visitComponentType")
            return super().visitComponentType(t)
        
        def visitInput(self, f):
            self.print("visitInput: %s" % f.name)

        def visitOutput(self, f):
            self.print("visitOutput: %s" % f.name)

        def visitExec(self, name, e):
            self.print("visitExec: %s" % name)

        def print(self, m):
            self._result += m + "\n"</code></pre></figure>

<p>In this case, we’re simply transforming a type model into a string 
that displays the content of the model. But, we could use the same
approach to transform the type to Verilog. And, because the model 
is a specification without a class-library implementation, both
of these implementations (and more) can easily co-exist.</p>

<h1 id="next-steps">Next Steps</h1>

<p>In this post, we’ve looked at an approach to capturing hardware domain
semantics in Python such that we keep the description independent 
of the implementation in the same way a full-custom domain-specific
language does. Moving forward, we’ll focus on getting an implementation
path in place that will let us create Verilog and start to explore
some of the ways that capturing RTL in Python boosts our productivity.</p>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[A key benefit of full languages is having full control over processing the language: being the compiler. Having full control over language processing is exactly what enables us target simulation and FPGA bitstream with the same SystemVerilog source simply by specifying the same source to different toolchains. Fortunately, Python’s dynamic nature gives us all the tools we need to “become the compiler” for portions of the Python description that we care about. A Simple Counter Let’s start with an example. The code below represents the behavior of a very simple counter in Verilog: module counter( input clock, input reset, output reg[31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= {32{1'b0}}; end else begin count &lt;= count + 1; end end endmodule When we process this description to create an implementation, there are a few things that we need to know: The region of interest – what is a class, module, interface, etc? Data member types and kinds – local data vs port with directionality Logic/behavior inside the region and when it’s activated A Verilog-based tool establishes these key attributes by lexically processing the input text. Let’s create an equivalent representation in Python using our Zuspec library. import zuspec.dataclasses as zdc @zdc.dataclass class Counter(zdc.Component): clock : zdc.Bit = zdc.input() reset : zdc.Bit = zdc.input() count : zdc.Bit[32] = zdc.output() @zdc.sync(clock=lambda s:s.reset, reset=lambda s:s.clock): def inc(self): if self.reset: self.count = 0 else: self.count += 1 From one perspective, this is just a Python class that conforms to the Python’s syntactic and semantic rules. But, we’ve also encoded some special domain-specific information: The base class is Component. A processing tool can identify the “kind” of region based on the base type. We have typed fields that have direction information attached to them. We have tagged a method with a decorator named “sync”. This identifies the method as being evaluated with synchronous semantics. You might be asking how this is any different from a class library, such as SystemC or pyuvm. This is exactly the right question to ask, since it’s at the crux of how this approach is different. Becoming the Compiler If we were implementing the Zuspec library as a class library, we would have each of the key elements above (Component, @sync, input, output) construct a portion of a description that we could execute. For example, we might create an implementation to generate Verilog source. But, committing to an implementation is limiting. What if we, instead, wanted to test the Python model by simulating it in Python? We would probably need a different class library implementation. We’ll definitely want to use different implementations for different modules in the system across the design cycle. Managing which class library implementation each module uses gets complicated very quickly. How else can we approach this problem? Like a compiler, of course. And, Python’s dynamic programming aspects make this much more straightforward than any other language that I’m currently aware of. So, what does this look like? Treat user input (Counter class above) as having no implementation Doing something with the input requires a transformation – a “compiler” Transformers take the user-specified class as input and return Another Python class type A Python data structure with information about a non-Python implementation Using this approach allows different transformations to be used for different modules in the design. Anatomy of a Type Transformer Type transformers typically use the visitor pattern, using a visitor that is aware of key elements of the domain-specific specification. class MyTransform(api.Visitor): _result : str = "" def transform(self, t) -&gt; str: self._result = "" self.visit(t) return self._result def visitComponentType(self, t): self.print("MyV.visitComponentType") return super().visitComponentType(t) def visitInput(self, f): self.print("visitInput: %s" % f.name) def visitOutput(self, f): self.print("visitOutput: %s" % f.name) def visitExec(self, name, e): self.print("visitExec: %s" % name) def print(self, m): self._result += m + "\n" In this case, we’re simply transforming a type model into a string that displays the content of the model. But, we could use the same approach to transform the type to Verilog. And, because the model is a specification without a class-library implementation, both of these implementations (and more) can easily co-exist. Next Steps In this post, we’ve looked at an approach to capturing hardware domain semantics in Python such that we keep the description independent of the implementation in the same way a full-custom domain-specific language does. Moving forward, we’ll focus on getting an implementation path in place that will let us create Verilog and start to explore some of the ways that capturing RTL in Python boosts our productivity.]]></summary></entry><entry><title type="html">Re-Evaluating EDA DSLs in the AI Era</title><link href="https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era.html" rel="alternate" type="text/html" title="Re-Evaluating EDA DSLs in the AI Era" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era.html"><![CDATA[<p>I’ve been looking for a new hardware-centric design language for the last couple of years. 
Or, more precisely, I’ve been looking for a hardware-centric design language that would
allow me to realize my ideal silicon design flow.</p>
<ul>
  <li>Must support using the same language to refine a design through a series of abstraction levels – from architecture down to RTL</li>
  <li>Must support fast iteration by supporting both dynamic/executable and static/formal/symbolic evaluation of the same description</li>
  <li>Must support capturing the test, verification, and firmware aspects of a design in addition to the hardware.</li>
  <li>Must be interoperable with existing design flows and environments</li>
</ul>

<p>Until recently, I’ve assumed that a dedicated domain-specific language would be required
to meet these requirements. However, some new observations about languages and 
large language models, coupled with some technical learning has me seeing a different 
path forward for my little project – as well as for future EDA domain-specific languages.</p>

<!-- more -->

<h1 id="why-eda-domain-specific-languages">Why EDA Domain-Specific Languages?</h1>
<p>If you work in silicon design, you’re very familiar with a set of domain-specific languages (DSLs),
such as SystemVerilog and VHDL,  that are used to specify a model of your design intent, 
verify its logical correctness, and synthesize it to a gate-level representation that can
be programmed onto an FPGA or fabricated as an ASIC. These languages exist precisely because 
of the domain (hardware)-specific semantics that we need to capture, and how distinct 
those semantics are from those captured by software languages.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">module counter(
    input clock, reset, enable,
    output reg [31:0] count);

  always @(posedge clock or posedge reset) begin
    if (reset) begin
      count &lt;= 0;
    end else if (enable) begin
      count &lt;= count + 1;
    end
  end
endmodule</code></pre></figure>

<p>Even a simple counter, like the code above, highlights some of the key semantics
unique to hardware.</p>
<ul>
  <li>implicit entrypoint – nothing “calls” the always block</li>
  <li>parallel evaluation – always blocks run concurrently</li>
  <li>synchronized assignment – the new value of ‘count’ doesn’t take effect immediately</li>
</ul>

<p>Typical implementation, such as an event-driven simulator, is very different from 
how this code would be evaluated if it was written in a software language. Having a
language that directly captures the semantics of synchronous digital logic makes us
much more productive.</p>

<p>There certainly are advantages to this approach of creating specific languages for
capturing hardware semantics. We can use whatever syntax we find to most-accurately
convey the semantics that we’re capturing – for example, using ‘&lt;=’ above to denote
an assignment that doesn’t take effect immediately. Having a full, bespoke, language 
also often encourages new applications for the language. For example, Verilog started
off as a simulation language. It was only later that tools started to synthesize
gates from a Verilog description.</p>

<h1 id="the-cost-of-eda-domain-specific-languages">The Cost of EDA Domain-specific Languages</h1>
<p>For all the benefits of having full EDA domain-specific languages, there are 
significant drawbacks.</p>

<p>For one, the cost of designing such a language is high 
precisely because we often want to have standard software features and semantics
alongside our hardware-specific semantics. Creating a whole language necessitates
designing all the details – not just the ones that we’re most interested in 
as hardware designers.</p>

<p>When it comes to languages, community and popularity matter. Community and popularity
lead to tools and libraries built around the language, and people talking about 
how to accomplish things with a language. As hardware designers, 
we represent a very small group compared to the much larger community of software 
engineers. A keynote speaker at DAC this year cited a statistic that the number of 
hardware engineers (inclusive of all disciplines) was less than 10% the number of 
software engineers. Even a language that is wildly popular among hardware engineers
would still be considered a niche language in the broader industry.</p>

<p>Generative AI and LLMs are driving what appears to be a consolidation around 
popular languages recently. In their <a href="https://www.tiobe.com/tiobe-index/">August report</a>, TIOBE (software security analysts, that also track langauge popularity) note a strong
increase in the popularity of Python driven by the proficiency of AI assistants with
Python. Given the cost of training a large language model (LLM), language popularity is likely to become a self-reinforcing pattern: increasing popularity leads to better 
results from LLMs, which further increases the popularity of a language.</p>

<h1 id="alterative-approaches">Alterative Approaches</h1>

<p>Over the years, at least two alternatives to a full domain-specific language have been
used: class libraries and embedded domain-specific languages.</p>

<h2 id="class-libraries">Class Libraries</h2>

<p>A class library is the lightest-weight approach to capturing domain-specific semantics.
In this approach, the host language is used as-is and domain-specific semantics are
captured by creating instances of classes and calling methods from the class library.
Both UVM and SystemC Follow the class-library approach to domain-specific semantics.</p>

<p>This approach encounters challenges when the semantics to be captured run counter to
the host language, or the host language doesn’t support capturing them. For example,
introspecting the value of class fields is of high interest in both SystemC and UVM. 
UVM uses a special set of macros to register user-defined class fields with the 
library.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">class ABC extends uvm_object;
	rand bit [15:0] 	m_addr;
	rand bit [15:0] 	m_data;

	`uvm_object_utils_begin(ABC)
		`uvm_field_int(m_addr, UVM_DEFAULT)
		`uvm_field_int(m_data, UVM_DEFAULT)
	`uvm_object_utils_end
endclass</code></pre></figure>

<p>Exposing access to fields in this way is both a bit cumbersome for the user,
and quite possibly computationally inefficiency because the implementation
must cover so many cases in a generic fashion.</p>

<p>Class libraries also tend to be tightly locked to the their host language
for evaluation. Because a processing tool isn’t able to look at the
structure of user-defined functions, there isn’t an opportunity to represent
them in a different language. If a class library-based description needs to 
target a different language, it typically will build an internal data 
model based on running the model and generate code from that data model.</p>

<h2 id="embedded-domain-specific-languages">Embedded Domain-Specific Languages</h2>

<p>If a class library is insufficient to capture the semantics we require, another
approach is to create an embedded domain-specific language (eDSL) using a language
feature called operator overloading. Not all languages support operator overloading
– for example, SystemVerilog does not. For those that do, operator overloading 
allows us to redefine the implementation of standard operators in specific cases.
This can allow us to create the illusion of writing a different language inside
the confines of our host language.</p>

<p><a href="https://systemc.org/overview/systemc-verification/">SystemC Verification (SCV) library</a> 
provides one example of using operator 
overloading to capture random constraints. The PyVSC library offers another.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    @vsc.constraint
    def ab_c(self):
       self.a &gt; self.b</code></pre></figure>

<p>Python is feature-rich when it comes to operator overloading. The constraint
above looks exactly how you would intuitively expect a ‘greater-than’ constraint
to look. But there are limits.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    @vsc.constraint
    def ab_c(self):
        self.a == 5

        with vsc.if_then(self.a == 1):
            self.b == 1
        with vsc.else_if(self.a == 2):
            self.b == 2</code></pre></figure>

<p>Python doesn’t allow us to override statements, so we need to invent a new
way of capturing constraint statements like if/elsif/else.</p>

<p>Furthermore, Python doesn’t allow us to override some operators. So, we need
to invent another way of capturing logical <code class="language-plaintext highlighter-rouge">and</code>, logical <code class="language-plaintext highlighter-rouge">or</code>, and the <code class="language-plaintext highlighter-rouge">in</code>
operator.</p>

<p>Finally, the code above doesn’t really <em>look</em> like good Python code. Tools
like linters are likely to complain. LLMs will also not know how to create
this content unless specially prompted.</p>

<h1 id="back-to-python">Back to Python</h1>

<p>So, where does that leave us? Well, until recently, right back to needing a full language to
satisfy the requirements. But, as it turns out, Python has a few more features to offer.</p>

<p>Unlike many languages, Python supports introspecting and rewriting code at the <a href="https://docs.python.org/3/library/ast.html">abstract 
syntax tree (AST) level</a>. This feature is mostly
used by linting tools, but is also used by the <a href="https://docs.pytest.org/en/stable/">Pytest</a> 
tool to provide more detail about assertions that fail.</p>

<p>This suggests a new way to look at a Python description:</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">class MyClass(vsc.RandClass):
    a : vsc.rand[vsc.bit[32]]
    b : vsc.rand[vsc.bit[32]]

    @vsc.constraint
    def ab_c(self):
        self.a == 5

        if self.a == 1:
            self.b == 1
        elif self.a == 2:
            self.b == 2</code></pre></figure>

<p>Specifically, all syntax is plain Python syntax – no operator overloading that might
confuse linters or LLMs. We still can use markers, such as base classes and 
decorators, to identify special regions where the semantics differ from plain 
Python execution. For example, the @vsc.constraint decorator marks a method that
contains constraints. Instead of executing these regions to build up a data structure,
we simply use Python’s AST introspection to build the data structure directly.
This allows us to leverage Python syntax, and all the tools that understand it, while
layering our own special semantics on top.</p>

<h1 id="next-steps">Next Steps</h1>

<p>As I mentioned at the beginning of this post, my key interest is in having a modeling
language that supports capturing very abstraction descriptions of hardware behavior
all the way to RTL. While I could start with any of the abstraction levels, I’ve 
decided to start with RTL because that’s where all abstraction levels eventually end 
up. We’ll start looking at a Python-encapsulated description of RTL in the next post.</p>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[I’ve been looking for a new hardware-centric design language for the last couple of years. Or, more precisely, I’ve been looking for a hardware-centric design language that would allow me to realize my ideal silicon design flow. Must support using the same language to refine a design through a series of abstraction levels – from architecture down to RTL Must support fast iteration by supporting both dynamic/executable and static/formal/symbolic evaluation of the same description Must support capturing the test, verification, and firmware aspects of a design in addition to the hardware. Must be interoperable with existing design flows and environments Until recently, I’ve assumed that a dedicated domain-specific language would be required to meet these requirements. However, some new observations about languages and large language models, coupled with some technical learning has me seeing a different path forward for my little project – as well as for future EDA domain-specific languages. Why EDA Domain-Specific Languages? If you work in silicon design, you’re very familiar with a set of domain-specific languages (DSLs), such as SystemVerilog and VHDL, that are used to specify a model of your design intent, verify its logical correctness, and synthesize it to a gate-level representation that can be programmed onto an FPGA or fabricated as an ASIC. These languages exist precisely because of the domain (hardware)-specific semantics that we need to capture, and how distinct those semantics are from those captured by software languages. module counter( input clock, reset, enable, output reg [31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= 0; end else if (enable) begin count &lt;= count + 1; end end endmodule Even a simple counter, like the code above, highlights some of the key semantics unique to hardware. implicit entrypoint – nothing “calls” the always block parallel evaluation – always blocks run concurrently synchronized assignment – the new value of ‘count’ doesn’t take effect immediately Typical implementation, such as an event-driven simulator, is very different from how this code would be evaluated if it was written in a software language. Having a language that directly captures the semantics of synchronous digital logic makes us much more productive. There certainly are advantages to this approach of creating specific languages for capturing hardware semantics. We can use whatever syntax we find to most-accurately convey the semantics that we’re capturing – for example, using ‘&lt;=’ above to denote an assignment that doesn’t take effect immediately. Having a full, bespoke, language also often encourages new applications for the language. For example, Verilog started off as a simulation language. It was only later that tools started to synthesize gates from a Verilog description. The Cost of EDA Domain-specific Languages For all the benefits of having full EDA domain-specific languages, there are significant drawbacks. For one, the cost of designing such a language is high precisely because we often want to have standard software features and semantics alongside our hardware-specific semantics. Creating a whole language necessitates designing all the details – not just the ones that we’re most interested in as hardware designers. When it comes to languages, community and popularity matter. Community and popularity lead to tools and libraries built around the language, and people talking about how to accomplish things with a language. As hardware designers, we represent a very small group compared to the much larger community of software engineers. A keynote speaker at DAC this year cited a statistic that the number of hardware engineers (inclusive of all disciplines) was less than 10% the number of software engineers. Even a language that is wildly popular among hardware engineers would still be considered a niche language in the broader industry. Generative AI and LLMs are driving what appears to be a consolidation around popular languages recently. In their August report, TIOBE (software security analysts, that also track langauge popularity) note a strong increase in the popularity of Python driven by the proficiency of AI assistants with Python. Given the cost of training a large language model (LLM), language popularity is likely to become a self-reinforcing pattern: increasing popularity leads to better results from LLMs, which further increases the popularity of a language. Alterative Approaches Over the years, at least two alternatives to a full domain-specific language have been used: class libraries and embedded domain-specific languages. Class Libraries A class library is the lightest-weight approach to capturing domain-specific semantics. In this approach, the host language is used as-is and domain-specific semantics are captured by creating instances of classes and calling methods from the class library. Both UVM and SystemC Follow the class-library approach to domain-specific semantics. This approach encounters challenges when the semantics to be captured run counter to the host language, or the host language doesn’t support capturing them. For example, introspecting the value of class fields is of high interest in both SystemC and UVM. UVM uses a special set of macros to register user-defined class fields with the library. class ABC extends uvm_object; rand bit [15:0] m_addr; rand bit [15:0] m_data; `uvm_object_utils_begin(ABC) `uvm_field_int(m_addr, UVM_DEFAULT) `uvm_field_int(m_data, UVM_DEFAULT) `uvm_object_utils_end endclass Exposing access to fields in this way is both a bit cumbersome for the user, and quite possibly computationally inefficiency because the implementation must cover so many cases in a generic fashion. Class libraries also tend to be tightly locked to the their host language for evaluation. Because a processing tool isn’t able to look at the structure of user-defined functions, there isn’t an opportunity to represent them in a different language. If a class library-based description needs to target a different language, it typically will build an internal data model based on running the model and generate code from that data model. Embedded Domain-Specific Languages If a class library is insufficient to capture the semantics we require, another approach is to create an embedded domain-specific language (eDSL) using a language feature called operator overloading. Not all languages support operator overloading – for example, SystemVerilog does not. For those that do, operator overloading allows us to redefine the implementation of standard operators in specific cases. This can allow us to create the illusion of writing a different language inside the confines of our host language. SystemC Verification (SCV) library provides one example of using operator overloading to capture random constraints. The PyVSC library offers another. @vsc.constraint def ab_c(self): self.a &gt; self.b Python is feature-rich when it comes to operator overloading. The constraint above looks exactly how you would intuitively expect a ‘greater-than’ constraint to look. But there are limits. @vsc.constraint def ab_c(self): self.a == 5 with vsc.if_then(self.a == 1): self.b == 1 with vsc.else_if(self.a == 2): self.b == 2 Python doesn’t allow us to override statements, so we need to invent a new way of capturing constraint statements like if/elsif/else. Furthermore, Python doesn’t allow us to override some operators. So, we need to invent another way of capturing logical and, logical or, and the in operator. Finally, the code above doesn’t really look like good Python code. Tools like linters are likely to complain. LLMs will also not know how to create this content unless specially prompted. Back to Python So, where does that leave us? Well, until recently, right back to needing a full language to satisfy the requirements. But, as it turns out, Python has a few more features to offer. Unlike many languages, Python supports introspecting and rewriting code at the abstract syntax tree (AST) level. This feature is mostly used by linting tools, but is also used by the Pytest tool to provide more detail about assertions that fail. This suggests a new way to look at a Python description: class MyClass(vsc.RandClass): a : vsc.rand[vsc.bit[32]] b : vsc.rand[vsc.bit[32]] @vsc.constraint def ab_c(self): self.a == 5 if self.a == 1: self.b == 1 elif self.a == 2: self.b == 2 Specifically, all syntax is plain Python syntax – no operator overloading that might confuse linters or LLMs. We still can use markers, such as base classes and decorators, to identify special regions where the semantics differ from plain Python execution. For example, the @vsc.constraint decorator marks a method that contains constraints. Instead of executing these regions to build up a data structure, we simply use Python’s AST introspection to build the data structure directly. This allows us to leverage Python syntax, and all the tools that understand it, while layering our own special semantics on top. Next Steps As I mentioned at the beginning of this post, my key interest is in having a modeling language that supports capturing very abstraction descriptions of hardware behavior all the way to RTL. While I could start with any of the abstraction levels, I’ve decided to start with RTL because that’s where all abstraction levels eventually end up. We’ll start looking at a Python-encapsulated description of RTL in the next post.]]></summary></entry><entry><title type="html">PSS: Getting Outside the Box</title><link href="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html" rel="alternate" type="text/html" title="PSS: Getting Outside the Box" /><published>2025-02-11T00:00:00+00:00</published><updated>2025-02-11T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSGettingOutsideTheBox_splash.png" /> 
</p>

<p>In the <a href="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html">last post</a>, 
we showed a SystemVerilog implementation of a PSS model
that printed “Hello World!”. Interesting, perhaps, but quite a ways from 
being useful. In order to be useful, our PSS model needs to interact with
the environment surrounding it.</p>

<p>This post will cover more details about how a PSS model interacts with 
the environment around it, and look at an object-oriented interface between
PSS and a SystemVerilog environment.</p>

<!--more-->

<p>Both PSS and SystemVerilog are object-oriented languages. With language
interoperability, our goal is to keep each language’s view of inteacting
with the “other” consistent with its own norms and conventions. Because
both languages are object-oriented, we want SystemVerilog to see its
interactions with PSS in object-oriented terms, and vice versa.</p>

<p>While we’re looking at an API in the context of our Zuspec PSS to SystemVerilog
transpiler, the goal is to define a language interoperability approach that
will work with many PSS tools.</p>

<p>Essentially, what we want is this:</p>
<div class="mermaid" align="center">
flowchart TD
    subgraph Model1 ["PSS Model1"]
      BFM1_1["BFM1"]
      BFM1_2["BFM2"]
    end
    subgraph Model2 ["PSS Model2"]
      BFM2_1["BFM1"]
      BFM2_2["BFM2"]
    end

    subgraph Sim ["Simulation"]
      BFM1
      BFM2
      BFM3
      BFM4
    end
    Model1 --&gt; Sim
    Model2 --&gt; Sim

</div>

<p>In other words, we want an integration mechanism that supports:</p>
<ul>
  <li>Multiple, independent, instances of PSS model implementations that run concurrently.</li>
  <li>Multiple “logical streams” within each PSS model instance that
interact with the SystemVerilog testbench</li>
</ul>

<p>The biggest obstacle to achieving this is that both PSS and SystemVerilog
use global functions to implement interactions with the outside world. 
Global functions do not allow us to leverage object-oriented language constructs, so 
we will need to add some infrastructure on top.</p>

<h1 id="the-basics">The Basics</h1>
<p>PSS provides <code class="language-plaintext highlighter-rouge">import</code> functions to allow the PSS model to interact 
with the outside world.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">bfm_c</span> <span class="p">{</span>
  <span class="kd">action</span> <span class="nc">write</span> <span class="p">{</span>
    <span class="c1">// </span>
    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
      <span class="n">bfm_write</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above, two functions are declared – one to perform
a read via a BFM, and one to perform a write. These are global
functions, accessible from all PSS contexts.</p>

<p>The PSS LRM specifies how function parameter and return types are 
mapped to SystemVerilog and C. Theoretically, we could map
the functions themselves to <code class="language-plaintext highlighter-rouge">export</code> tasks and functions
in SystemVerilog.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">interface bfm;
  automatic task bfm_write(int unsigned addr, int unsigned data);
  endtask
  export "DPI-C" task bfm_write;

  automatic task bfm_read(output int unsigned data, input int unsigned addr);
  endtask
  export "DPI-C" task bfm_read;

endinterface</code></pre></figure>

<p>The example above shows SystemVerilog <code class="language-plaintext highlighter-rouge">export</code> tasks that mirror the
PSS <code class="language-plaintext highlighter-rouge">import</code> functions. Conceptually, calling <code class="language-plaintext highlighter-rouge">bfm_write</code> in PSS
would translate into a call to the <code class="language-plaintext highlighter-rouge">bfm_write</code> task in SystemVerilog. 
If we do that, though, we have no awareness of multiple PSS model
instances, and little implementation flexibility.  Fortunately, a 
little methodology and a little code generation can help us
get the object-oriented interfaces that we want!</p>

<h2 id="introducing-the-api-class">Introducing the API Class</h2>
<p>Zuspec-SV (our PSS to SV transpiler) defines an Import API class that
contains a virtual method definition for each and every Import function
in the PSS model.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">class pss_import_api extends backend_api;
   
  virtual task bfm_write(int unsigned addr, int unsigned data);
  endtask

  virtual task bfm_read(output int unsigned data, input int unsigned addr);
  endtask

endclass</code></pre></figure>

<p>The code above shows what would be produced for the <code class="language-plaintext highlighter-rouge">bfm_write</code> and
<code class="language-plaintext highlighter-rouge">bfm_read</code> functions shown earlier. The <code class="language-plaintext highlighter-rouge">import</code> API class inherits
from another API class that defines built-in functions that the PSS
model needs to access. Implementing the API can be done simply by
creating a class that inherits from <code class="language-plaintext highlighter-rouge">pss_import_api</code> and providing
implementations of the tasks and functions.</p>

<h2 id="connecting-our-api-implementation">Connecting our API Implementation</h2>
<p>Once we have a SystemVerilog class with properly-implemented methods, 
we need to connect the PSS model implementation to it. This is where
things get a bit tool-specific.</p>

<p>PSS defines a scenario model as the combination of a tree of 
<em>components</em> and a hierarchy of <em>actions</em> that execute in the
context of the components. <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> refers to this 
component/action combination as an <em>Actor</em>. An <em>Actor</em> is 
implemented as a class that accepts the import API class 
as an argument to its constructor.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_top__Entry_actor extends actor_c;
        pss_top comp_tree;
        pss_import_api api;
        executor_base_c default_executor;

        function new(pss_import_api api=null);
           ...
        endfunction
      ...
    endclass</code></pre></figure>

<p>As we saw in the <em>Hello World</em> example, we run a PSS model
by creating an instance of the <em>Actor</em> and calling the
<em>run</em> task.</p>

<h2 id="full-example">Full Example</h2>
<p>Let’s take a step-by-step look at the simple API implementation example
in <code class="language-plaintext highlighter-rouge">zuspec-examples</code>. You can find the full example 
<a href="https://github.com/zuspec/zuspec-examples/tree/main/sv/simple_read_write">here</a>.</p>

<p>If you want to try this example yourself, be sure to update your <code class="language-plaintext highlighter-rouge">Zuspec-SV</code>
version. You can do so in the <code class="language-plaintext highlighter-rouge">zuspec-examples</code> project by running the
following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% ./packages/python/bin/pip install -U zuspec-sv
</code></pre></div></div>

<p>You will need at least version 0.0.9 to run this example.</p>

<p>Let’s start with the PSS code:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Entry</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">bfm_read</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"PSS read data %d"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We declare two import functions – one that writes data via a bus functional 
model (BFM), and one that reads data via a bus functional model.</p>

<p>We then declare a (very) simple PSS Action that calls the <code class="language-plaintext highlighter-rouge">write</code> function
twice, calls the <code class="language-plaintext highlighter-rouge">read</code> function once, and displays the return value.</p>

<h3 id="implementing-the-api">Implementing the API</h3>

<p><code class="language-plaintext highlighter-rouge">Zuspec-SV</code> creates the following API class based on the import functions
declared within the PSS model:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_import_api #(type BaseT=zsp_sv::empty_t) extends backend_api #(BaseT);
        virtual task bfm_write(
                input int unsigned addr,
                input int unsigned data);
            `ZSP_FATAL(("Import function bfm_write is not implemented"));
        endtask
        virtual task bfm_read(
                output int unsigned __retval,
                input int unsigned addr);
            `ZSP_FATAL(("Import function bfm_read is not implemented"));
        endtask
    endclass</code></pre></figure>

<p>Note that the signature of the <code class="language-plaintext highlighter-rouge">bfm_read</code> task is a bit different. This 
is because SystemVerilog tasks do not support a return value, so the
result must be returned via an output parameter. Fortunately, this is
all well-defined by the rules in the PSS LRM.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">package simple_read_write_pkg;
    import pss_types::*;

    class api_impl extends pss_import_api;
        virtual task bfm_write(
            input int unsigned addr,
            input int unsigned data);
            $display("bfm_write: 'h%08h 'h%08h", addr, data);
        endtask

        virtual task bfm_read(
            output int unsigned __retval,
            input int unsigned addr);
            $display("bfm_read: 'h%08h", addr);
            __retval = 42;
        endtask
    endclass

endpackage</code></pre></figure>

<p>Our testbench environment is responsible for providing code, like 
that shown above, to provide an implementation for the import functions.
Our implementation, here, is quite simple: We print a message when either 
task is called, and return the value <code class="language-plaintext highlighter-rouge">42</code> from the <code class="language-plaintext highlighter-rouge">read</code> function.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module simple_read_write;
    import simple_read_write_pkg::*;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic api_impl api = new();
        pss_top__Entry actor = new(api);

        actor.run();
    end
endmodule</code></pre></figure>

<p>Finally, we can put everything together and run our PSS model. The 
code above creates an instance of our implementation of the API 
class, and passes it to the constructor of our PSS <code class="language-plaintext highlighter-rouge">Actor</code> class.
When we run the simulation, we should see something like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bfm_write: 'h00000000 'h12345678
bfm_write: 'h00000004 'h12345678
bfm_read: 'h00000004
PSS read data 42
</code></pre></div></div>

<h1 id="summary-and-whats-next">Summary and What’s Next</h1>
<p>We’ve looked at the funadamentals of a strategy to integrate two 
object-oriented languages, via global functions, 
in an object-oriented way. This approach
gives us flexibility in changing how APIs are implemented using 
the standard object-oriented approaches that we’re used to.</p>

<p>But, we’re not done just yet. You can likely imagine how this 
approach supports multiple indepdent PSS model instances. But,
how does it support API implementations coming from different
sources, and multiple independent streams of activity within
one PSS model? In the next post, we’ll start to dig into how
to interface PSS to verifcation IP (VIP) and bus functional models (BFMs).</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[In the last post, we showed a SystemVerilog implementation of a PSS model that printed “Hello World!”. Interesting, perhaps, but quite a ways from being useful. In order to be useful, our PSS model needs to interact with the environment surrounding it. This post will cover more details about how a PSS model interacts with the environment around it, and look at an object-oriented interface between PSS and a SystemVerilog environment.]]></summary></entry><entry><title type="html">Transpilation and PSS</title><link href="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html" rel="alternate" type="text/html" title="Transpilation and PSS" /><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSTranspilation_splash.png" /> 
</p>

<p>You’re probably familiar with compilers. They take a high-level input description – 
typically a programming language – and distill it down to an efficient 
low-level implementation. Typically the implementation is machine code or 
bytecode. In other words, as close as possible to what will actually execute 
given the language ecosystem.</p>

<p>You might be less familiar with transpilers (or 
source-to-source compilers, as they are <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">also known</a>). Transpilers convert
an input in one programming language to output in another programming language
with a similar level of abstraction. Transpilers have been in use for a very 
long time. For example, the C++ language was originally implemented with 
<a href="https://en.wikipedia.org/wiki/Cfront">Cfront</a>, a transpiler that converted
C++ input to C code that any C compiler could process. More recently, the 
<a href="https://www.typescriptlang.org/">Typescript</a> and 
<a href="https://en.wikipedia.org/wiki/ECMAScript">Javascript/ECMAScript</a> ecosystems
have used transpilation extensively to allow the languages to evolve while
maintaining an impressive level of backward compatibility with older 
implementations of the language.</p>

<p>The next few posts will start to explore what we can do by transpiling
test scenarios in PSS into implementations in existing programming languages.</p>

<!--more-->

<h1 id="is-pss-a-programming-language">Is PSS a Programming Language?</h1>
<p>Both compilers and transpilers are software concepts, so it’s worth asking
whether PSS language is a programming language. Portions of the language 
do provide the features of a standard programming language – if/else,
loops, functions, and data structures. In this portion of the language,
these constructs retain the same <em>imperative</em> semantics as the 
equivalent constructs in software programming languages.</p>

<p>The other major portion of the language has <em>declarative</em> semantics.
This means that we focus on capturing the <em>rules</em> of our test scenarios
instead of capturing how we will <em>implement</em> our test scenarios.</p>

<h2 id="why-be-declarative">Why be declarative?</h2>

<p>Take, for example, test scenarios that exercise a multi-channel DMA
controller. When our test exercises multiple channels at the same
time, it needs to use unique channels. With PSS, we can simply 
state that this is a rule: DMA channels are <em>resources</em> that 
can only be used by a single behavior at a time.</p>

<p>In contrast, if we are writing our tests in a regular programming 
language, we would need to design a channel-allocation algorithm 
to manage DMA channels for our tests. Actually, we would
probably need several algorithms to handle all the corner cases
that our tests need to cover.</p>

<p>The declarative nature of the PSS language increases our testing
productivity by allowing us to capture the rules of our scenarios
and automate the work of implementing tests.</p>

<h1 id="creating-model-implementations">Creating Model Implementations</h1>
<p>Capturing tests in this way has huge productivity benefits. It also
has a (subjective) downside: we need to use a <em>constraint solver</em> 
to evaluate the model and select the data and operation schedule 
that will be used to exercise the design. Constraints solvers are 
marvelous tools for ripping through reams of constraints, but 
they’re not considered <em>fast</em> when compared to the execution speed 
of regular procedural programming languages. In addition, 
constraint solvers typically require substantial resources to run.</p>

<p>This need to <em>solve</em> the PSS model to generate specific tests, 
along with different verification-platform characteristics,
has resulted in two common ways to produce tests from a PSS model:</p>

<ul>
  <li><strong>On-the-Fly Solving</strong> - This model is typically used in simulation.
A special PSS interpreter and constraint solver run in parallel with
the simulation and make choices as they are needed.</li>
  <li><strong>Pre-Run Test Generation</strong> - This model is typically used when 
the test will run on a processor core within the design. In this model,
the entire test is produced as source code prior to the start of 
test execution.  We want to keep the code that runs on the processor 
core simple for many reasons, and pre-solving the PSS model allows 
us to do this.</li>
</ul>

<p>Both of these models are useful and important, but the on-the-fly
model is very interesting because it suggests that we might be able
to leverage the constraint solver within our SystemVerilog simulators
to provide the solving needed to evaluate our PSS models.</p>

<h1 id="transpiling-pss-to-systemverilog">Transpiling PSS to SystemVerilog</h1>
<p>I’ve been working PSS infrastructure, in general, for a while. More
recently, I’ve focused on using that infrastructure to implement the
beginnings of a PSS to SystemVerilog transpiler.</p>

<p>The general flow is shown below.</p>

<div class="mermaid" align="center">
block-beta
%% columns 5
  block:Source
    columns 1
    PssFiles["PSS Files"]
    Files1
    Files2
    Files3
    Files["PSS Source"]
    style Files1 fill:transparent,stroke:transparent,color:transparent
    style Files2 fill:transparent,stroke:transparent,color:transparent
    style Files3 fill:transparent,stroke:transparent,color:transparent
    style Files fill:transparent,stroke:transparent
  end
  block:Pkgs
    columns 1
    ScenarioPkg["Scenario-Specific Types"]
    ModelPkg["Model-Specific Shared Types"]
    Spacer1
    Spacer2
    Spacer3["Generated SV"]
    style Spacer1 fill:transparent,stroke:transparent,color:transparent
    style Spacer2 fill:transparent,stroke:transparent,color:transparent
    style Spacer3 fill:transparent,stroke:transparent
  end
  block:Runtime
    columns 1
    ScenarioPkg2["Scenario-Specific Types"]
    ModelPkg2["Model-Specific Shared Types"]
    ClassLib["Shared Class Library"]
    SVSolver["SystemVerilog Runtime"]
    Runtime1["Runtime"]
    style Runtime1 fill:transparent,stroke:transparent
  end
  Source--&gt;Pkgs
  Pkgs--&gt;Runtime
</div>

<p>Specifically:</p>
<ul>
  <li>The <a href="https://github.com/zuspec/zuspec-sv/">Zuspec-SV</a> tool processes the PSS model 
source to produce an implementation 
for an Action</li>
  <li>It produces two SystemVerilog packages. The first contains types specific to the action 
being implemented. The second contains types shared across all actions captured in the model</li>
  <li>These packages are compiled along with a supporting class library and the user’s testbench,
and executed by a SystemVerilog simulator.</li>
</ul>

<h1 id="a-simple-example">A simple example</h1>

<p>Let’s take a look at a tiny example from the 
<a href="https://github.com/zuspec/zuspec-examples">Zuspec Examples</a> project.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="nn">std_pkg</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">Hello</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>You can find the soure <a href="https://github.com/zuspec/zuspec-examples/blob/main/sv/hello_world/hello_world.pss">here</a>.</p>

<p>This extremely-simple PSS model prints ‘Hello World!’ to the simulation log.</p>

<p>Have a look at the root SystemVerilog module to see how the SystemVerilog
model implementation is invoked:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module top;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic pss_top__Entry actor = new();
        actor.run();
        $finish;
    end

endmodule</code></pre></figure>

<h1 id="where-do-we-go-from-here">Where do we go from here?</h1>

<p>Transpiling PSS to SystemVerilog provides a useful interesting implementation 
option for PSS, both because of the solver within the simulator and because
PSS is frequently used with UVM testbenches.</p>

<p>If you’re interested in trying out the PSS ‘Hello World’ example, have a look
at the instructions in the 
<a href="https://github.com/zuspec/zuspec-examples/blob/main/README.md">README</a> file.</p>

<p>The <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> transpiler is under active development, but the approach 
looks very promising.  Over the next few posts, we’ll have  look at 
additional PSS constructs that we can implement in SystemVerilog and,
more importantly, see how PSS interacts the testbench and design.</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[You’re probably familiar with compilers. They take a high-level input description – typically a programming language – and distill it down to an efficient low-level implementation. Typically the implementation is machine code or bytecode. In other words, as close as possible to what will actually execute given the language ecosystem. You might be less familiar with transpilers (or source-to-source compilers, as they are also known). Transpilers convert an input in one programming language to output in another programming language with a similar level of abstraction. Transpilers have been in use for a very long time. For example, the C++ language was originally implemented with Cfront, a transpiler that converted C++ input to C code that any C compiler could process. More recently, the Typescript and Javascript/ECMAScript ecosystems have used transpilation extensively to allow the languages to evolve while maintaining an impressive level of backward compatibility with older implementations of the language. The next few posts will start to explore what we can do by transpiling test scenarios in PSS into implementations in existing programming languages.]]></summary></entry></feed>