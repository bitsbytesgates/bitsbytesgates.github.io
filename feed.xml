<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://bitsbytesgates.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bitsbytesgates.com/" rel="alternate" type="text/html" /><updated>2023-05-26T16:09:09+00:00</updated><id>https://bitsbytesgates.com/feed.xml</id><title type="html">Bits, Bytes, and Gates</title><subtitle>There&apos;s oh so much fun to be had. At the leading edge,  at the bleeding edge, at the confluence of bits, bytes, and gates.</subtitle><entry><title type="html">Relating Actions with Dataflow Part2 – Parallelism</title><link href="https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2.html" rel="alternate" type="text/html" title="Relating Actions with Dataflow Part2 – Parallelism" /><published>2023-05-07T00:00:00+00:00</published><updated>2023-05-07T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/05/RelatingActionsPart2_splash.png" />
</p>

<p>A few posts back (<a href="https://bitsbytesgates.com/_posts/2023-03-18-RelatingActionsWithDataflow.html">Relating Actions with Dataflow</a>), 
we talked about using <code class="language-plaintext highlighter-rouge">buffer</code> objects to form a relationship 
between actions that execute sequentially. Because the actions 
execute sequentially, this
relationship looks a lot like function call or the transfer of a 
transaction. What is actually happening is actually a bit more 
involved and much more powerful. Let’s use the DMA engine’s 
‘peripheral interface’ as a vehicle to explore this declarative 
data exchange aspect of the PSS language.</p>

<!--more-->

<h1 id="dma-as-a-service">DMA as a Service</h1>
<p>Many high-speed devices have a built-in DMA engine to offload the
system processor from managing data transfers, and maximize 
overall system performance. For other devices, whether to use
DMA comes down to the characteristics of the system. Some systems
may need the extra throughput that DMA provides, while others
may need the area savings that using a processor to manage
data transfers brings. For this type of device, our DMA Engine’s
peripheral interface provides a compromise approach: devices
can be designed such they can optionally use the channel of
an external DMA engine. This way, whether to use DMA or not
is up to the system architect and not up to the individual
IP designer.</p>

<p>This capability of our DMA engine means that we need to test it
as a feature of the DMA IP using PSS. If we purely focus on 
this, our life is (relatively) straightforward. 
However, because we want our PSS
content to be reusable, we also need to think about how the
PSS test content we create for the DMA engine will interact
with PSS test content created for DMA-optional devices. We will
definitely want these two aspects to easily work together
when testing a system where the architect has provisioned
a device with an external DMA engine channel!</p>

<h1 id="dma-as-a-service-theory-of-operations">DMA as a Service: Theory of Operations</h1>

<p>The DMA engine that we’re working with has a fairly simple 
interface when it comes to supporting external devices.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/05/DMA_HandshakeOperation.png" />
</p>

<p>As shown in the diagram above from the DMA manual, the
peripheral interface involves two signals. The peripheral
device asserts the <em>req</em> line when it wants attention from 
the DMA channel. Once the channel associated with the 
peripheral device is prioritized, the DMA engine 
transfers a burst (1-N) of data to the destination
address and toggles the <em>ack</em> signal.</p>

<p>Over the course of transferring a block of data, a 
peripheral device and the DMA engine are likely to
interact many times.</p>

<h2 id="key-takeaways--and-pss-rules">Key takeaways – and PSS Rules</h2>

<p>Now that we understand a bit more about how the DMA engine
provides “DMA as a service”, it’s time to start organizing
what we know into a set of ‘rules’ that we can use with PSS.
As you’ve likely identified already, a fair portion of a 
PSS model involves ‘rules’ about data relationships 
(constraints), ‘rules’ about what how resources are 
allocated, etc.</p>

<p>Here’s what we know thus far:</p>
<ul>
  <li>A peripheral device and DMA channel have a 1:1 relationship.
We must ensure that the correct channel is used for a given device</li>
  <li>The DMA engine must be told about the external device’s address.</li>
  <li>The channel resource for the DMA channel to which the peripheral
device is connected must be held for the duration of the transfer.</li>
  <li>The action representing the DMA transfer activity must run in 
parallel with the action representing the peripheral device activity.</li>
</ul>

<p>Okay, so this is a bit different from operations we’ve previously
modeled with PSS. The overall data transfer operation between
memory and the device occurs at the same time as the device is
formatting that data and sending it to the world outside 
our system. This certainly means that we can’t use the 
<code class="language-plaintext highlighter-rouge">buffer</code> that we previously used to relate two actions because
the actions are not evaluated sequentially.  Fortunately, PSS 
provides a <code class="language-plaintext highlighter-rouge">stream</code> data type for specifying a data 
relationship between two actions that are run in parallel.</p>

<h2 id="data-to-agree-on">Data to Agree On</h2>

<p>Much like a <code class="language-plaintext highlighter-rouge">buffer</code> type, a <code class="language-plaintext highlighter-rouge">stream</code> type is a struct-like type that
holds user-defined fields. while a <code class="language-plaintext highlighter-rouge">buffer</code> object is used to form
a relationship between two actions that execute sequentially, a 
<code class="language-plaintext highlighter-rouge">stream</code> object is used to form a relationship between two actions
that execute in parallel.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">stream</span> <span class="nc">PeriphDmaStream</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>             <span class="n">periph_addr</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>       <span class="n">mem_h</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">xfer_sz</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">xfer_cnt</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The definition above is for a PSS <code class="language-plaintext highlighter-rouge">stream</code> type that captures the
data that the peripheral device action and the DMA transfer action
must agree on. As you might note, this aligns quite nicely with the
list that we already assembled:</p>
<ul>
  <li>The two actions must agree on the DMA channel to use</li>
  <li>They must agree on the address of the peripheral device, as well
as where data is stored in memory.</li>
  <li>They must agree on how data will be transferred.</li>
</ul>

<h2 id="actions-to-match">Actions to Match</h2>

<p>Now that we’ve captured the data to be shared, let’s sketch out 
the actions that will actually participate in this two-part
transfer. Bear in mind that our goal is that another team can
implement a ‘peripheral’ action for their IP in order to make
use of our DMA controller.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">action</span> <span class="nc">Mem2Dev</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">PeriphDmaStream</span>       <span class="n">ctrl_i</span><span class="p">;</span>
        <span class="k">lock</span> <span class="n">Channel</span>                <span class="n">channel</span><span class="p">;</span>

        <span class="c1">// Acquire the requested channel</span>
        <span class="k">constraint</span> <span class="n">channel</span><span class="o">.</span><span class="n">instance_id</span> <span class="o">==</span> <span class="n">ctrl_i</span><span class="o">.</span><span class="n">channel</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="c1">// Configure the DMA channel in peripheral mode</span>
            <span class="c1">// Program parameters</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Now, here is the matching peripheral-device action:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">Uart</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// Configured during component-tree construction</span>
    <span class="kt">int</span>        <span class="n">dma_channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>    <span class="n">xmit_addr</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">SendMsgDma</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">PeriphDmaStream</span> <span class="n">ctrl_o</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">channel</span>     <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">dma_channel</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">periph_addr</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">xmit_addr</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">mem_h</span>       <span class="o">=</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">addr_h</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">constraint</span> <span class="p">{</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">xfer_cnt</span> <span class="o">==</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">xfer_sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Remember that the DMA engine acts as an assistant in this case.
Consequently, the UART action takes in the data buffer representing
memory to be transmitted. The corresponding receive action would
produce the buffer of memory created from the received data. 
In contrast, the DMA action only accepts instructions on 
how to setup and manage the transfer.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">Uart</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// Configured during component-tree construction</span>
    <span class="kt">int</span>        <span class="n">dma_channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>    <span class="n">xmit_addr</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">SendMsgDma</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">PeriphDmaStream</span> <span class="n">ctrl_o</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kd">action</span> <span class="nc">SendMsgPio</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In addition to making intuitive sense, this modeling approach has
the big benefit of ensuring that the dataflow for UART actions 
is the same whether or not DMA is being used (see above).</p>

<h2 id="creating-scenarios">Creating Scenarios</h2>

<p>Let’s create a small scenario that combines the PSS model for our
DMA engine with the PSS model for our UART to create a scenario
where we use the DMA to automate the data transfer process.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">WbDma</span>              <span class="n">dma</span><span class="p">;</span>
    <span class="n">Uart</span>               <span class="n">uart</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">Scenario</span> <span class="p">{</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Dev</span>   <span class="n">uart_tx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">SendMsgDma</span> <span class="n">uart_dma_tx</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="c1">// ... Create data to transmit</span>

            <span class="c1">// Bind control I/O together</span>
            <span class="k">bind</span> <span class="n">uart_tx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_tx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="n">uart_tx_dma</span><span class="p">;</span>
                <span class="n">uart_dma_tx</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above, we bind the control input/output of the
two actions together and traverse them in parallel. Because the
two actions are connected, they will ‘agree’ on the parameters
of the DMA transfer – specifically, which channel to use,
what the source and destination addresses are, etc.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">WbDma</span>              <span class="n">dma</span><span class="p">;</span>
    <span class="n">Uart</span>               <span class="n">uart</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">Scenario</span> <span class="p">{</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Dev</span>   <span class="n">uart_tx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">SendMsgDma</span> <span class="n">uart_dma_tx</span><span class="p">;</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Dev2Mem</span>   <span class="n">uart_rx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">RecvMsgDma</span> <span class="n">uart_dma_rx</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="c1">// ... Create data to transmit</span>

            <span class="k">bind</span> <span class="n">uart_tx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_tx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">bind</span> <span class="n">uart_rx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_rx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="k">parallel</span> <span class="p">{</span><span class="n">uart_tx_dma</span><span class="p">;</span> <span class="n">uart_dma_tx</span><span class="p">;</span> <span class="p">}</span>
                <span class="k">parallel</span> <span class="p">{</span><span class="n">uart_rx_dma</span><span class="p">;</span> <span class="n">uart_dma_rx</span><span class="p">;</span> <span class="p">}</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>

<p>Buffers and Streams – the PSS mechanism for relating sequential-
and parallel-executing actions act as APIs that allow actions
to interact and cooperate, despite the fact that they may have 
been created by multiple teams for different projects.</p>

<p>Using these <em>action APIs</em> also allows us to easily
scale up our test scenarios while maintaining the validity of the
test. We can build our test-specific rules on top of the rules 
that are built-in to the scenario because of the actions we include
and their relationships. Combined with the automation provided by
random generation, being able to build on top of a well-defined
set of existing scenario rules significantly boosts our 
scenario creation productivity.</p>

<p>Over the past few posts, we’ve looked at some key aspects of the
Accellera Portable Test and Stimulus (PSS) language:</p>
<ul>
  <li>How PSS helps in creating bare-metal SoC tests</li>
  <li>Key elements of the PSS language: actions, components, flow objects, and resources</li>
  <li>Creating multi-core tests with PSS</li>
  <li>Managing memory and accessing registers with PSS</li>
  <li>Modeling random scenarios using rules action relationship rules</li>
</ul>

<p>I hope this has provided a more in-depth view of the PSS language, 
its goals, and its capabilities. As you might guess, though, this intro
to PSS has really only scratched the surface in terms of PSS language
features and modeling approaches. The good news is that there are a 
plethora of open-source hardware designs out there that we can use
to explore these topics!</p>

<h1 id="references">References</h1>
<ul>
  <li>[1] Wishbone DMA Core <a href="https://opencores.org/projects/wb_dma">project page</a></li>
  <li>[2] Wishbone DMA Core <a href="https://bitsbytesgates.com/imgs/2023/03/dma_doc.pdf">manual</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[A few posts back (Relating Actions with Dataflow), we talked about using buffer objects to form a relationship between actions that execute sequentially. Because the actions execute sequentially, this relationship looks a lot like function call or the transfer of a transaction. What is actually happening is actually a bit more involved and much more powerful. Let’s use the DMA engine’s ‘peripheral interface’ as a vehicle to explore this declarative data exchange aspect of the PSS language.]]></summary></entry><entry><title type="html">Interacting with Devices via PSS Registers</title><link href="https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters.html" rel="alternate" type="text/html" title="Interacting with Devices via PSS Registers" /><published>2023-04-18T00:00:00+00:00</published><updated>2023-04-18T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/InteractingWithDevicesViaPssRegisters_splash.png" /> 
</p>
<p>We’ve been looking at properly modeling the types of behaviors that we want
to exercise on our DMA IP for the last few posts. Of course, until we can 
actually start programming the DMA registers, all of our modeling won’t
actually <em>do</em> anything.</p>

<p>PSS provides two primary ways to connect the model of test behavior we 
want to exercise to the device on which we will exercise that behavior:</p>
<ul>
  <li>Calling functions that are implemented in the target environment</li>
  <li>Using PSS features to read/write registers and memory</li>
</ul>

<p>Both of these approaches have benefits and drawbacks. If functions
already exist to program IP registers, leveraging these from PSS
helps to get tests up and running more quickly. However, functions
are typically only implemented in a single language. Greater 
portability is achieved by directly describing the interactions
between PSS model and device registers in PSS.</p>

<p>This post will look at describing the register interface 
using the PSS register model.</p>

<!--more-->

<h1 id="registers-in-different-contexts">Registers in Different Contexts</h1>

<p>Looking across the various contexts in which registers appear, it 
quickly becomes clear that the critical capabilities are
quite different.</p>

<ul>
  <li>Within the RTL implementation of an IP, registers communicate
control values set by firmware to the implementing logic and
feed back status data from hardware to firmware. In addition,
some degree of change event may be useful (eg register written).
In other words, data storage and the structure of that data
are the key care-abouts here.</li>
  <li>In a UVM block-level verification environment, there are a
significant number of overlapping requirements. A UVM register
model captures the structure of data within registers (eg 
named fields), and layout of registers within memory. A
UVM register model enables a shadow copy of register 
contents to be maintained for debug and analysis purposes.
Since access to registers is typically via a memory-mapped
address space, the register model supports mapping between
high-level changes to register values and writes to the
addresses of those modified registers. All in all, the UVM
register model may be the most complex that we work with.</li>
  <li>At system level, we interact with the registers in our
IP blocks and subsystems using firmware. When we’re 
writing this firmware by hand, it’s typical to have a 
set of C ‘#define’ macros that help to calculate the 
address of registers, and that extract and set the value
of register fields. At this level, there’s little to 
no value in caching a copy of the last known value of
a device register.</li>
</ul>

<p>Because PSS has a system-level focus, it’s probably no surprise 
that it focuses on the key capabilities required at system
level: being able to efficiently model how registers fit into
the address space space of a device, and efficiently read and
write them. Unlike the UVM register model, the PSS register
model doesn’t maintain a copy of the data stored in registers.</p>

<h1 id="the-pss-register-model">The PSS Register Model</h1>
<p>The PSS register model focuses on capturing the field layout
of each register, the layout of device registers in the
memory map, and on providing efficient mechanisms for
reading and writing to the device registers.</p>

<p>The key elements to be aware of are:</p>
<ul>
  <li>Register group component that collects registers and sub-groups of registers together</li>
  <li>Register component that describes a single register – often in-line</li>
  <li>Register definition struct that describes the fields of a register</li>
</ul>

<p>Both the register group and register components are pre-defined components
defined by the PSS <em>Core Library</em>. While they are not built-in constructs
in the language, they are special types that tools are expected to 
implement specially.</p>

<h2 id="register-group">Register Group</h2>

<p>We define a register group to contain the top-level registers and register
groups of a device (eg our DMA engine). Or, any time we collections of 
registers that we want to use mulitple times.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/WB_DMA_TopLevel_Channel_Regs.png" />
</p>

<p>Let’s look at the first part of the DMA Engine registers (shown above). We have
some control registers that are common across all of the DMA channels. Then, 
groups of registers that are replicated for each channel.</p>

<p>We will create a register group for the full set of DMA engine registers
and a register group for the per-channel registers. The full DMA engine
register group will contain both the individual registers and an array
of the per-channel register groups.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaChannelRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="n">WbDmaChannelRegs</span>        <span class="n">channels</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<h2 id="register-definition-struct-and-component">Register Definition Struct and Component</h2>

<p>Each register is composed of some number of fields. When these fields have
special meaning, we define a <code class="language-plaintext highlighter-rouge">packed struct</code> to capture the field layout.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/WB_DMA_Channel_SZ_Reg.png" />
</p>

<p>The image above shows the layout of the <em>size</em> register within the block
of per-channel registers. We declare the struct below to capture the 
layout of the fields in the register. Note that the start of the first 
field in the struct corresponds to the lowest bit in the register.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">struct</span> <span class="nc">WbDmaChannelSz</span> <span class="p">:</span> <span class="n">packed_s</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>           <span class="n">TOT_SZ</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>            <span class="n">RESERVED_1</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>            <span class="n">CHK_SZ</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>            <span class="n">RESERVED_2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The struct shown above just defines the layout of data within a
register.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaChannelRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaChannelCSR</span><span class="o">&gt;</span>         <span class="n">CSR</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaChannelSZ</span><span class="o">&gt;</span>          <span class="n">SZ</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SrcAddr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SrcAddrMask</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">DstAddr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">DstAddrMask</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">LinkListPtr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SwPtr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>When declaring a register within a register group, we add a field
of type <code class="language-plaintext highlighter-rouge">reg_c</code> that is parameterized with the data type 
that describes the register. This core data type could be a packed
struct as is shown above. It could also be an integer in cases where
giving names to all the fields isn’t so important.</p>

<p>For example, we use packed structs to define the layout of the CSR
and SZ fields. Address and address-mask fields are defined using
plain integer data types.</p>

<p>From this point on, we simply build up. We define a register struct
for any register whose field layout we care about. We add a 
type-parameterized <code class="language-plaintext highlighter-rouge">reg_c</code> field for each register to its containing
register group, and fields of <code class="language-plaintext highlighter-rouge">reg_group_c</code> type for instances
of register groups.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaCSR</span><span class="o">&gt;</span>         <span class="n">CSR</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_MSK_A</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_MSK_B</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_SRC_A</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_SRC_B</span><span class="p">;</span>

    <span class="n">WbDmaChannelRegs</span>        <span class="n">channels</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>For the DMA engine, this process results in a top-level register block
for the IP such as the one shown above. In this case, we have a few
individual registers and an array of channel register groups.</p>

<h1 id="the-pss-register-model-in-the-real-world">The PSS Register Model in the Real World</h1>

<p>In the prior sections, we manually created a PSS register model.
In practice this is quite rare because, in a production environment,<br />
all of the various register descriptions 
(RTL, UVM, firmware, documentation, etc)
are derived automatically from a single description. That 
central description might be captured in a spreadsheet or
CSV file, IP-XACT document [3], or a SystemRDL description [1].</p>

<p>Personally, I’m very interested in SystemRDL. My feeling is that
it’s easier to create and modify than IP-XACT, and I just learned
about an open source toolchain named 
<a href="https://github.com/orgs/SystemRDL">PeakRDL</a> that can be used to 
derive various outputs from it.</p>

<p>As you begin to look at applying PSS in your environment, it’s
a good idea to understand what single representation your
organization uses for register information, and what 
facilities exist for adding new automatically-derived
output formats.</p>

<h1 id="instantiating-and-connecting-the-register-model">Instantiating and Connecting the Register Model</h1>

<p>Our PSS register model is simply a mechanism for associating
the addresses and bit patterns of memory-mapped registers
with symbolic representations. Consequently, we need to 
connect our register model to an address space before we
can actually use it for reading and writing registers.</p>

<h2 id="connecting-to-register-space">Connecting to Register Space</h2>
<p>Registers are always mapped at some location within the 
address space. In order to determine the correct address
to use when accessing a register, we need to know where
its containing register model is located in memory.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x8000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The code above shows defining a region within the memory
map that is defined as non-allocatable. In other words,
we cannot use <code class="language-plaintext highlighter-rouge">addr_claim_s</code> fields within actions to
claim memory from this region. Note that 
<code class="language-plaintext highlighter-rouge">add_nonallocatable_region</code> returns an address handle that we save.
We will use this handle to specify where the register block 
is located.</p>

<h2 id="connecting">Connecting</h2>
<p>In this little example, the register model that we’re focusing on
is the one and only register model. This is not the case most 
of the time. It’s much more frequently the case that the register
model for our IP is just one part of much larger system-level
register model.</p>

<p>Generally speaking, PSS provides two different strategies for
associating a component with the register model it should use,
and associating the register model with the base address it 
must use:</p>
<ul>
  <li>We can create a large register model that has a base address
and distribute references to register sub-models to components</li>
  <li>We can create a register model per consumer component and 
calculate a base address to associate with each.</li>
</ul>

<h3 id="large-register-model--distribute-refs">Large Register Model ; Distribute Refs</h3>

<p>In this scheme, our DMA component has a reference to the 
register model, not an instance:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>

    <span class="c1">// Handle to the register model</span>
    <span class="kd">ref</span> <span class="n">WbDmaRegs</span>           <span class="n">regs</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>The code that uses the register model doesn’t care whether it is
using a reference or an instance of a register model. Either way,
registers get written and read.</p>

<p>The register for all instances of our DMA engine are included in
the top-level register model, as shown below.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">SysRegModel</span> <span class="p">:</span> <span class="n">reg_group_c</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">WbDmaRegs</span>           <span class="n">dma0</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, our system-level register model is instanced at the top
level of the component tree.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>

    <span class="n">SysRegModel</span>                              <span class="n">regs</span><span class="p">;</span>

    <span class="n">WbDma</span>                                    <span class="n">dma0</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="c1">// ...</span>
        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">regs</span><span class="o">.</span><span class="n">set_handle</span><span class="p">(</span><span class="n">mmio_h</span><span class="p">);</span>

        <span class="n">dma</span><span class="o">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">dma0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>A few things are going on here:</p>
<ul>
  <li>After obtaining a handle to the root of the memory-mapped I/O
space, we configure this as the base address of the system
register map by calling the <code class="language-plaintext highlighter-rouge">set_handle</code> function on the system
register model.</li>
  <li>Next, we hook set the register-model reference field in the 
dma0 component instance to point to its instance of the 
register in the system register model.</li>
</ul>

<p>And, with that we’re done. The advantages of this approach are that
we’re only concerned with the base address of the full register
space and it might be easier to construct this ‘super’ register
model using automation tools. We also have the option to directly
reach down through the register model to access registers. 
The biggest downside is a loss of some degree of modularity.</p>

<h3 id="individual-register-models--distribute-base-addresses">Individual Register Models ; Distribute Base Addresses</h3>

<p>This approach is nearly mirror image of the previous approach. 
In this approach, each component with registers “owns” its 
register block and we distribute base-address handles.</p>

<p>So, here’s the DMA component:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>

    <span class="c1">// DMA register model</span>
    <span class="n">WbDmaRegs</span>           <span class="n">regs</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Note that we have full register model instance here, instead of
just a reference.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>

    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="c1">// ...</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">dma</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">set_handle</span><span class="p">(</span><span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">mmio_h</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>At the top level, things are a bit different as well. There is not
unified top-level register model. Instead of setting the DMA 
register-model handle within the DMA component, we set the base address
handle on the register-model instance within the DMA component. Note
that we need to compute the proper offset to create the correct address
handle for the DMA registers.</p>

<h1 id="using-the-register-model">Using the Register Model</h1>
<p>Now that we have our register model integrated and connected, we can
write PSS test realization code to program a DMA channel to perform
a transfer.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
        <span class="c1">// Setup the transfer size</span>
        <span class="n">WbDmaChannelSZ</span> <span class="n">sz</span><span class="p">;</span>
        <span class="n">sz</span><span class="o">.</span><span class="n">CHK_SZ</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">sz</span><span class="o">.</span><span class="n">TOT_SZ</span> <span class="o">=</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// We always work in words</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">SZ</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>

        <span class="c1">// Configure source and destination addresses</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">INT_SRC_A</span><span class="o">.</span><span class="n">write_val</span><span class="p">(</span><span class="n">addr_value</span><span class="p">(</span><span class="n">src_i</span><span class="o">.</span><span class="n">addr_h</span><span class="p">));</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">INT_DST_A</span><span class="o">.</span><span class="n">write_val</span><span class="p">(</span><span class="n">addr_value</span><span class="p">(</span><span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span><span class="p">));</span>

        <span class="c1">// Enable the channel</span>
        <span class="n">WbDmaChannelCSR</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">CH_EN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>

        <span class="c1">// Wait for the transfer to complete</span>
        <span class="k">repeat</span> <span class="p">{</span>
            <span class="n">csr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
            <span class="c1">// ...</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">DONE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>First, we’ll want to configure a couple of details about the 
size of the transfer. For this, we use the WbDmaChannelSZ packed struct to 
properly format data to write to the register.</p>

<p>Next, we’ll setup the source and destination addresses. For these, we will
use the <code class="language-plaintext highlighter-rouge">write_val</code> function to just write the address value to the register.</p>

<p>We need to enable the channel before the transfer will start. To do this, 
we want to modify a bit within the configuration and status register while
leaving the other fields as-is. To do this, we can read the value of the
CSR into a register struct, set the <code class="language-plaintext highlighter-rouge">CH_EN</code> bit, then write it back 
to the register.</p>

<p>At this point, the DMA engine will begin transferring memory. Finally, we
need to wait until the channel’s <code class="language-plaintext highlighter-rouge">DONE</code> bit is set. This signals that the
transfer is complete. Here, again, we use the register struct to make it
easy to extract the bits that we care about.</p>

<p>This code is concise and easy to write – generally much more so than
the equivalent hand-coded bare-metal C code. The great thing, of course,
is that the resulting implementation is just as efficient as if it 
were hand-coded in C.</p>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>

<p>We have now worked through all the key topics in exercising the 
memory to memory copy functionality of our DMA engine. We’ve looked
at:</p>
<ul>
  <li>Buffers to represent data transfer between sequential actions</li>
  <li>Memory management to remove complexity from our tests</li>
  <li>Resource management to ensure concurrent test behavior doesn’t
collide over resource usage like DMA channels</li>
  <li>And finally, using the PSS register model to capture the layout
of registers and register blocks, and access device registers.</li>
</ul>

<p>But, if you remember, there is one other key part of the DMA
engine’s functionality: supporting DMA transfer for peripheral
devices without their own internal DMA engines. Modeling this
type of behavior brings unique challenges. Especially so when 
we want to be able to exercise that behavior with multiple different 
devices at the system. In the next post, we’ll look at approaches
for modeling this with PSS.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://www.accellera.org/images/downloads/standards/systemrdl/SystemRDL_2.0_Jan2018.pdf">SystemRDL 2.0 LRM</a></li>
  <li>[2] <a href="https://github.com/orgs/SystemRDL">PeakRDL</a></li>
  <li>[3] <a href="https://www.accellera.org/downloads/standards/ip-xact">IP-XACT</a></li>
  <li>[4] <a href="https://bitsbytesgates.com/code_html/2023/04/wb_dma_4_registers.html">DMA Example (Viewing)</a></li>
  <li>[5] <a href="https://bitsbytesgates.com/code/2023/04/wb_dma_4_registers.pss">DMA Example (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[We’ve been looking at properly modeling the types of behaviors that we want to exercise on our DMA IP for the last few posts. Of course, until we can actually start programming the DMA registers, all of our modeling won’t actually do anything. PSS provides two primary ways to connect the model of test behavior we want to exercise to the device on which we will exercise that behavior: Calling functions that are implemented in the target environment Using PSS features to read/write registers and memory Both of these approaches have benefits and drawbacks. If functions already exist to program IP registers, leveraging these from PSS helps to get tests up and running more quickly. However, functions are typically only implemented in a single language. Greater portability is achieved by directly describing the interactions between PSS model and device registers in PSS. This post will look at describing the register interface using the PSS register model.]]></summary></entry><entry><title type="html">PSS Concurrency and Resources</title><link href="https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources.html" rel="alternate" type="text/html" title="PSS Concurrency and Resources" /><published>2023-04-09T00:00:00+00:00</published><updated>2023-04-09T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/DMAModelingResourcesWithPSS_splash.png" /> 
</p>

<p>Resource contention is a challenge that arises any time concurrency and 
shared resources (data, hardware accelerators, etc) are involved. It’s one
of the big challenges, and source of bugs, in implementing code that takes
advantage of parallelism. 
When it comes to hardware resources, safe access to shared resources is 
generally managed in production by the operating system. There are two big 
reasons that using this same approach for bare-metal tests isn’t a good solution:</p>
<ul>
  <li>First, and most obvious, is that our bare-metal tests don’t have an
operating system to use in managing access to shared devices</li>
  <li>Second, and more interesting, is that our tests are constraint 
guided and seek to exercise as many unique corner cases as possible.
In contrast, the OS can focus simply on providing correct results, and
doesn’t need t be as concerned with being able to produce interesting
and unique corner cases.</li>
</ul>

<p>The good news, as you might guess, is that PSS provides constructs for modeling
available resources and how actions can make use of them without 
conflicts – whether the actions are executing sequentially or 
concurrently. Let’s dig in and learn more.</p>

<!--more-->

<h1 id="resources-and-the-dma-example">Resources and the DMA Example</h1>
<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/DMA_block_diagram.png" />
</p>

<p>In the DMA example, the most obvious features that must be managed
as a resource are the channels. Channels can execute memory
transfers in parallel – an important usecase for the IP. Eventually,
the OS driver for the DMA will manage satisfying requests for a 
DMA channel. But, for now, our test will need to manage allocating
channels itself.</p>

<h1 id="pss-resource-management-in-three-parts">PSS Resource Management in Three Parts</h1>

<p>There are three key parts to managing resources in PSS.</p>
<ul>
  <li>A data type to encapsulate data related to the resource kind</li>
  <li>A pool of a given resource kind that specifies the number of
available resources</li>
  <li>A resource claim on an action to acquire a resource with 
specific characteristics</li>
</ul>

<h2 id="resource-type">Resource Type</h2>

<p>A <em>resource</em> data type is declared using the <code class="language-plaintext highlighter-rouge">resource</code> keyword.
A resource type is very similar to a struct, in that it can
contain random and non-random data fields and constraints.</p>

<p>A <em>resource</em> data type has one built-in field named
<code class="language-plaintext highlighter-rouge">instance_id</code>. The <code class="language-plaintext highlighter-rouge">instance_id</code> field is a simple but effective
way to uniquely identify a resource instance.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">MemBuf</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span>        <span class="n">size</span><span class="p">;</span> <span class="c1">// Size of the data</span>
    <span class="n">addr_handle_t</span>       <span class="n">addr_h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">resource</span> <span class="nc">Channel</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In the case of the DMA engine, the key thing we need to know is
to which DMA channel an action is assigned. Consequently, our
resource type <code class="language-plaintext highlighter-rouge">Channel</code> doesn’t contain any custom fields.</p>

<h2 id="resource-pool">Resource Pool</h2>

<p>In prior posts, we’ve hand-waved a bit about where <code class="language-plaintext highlighter-rouge">buffer</code> pools
are placed, and how they are statically bound to actions.
Now that we have resources, we need to be a bit more mindful of 
pools, where they are placed, and how actions are bound to them.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>The bind directive connects a pool to a set of actions that 
reference that <code class="language-plaintext highlighter-rouge">flow-object</code> type. In our case, we have 
placed the resource pool inside the <code class="language-plaintext highlighter-rouge">WbDma</code> component and
bound it to all actions that claim a <code class="language-plaintext highlighter-rouge">Channel</code> resource because
channels are a property of a specific DMA engine instance. Actions
running on that instance of a DMA engine IP have access to the
available channels. Actions running on a different instance have
access to a different set of channels.</p>

<p>Note that a <code class="language-plaintext highlighter-rouge">resource</code> pool always has a size, unlike<br />
<code class="language-plaintext highlighter-rouge">buffer</code> pools that are unsized. The specified size
states exactly how many resources exist in the pool.</p>

<p>As in previous posts, our <code class="language-plaintext highlighter-rouge">WbDma</code> component is instantiated inside the
top component in the componet tree, <code class="language-plaintext highlighter-rouge">pss_top</code>.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s say we add another instance of the DMA engine:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma_1</span><span class="p">;</span>
    <span class="n">WbDma</span>                                    <span class="n">dma_2</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Everything will work as we expect with the <code class="language-plaintext highlighter-rouge">resource</code> pool 
local to each DMA component, and resource claims on actions 
within the DMA Component bound to that local pool. When an
action runs on the <code class="language-plaintext highlighter-rouge">dma_1</code> instance, it will contend with
other actions running on that component for the
available 16 channels. Likewise, for an action running 
on the <code class="language-plaintext highlighter-rouge">dma_2</code> instance.</p>

<p>What would be different if we moved the resource pool up
a level?</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>                        <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma_1</span><span class="p">;</span>
    <span class="n">WbDma</span>                                    <span class="n">dma_2</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Now, all actions that run on either <code class="language-plaintext highlighter-rouge">dma_1</code> or <code class="language-plaintext highlighter-rouge">dma_2</code>
contend for the same set of shared channel resources 
because all actions are bound to the same resource pool.</p>

<p>Doing things this way doesn’t make sense for our DMA 
example, but certainly makes sense in other cases. For example,
consider a case where we have a family of algorithm 
accelerators - each with their own distinct actions - that all need to use
some shared resource such as a shared DMA engine. In that 
case, having all actions share the same resource pool would 
make sense.</p>

<h2 id="resource-claim">Resource Claim</h2>

<p>Finally, we reach the point where we can have our DMA actions
claim a resource. Actions claim resources using a special 
<code class="language-plaintext highlighter-rouge">lock</code> or <code class="language-plaintext highlighter-rouge">share</code> field within the action. Much like the 
<code class="language-plaintext highlighter-rouge">input</code> and <code class="language-plaintext highlighter-rouge">output</code> fields used with buffers, declaring
a resource lock or share field causes the PSS tool to make
the field point to a resource that matches any criteria
the user has specified for the resource.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
    <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
    <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>
    <span class="k">lock</span> <span class="n">Channel</span>            <span class="n">channel</span><span class="p">;</span>

    <span class="c1">// Input and output size must be the same</span>
    <span class="k">constraint</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">src_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In the case above, the only criteria the action places on the
resource is that it needs to have exclusive (lock) access to
it. No other action can use the channel at the same time.</p>

<p>It’s also possible to use constraints to add more criteria
on selection of a resource. Take the example test below:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">extend</span> <span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">TestParallelXfer</span> <span class="p">{</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In this case, we are very specific about which channels two of 
the three transfers should run on. Perhaps that is because we 
want to exercise some aspect of the arbitration scheme. 
For the third parallel transfer, we request a channel less than 8. 
The PSS tool will randomly select an appropriate channel, while not 
selecting channels 0 or 1.</p>

<h1 id="locking-vs-sharing-a-resource">Locking vs Sharing a Resource</h1>
<p>In the case of the DMA example, acquiring exclusive access to a DMA channel
(locking it) is the appropriate choice. In fact, locking resources is 
probably the most common use case. However, there are certainly valid
cases where we need to allow multiple actions to access the same resource.</p>

<p>The most straightforward case for shared access to a resource is when a
resource provides some useful information that can be read by multiple
actions. In this case, actions that wish to read the information should
acquire the resource as a <code class="language-plaintext highlighter-rouge">share(d)</code> resource. Actions wishing to write
the information should acquire the resource as a <code class="language-plaintext highlighter-rouge">lock(ed)</code> resource. 
Doing this will enable multiple actions to read information from the
resource-protected element, while ensuring that no action is 
simultaneously trying to change the stored information.</p>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>
<p>In this post, we’ve seen how PSS enables the definition of resources
that can only be used in certain ways by certain actions over time, 
and have seen how PSS resources can be applied to describe restrictions
on how DMA channels can be used over time by concurrent behavior.</p>

<p>In the next post, we’ll look at using PSS <code class="language-plaintext highlighter-rouge">registers</code> to connect the 
actions in our PSS model to the registers within the DMA engine.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://bitsbytesgates.com/code_html/2023/03/wb_dma_3.html">DMA PSS Code (Viewing)</a></li>
  <li>[2] <a href="https://bitsbytesgates.com/code/2023/03/wb_dma_3.pss">DMA PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Resource contention is a challenge that arises any time concurrency and shared resources (data, hardware accelerators, etc) are involved. It’s one of the big challenges, and source of bugs, in implementing code that takes advantage of parallelism. When it comes to hardware resources, safe access to shared resources is generally managed in production by the operating system. There are two big reasons that using this same approach for bare-metal tests isn’t a good solution: First, and most obvious, is that our bare-metal tests don’t have an operating system to use in managing access to shared devices Second, and more interesting, is that our tests are constraint guided and seek to exercise as many unique corner cases as possible. In contrast, the OS can focus simply on providing correct results, and doesn’t need t be as concerned with being able to produce interesting and unique corner cases. The good news, as you might guess, is that PSS provides constructs for modeling available resources and how actions can make use of them without conflicts – whether the actions are executing sequentially or concurrently. Let’s dig in and learn more.]]></summary></entry><entry><title type="html">PSS Memory Management Fundamentals</title><link href="https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS.html" rel="alternate" type="text/html" title="PSS Memory Management Fundamentals" /><published>2023-04-02T00:00:00+00:00</published><updated>2023-04-02T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/MemoryManagement_splash.png" /> 
</p>

<p>Storage (memory) is right in the middle of all the work with do with
computer architecture. We have different kinds of memory that each have different
trade-offs around performance (latency / throughput), cost per unit,
and power consumption. We arrange memories into hierarchies with 
the goal of keeping frequently-used data in the upper 
(faster, but limited) layers, while pushing infrequently-accessed data 
to the lower (slower, but more expansive) layers.</p>

<p>Given the large amount of time time designers spend thinking about 
memory needs, it’s no surprise that creating good and capable tests 
to exercise those designs depends on being able to acquire the right 
type of memory at the right time in order to fully-exercise the 
capabilities and characteristics of the system.</p>

<!--more-->

<p>Remember, though, that we’re writing bare-metal tests. Consequently, we need 
to allocate memory for our test behaviors ahead of time in order to not waste valuable
simulation or emulation time running the ‘malloc’ and ‘free’ algorithm. 
When done by hand, static allocation can limit how reusable code is and
remove the majority of variability (ie randomness) from test scenarios. Fortunately, 
PSS provides some easy to use features that allow actions to manage memory that 
they require in a way that enables static allocation while not limiting 
variability or reuse. Let’s dig in!</p>

<h1 id="test-requirements-for-memory-management">Test Requirements for Memory Management</h1>
<p>System-level tests have three core requirements when it comes to 
memory management:</p>
<ul>
  <li>Ensure that behaviors needing distinct blocks of memory are provided non-overlapping
blocks of memory</li>
  <li>Ensure behaviors that need to share data see the same memory</li>
  <li>Ensure that a test is able to explicitly specify the general
location in memory (eg SRAM, DDR, etc) where a memory block
comes from.</li>
</ul>

<p>One of the biggest challenges with hand-written bare-metal
tests is implementing these three characteristics in a distributed
and modular way.</p>

<p>There are two parts of the PSS memory management approach:</p>
<ul>
  <li>Specification of available memory resource</li>
  <li>Specification of claims on those resources, and how the claimed data is used.</li>
</ul>

<h1 id="using-memory-in-behaviors">Using Memory in Behaviors</h1>
<p>Let’s start with the second point – how we claim memory – since we can see 
immediately how that fits into our DMA example.</p>

<p>In PSS, an action claims memory by having one or more random fields of type
<em>addr_claim_s</em>. The action can control how much memory is being requested,
and its alignment, by constraining the fields of the claim.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">MemBuf</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span>    <span class="n">size</span><span class="p">;</span> <span class="c1">// Size of the data</span>
    <span class="n">addr_handle_t</span>   <span class="n">addr_h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// Input and output size must be the same</span>
        <span class="k">constraint</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">src_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>

        <span class="c1">// DMA only transfers words</span>
        <span class="k">constraint</span> <span class="p">(</span><span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> 

        <span class="c1">// Specify size/alignment for allocation</span>
        <span class="k">constraint</span> <span class="n">dst_claim</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
        <span class="k">constraint</span> <span class="n">dst_claim</span><span class="o">.</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span> <span class="o">=</span> <span class="n">make_handle_from_claim</span><span class="p">(</span><span class="n">dst_claim</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Okay, we’ve added a few things to the skeleton Mem2Mem action that
we created in the last post:</p>
<ul>
  <li>Added a <code class="language-plaintext highlighter-rouge">size</code> field to <code class="language-plaintext highlighter-rouge">MemBuf</code> to ensure that producers and consumers
of this type agree on the data size.</li>
  <li>Added an ‘addr_h’ field to <code class="language-plaintext highlighter-rouge">MemBuf</code> that will hold a handle to the allocated
memory block.</li>
  <li>Add a claim field (<code class="language-plaintext highlighter-rouge">dst_claim</code>) to the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action that will cause 
memory to be allocated for the DMA destination memory</li>
  <li>Add constraints to:
    <ul>
      <li>Relate the source and destination buffer objects.</li>
      <li>Relate the source and destination buffer objects.</li>
    </ul>
  </li>
</ul>

<p>One new thing is that we assign the address handle to a field in the output 
buffer within the <code class="language-plaintext highlighter-rouge">post_solve</code> exec block inside the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action. 
This is done in order to make the address available to the consumer of the 
buffer. Why does this work? 
PSS specifies that two actions that are connected by a buffer object 
both have a handle to exactly the same object. That means that when the 
outputting action assigns a value to a field, it is assigning to the 
exact field that the inputting action will read.</p>

<h2 id="specifying-memory-claim-lifetimes">Specifying Memory Claim Lifetimes</h2>

<p>By default, the lifetime of a memory claim is the same as the action containing
it.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the context of our example, that means that <code class="language-plaintext highlighter-rouge">dst_claim</code> would be released
as soon as the DMA transfer completes. Clearly, that’s not what we want since we
are claiming <code class="language-plaintext highlighter-rouge">dst_claim</code> in order to provide data to another action.</p>

<p>The solution is to <em>extend</em> the lifetime of the memory claim by attaching 
it to something with a longer lifetime. In this case, that thing with a 
longer lifetime is, very naturally, the output buffer, since we intend the 
lifetime of the buffer and the lifetime of our memory claim to match.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// ...</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span> <span class="o">=</span> <span class="n">make_handle_from_claim</span><span class="p">(</span><span class="n">dst_claim</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// ...</span>
        
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now, when the memory we’ve claimed is passed to another action via a buffer,
the memory claim lives at least until the receiving action is complete.</p>

<div class="mermaid" align="center">
flowchart TD;
  mem_b_1 -.-&gt; mem2mem_1
  mem2mem_1 -.-&gt; mem_b_2
  mem_b_2 -.-&gt; mem2mem_2
  mem2mem_2 -.-&gt; mem_b_3
  subgraph Execution
    mem2mem_1("Mem2Mem[1]") --&gt; mem2mem_2("Mem2Mem[2]")
  end
  subgraph Dataflow
    mem_b_1(["MemBuf\nsize: 64\naddr_h=0x80000000"])
    mem_b_2(["MemBuf\nsize: 64\naddr_h=0x80001000"])
    mem_b_3(["MemBuf\nsize: 64\naddr_h=0x80002000"])
  end
</div>

<h1 id="describing-memory-resources">Describing Memory Resources</h1>
<p>In addition to claiming memory, we also need to capture the memory available
to us in the system. This is done by defining an address space with one or
more memory regions, from which memory will be allocated.</p>

<p>Address spaces are instanced in the component tree. Recall from the post about
actions and components that each action execution occurs in the context of
a component instance.</p>

<p>The address space used by a given claim is located by searching hierarchically
up the component tree from the action’s context component instance until an 
address space with the same <code class="language-plaintext highlighter-rouge">trait</code> type as the claim is found.</p>

<p>This resolution scheme means that we need to exercise care in where we place
our address space. Memory is most commonly a system property. 
If we instance our DMA Engine in two different systems, we could reasonably
expect the available memory to be different. The amount of memory is likely
to be different, as are the base addresses of key memory regions.</p>

<div class="mermaid" align="center">
flowchart TD
  subgraph PssTop["pss_top"]
    aspace[["aspace : transparen_address_space_c&lt;&gt;"]]
    mem2mem-. claim .-&gt;aspace
    subgraph WbDma["dma : WbDma"]
      mem2mem["Mem2Mem"]
    end
  end
</div>

<h2 id="capturing-available-memory">Capturing Available Memory</h2>
<p>In our simple example, we will capture the address space for our DMA
engine to use in <code class="language-plaintext highlighter-rouge">pss_top</code>.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="c1">// ...</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>           <span class="n">aspace</span><span class="p">;</span>

    <span class="n">WbDma</span>                                <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>      <span class="n">region</span><span class="p">;</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x8000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The available memory regions within the address space are specified in the 
<code class="language-plaintext highlighter-rouge">init_down</code> exec block. Here, we register two regions of memory – one at
0x8000_0000 and one at 0x0000_0000.</p>

<h1 id="putting-it-all-together">Putting it all together</h1>
<p>We’ve completed the basic updates to our PSS model that enable our DMA actions
to sensibly management memory.</p>
<ul>
  <li>We have added a memory claim to the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action to claim memory
for the destination buffer.</li>
  <li>We have added a handle to the the <code class="language-plaintext highlighter-rouge">MemBuf</code> buffer type that enables
us to properly manage the lifetime of that claimed memory.</li>
  <li>We have specified an address space with available regions of memory for 
the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action to use.</li>
</ul>

<p>At this point, the Mem2Mem action will randomly allocate memory regions from 
the two registered regions. For now, this is likely just fine. In the future,
we will need to take finer-grain control over where our memory claims are 
satisfied. Fortunately, PSS provides features to support that requirement
as well.</p>

<p>In this post, we’ve seen the steps necessarily to make use of the core 
memory-management features that PSS provides. Now that we know how to
manage memory as a test-scenario resource, we can turn our attention to
managing another type of resource: the DMA channels within the engine.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://www.accellera.org/downloads/standards/portable-stimulus">PSS LRM</a></li>
  <li>[2] <a href="https://bitsbytesgates.com/code_html/2023/03/wb_dma_2.html">DMA PSS Code (Viewing)</a></li>
  <li>[3] <a href="https://bitsbytesgates.com/code/2023/03/wb_dma_2.pss">DMA PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Storage (memory) is right in the middle of all the work with do with computer architecture. We have different kinds of memory that each have different trade-offs around performance (latency / throughput), cost per unit, and power consumption. We arrange memories into hierarchies with the goal of keeping frequently-used data in the upper (faster, but limited) layers, while pushing infrequently-accessed data to the lower (slower, but more expansive) layers. Given the large amount of time time designers spend thinking about memory needs, it’s no surprise that creating good and capable tests to exercise those designs depends on being able to acquire the right type of memory at the right time in order to fully-exercise the capabilities and characteristics of the system.]]></summary></entry><entry><title type="html">Modeling DMA Test Scenarios with PSS</title><link href="https://bitsbytesgates.com/pss/2023/03/25/ModelingTestScenariosForDMA.html" rel="alternate" type="text/html" title="Modeling DMA Test Scenarios with PSS" /><published>2023-03-25T00:00:00+00:00</published><updated>2023-03-25T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/03/25/ModelingTestScenariosForDMA</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/03/25/ModelingTestScenariosForDMA.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/ModelingTestScenariosForDMA_1_splash.png" /> 
</p>

<p>If you’ve been following the blog for any length of time, you’ve likely noticed
that I like to work with examples and applications when it comes to 
learning and understanding technology. I certainly like the tendency of
applications to take knowledge out of the theoretical realm and into the 
practical, helping to answer the ‘why’ and ‘how’ questions about a technology.</p>

<p>We’ve used a simple multi-core memory test example to illustrate the first 
few PSS concepts:</p>
<ul>
  <li>Actions and Components</li>
  <li>Modeling multi-core tests (and automating test creation)</li>
  <li>Specifying declarative communication relationships between actions</li>
</ul>

<p>We could likely continue on with this example to illustrate a few more PSS
concepts, but let’s move on and use a new example. In addition to showing
off a few new PSS concepts, my hope is to start talking about the PSS
modeling process in the context of this example.</p>

<p>To that end, we’ll spend a bit more time talking about the example design
itself before digging into the PSS that we’ll use to create tests for it.</p>

<!--more-->

<h1 id="wishbone-dma-engine">Wishbone DMA Engine</h1>

<p>Our next example design will be the 
<a href="https://opencores.org/projects/wb_dma">Wishbone DMA Core</a>. While this 
design has been around for quite some time, and certainly isn’t the most 
complex, I have found that it acts as a great proxy for various hardware 
accelerators, autonomous communication IP, and data movers that exist 
in moderately-complex systems.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/DMA_block_diagram.png" />
</p>

<p>The DMA engine has a configurable number of channels up to 31. Any
channel can perform memory-to-memory transfers using the two initiator
interfaces. The DMA engine also provides a per-channel control interface 
that allows devices without an internal DMA engine to request data 
transfers.</p>

<p>DMA transfers are setup via the register interface. Simple transfers
are configured via registers in the IP, while more-complex chained
transfers are configured via an in-memory lists of descriptors.</p>

<p>Transfer termination can be signalled via an interrupt, and also polled 
by reading the channel status registers.</p>

<p>We’ll use this example to look at PSS features such as:</p>
<ul>
  <li>Memory management in tests</li>
  <li>Modeling and managing contended resources</li>
  <li>Implementing test scenarios down to the register level</li>
</ul>

<h1 id="first-steps-in-pss-modeling">First Steps in PSS Modeling</h1>

<p>Getting started is often the hardest part of any task, and creating a
PSS scenario model is no different. I often advise that the best 
approach is to take some step, any step, since it’s easy to subsequently
revise and fix the inevitable mistakes. In this way, creating a PSS 
scenario is very different from craft and construction projects where 
“measure twice cut once” remains the mantra.</p>

<p>There are several ways to approach the initial PSS scenario model. The
best is often guided by what details stand out from the description 
of the device to be tested:</p>
<ul>
  <li>The behaviors that need to be exercised via PSS scenarios</li>
  <li>The restrictions imposed by the device that must be obeyed by the scenario</li>
  <li>Interesting relationships between behaviors</li>
  <li>Interesting relationships between the device and others in the system</li>
</ul>

<p>My fallback approach is to start with the individual behaviors supported
by the device. The other details can always be layered on later.</p>

<h1 id="core-dma-behaviors">Core DMA Behaviors</h1>

<p>At the core, our DMA engine supports three operations:</p>
<ul>
  <li>Copy memory from a source region to a destination region</li>
  <li>Read data from a device (eg a USB controller) and write it to a memory region</li>
  <li>Read data from a memory region and send it to a device</li>
</ul>

<p>Each of these core operations has two variations based on whether the description
of the transfer is stored in DMA channel registers or in an in-memory descriptor
chain. But, let’s also worry about in-memory descriptors later. For now, 
let’s figure out what our three behaviors look like in PSS.</p>

<h2 id="component">Component</h2>

<p>One thing that we always need when creating a new PSS scenario model is a 
component to put everything in. It’s generally a good practice to name
this component after the target of the scenario model. In our case, we
might name our component <code class="language-plaintext highlighter-rouge">WbDma</code> since that’s the name of the device
that we’re targeting.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>
    <span class="c1">// ... </span>
<span class="p">}</span></code></pre></figure>

<p>While we could do our initial development of actions inside <code class="language-plaintext highlighter-rouge">pss_top</code>, 
eventually we will need to move our content to a container that is 
reusable. Might as well start that way instead.</p>

<h2 id="memory-copy-action">Memory Copy Action</h2>

<p>Let’s think a bit about our memory copy operation – specifically 
what its <code class="language-plaintext highlighter-rouge">pre-conditions</code> and <code class="language-plaintext highlighter-rouge">post-conditions</code> are. For normal 
operation, our copy action needs an initialized region of memory
from which to copy. While the DMA controller doesn’t care whether
the source region of memory is initialized, we’ll have difficulty
telling whether the operation was properly carried out unless we
can compare the result against known values.</p>

<p>When the DMA runs, it will copy data from the source region to 
a destination region of memory. We could encapsulate all of the
behavior to setup test the DMA copy operation into a single
action that:</p>
<ul>
  <li>Selects and initializes a block of memory (source)</li>
  <li>Selects a block of memory to copy data to (destination)</li>
  <li>Programs the DMA to carry out the transfer</li>
  <li>Checks that the result is correct</li>
</ul>

<p>But, this wouldn’t be terribly reusable. And, one great rule of
thumb to use with PSS is to always think about how the actions
you create today might be combined with those created by 
someone else for a different device and used to create 
a larger test scenario.</p>

<p>So, let’s think about our copy operation in terms of <code class="language-plaintext highlighter-rouge">pre-conditions</code>
and <code class="language-plaintext highlighter-rouge">post-conditions</code>:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pre-condition</code> In order for DMA Copy to run, it needs an initialized 
source region of memory, a region of memory to copy to, and a DMA 
channel on which to run. For now, let’s focus on the memory region bit. 
We’ll get to the DMA channel aspect in a future post.</li>
  <li><code class="language-plaintext highlighter-rouge">post-condition</code> Once the DMA Copy has run, a new region of initialized
memory is available that other devices could use.</li>
</ul>

<p>The source and destination memory aspect of pre-conditions and 
post-conditions matches the semantics of the PSS <code class="language-plaintext highlighter-rouge">buffer</code> object, so we
can model this aspect by having our DMA copy operation input and
output buffer objects.</p>

<p>Here is what our memory-copy operation will look like as a diagram:</p>

<div class="mermaid" align="center">
flowchart TD;
    mem_b_i([MemBuf]) --&gt; mem2mem(Mem2Mem) --&gt; mem_b_o([MemBuf])
</div>

<p>And, here is the code:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">MemBuf</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">WbDMA</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>      <span class="n">src_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">MemBuf</span>     <span class="n">dst_o</span><span class="p">;</span>

        <span class="c1">// ...</span>

    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We’ll figure out the contents of the <code class="language-plaintext highlighter-rouge">MemBuf</code> and how the DMA
transfer is implemented later. For now, though, this action
captures the <code class="language-plaintext highlighter-rouge">pre-conditions</code> and <code class="language-plaintext highlighter-rouge">post-conditions</code> that we
listed above.</p>

<h2 id="copy-tofrom-device">Copy To/From Device</h2>

<p>The role of a DMA engine in copying data to/from a device is
a bit interesting. While the DMA engine may implement the
mechanics of data transfer from the device (eg a UART) to
memory, we think of the device itself as having produced the data.
The DMA was just a helper to make that happen more efficiently.</p>

<p>We’ll come back to how, exactly, the DMA portion
of our behavior coordinates with the <code class="language-plaintext highlighter-rouge">device</code> portion of 
our behavior, and introduce the PSS construct that enables this. 
For now, let’s give ourselves place holders
for the actions that copy data to and from a device. In
PSS, as in other programming languages, creating an outline
marked with <em>TODO: Fill in Later</em> is a perfectly acceptable
way to make forward progress.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="c1">// ...</span>

<span class="kd">component</span> <span class="nc">WbDMA</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>      <span class="n">src_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">MemBuf</span>     <span class="n">dst_o</span><span class="p">;</span>

        <span class="c1">// ...</span>

    <span class="p">}</span>

    <span class="kd">action</span> <span class="nc">Mem2Dev</span> <span class="p">{</span>
        <span class="c1">// TODO: fill in later</span>
    <span class="p">}</span>

    <span class="kd">action</span> <span class="nc">Dev2Mem</span> <span class="p">{</span>
        <span class="c1">// TODO: fill in later</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h2 id="playing-with-scenarios">Playing with Scenarios</h2>

<p>Even in this early state, we can start to arrange our actions to see if 
we’ll be able to form the test scenarios that we might be interested in.</p>

<p>Can we chain DMA operations together? Yes, we can.</p>

<p>Can we have data produced by another block be the source of the DMA copy?
Yes, so long as the <code class="language-plaintext highlighter-rouge">buffer</code> data types are the same.</p>

<p>Can we have data produced as a result of the DMA copy be the source for
another block? Again, yes, as long as the <code class="language-plaintext highlighter-rouge">buffer</code> data types are the same.</p>

<p>With very little work, we can start to build confidence that we’ll be able
to create the tests that we want.</p>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>

<p>Taking the first step with a new programming language and new modeling 
approach can seem intimidating, but it needn’t be with PSS. With PSS,
there are several ways to approach creating a scenario model based on
a behavioral description of a device, and it’s easy to sketch up 
something quickly.</p>

<p>Over the next few posts, we’ll continue to refine our initial PSS 
scenario model for the Wishbone DMA engine and fill in the missing 
details by learning about new PSS constructs.</p>

<p>Next up: modeling memory with PSS.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] Wishbone DMA Core <a href="https://opencores.org/projects/wb_dma">project page</a></li>
  <li>[2] Wishbone DMA Core <a href="https://bitsbytesgates.com/imgs/2023/03/dma_doc.pdf">manual</a></li>
  <li>[3] <a href="https://bitsbytesgates.com/code_html/2023/03/wb_dma_1.html">DMA PSS Code (Viewing)</a></li>
  <li>[4] <a href="https://bitsbytesgates.com/code/2023/03/wb_dma_1.pss">DMA PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[If you’ve been following the blog for any length of time, you’ve likely noticed that I like to work with examples and applications when it comes to learning and understanding technology. I certainly like the tendency of applications to take knowledge out of the theoretical realm and into the practical, helping to answer the ‘why’ and ‘how’ questions about a technology. We’ve used a simple multi-core memory test example to illustrate the first few PSS concepts: Actions and Components Modeling multi-core tests (and automating test creation) Specifying declarative communication relationships between actions We could likely continue on with this example to illustrate a few more PSS concepts, but let’s move on and use a new example. In addition to showing off a few new PSS concepts, my hope is to start talking about the PSS modeling process in the context of this example. To that end, we’ll spend a bit more time talking about the example design itself before digging into the PSS that we’ll use to create tests for it.]]></summary></entry><entry><title type="html">Relating Actions with Dataflow</title><link href="https://bitsbytesgates.com/pss/2023/03/18/RelatingActionsWithDataflow.html" rel="alternate" type="text/html" title="Relating Actions with Dataflow" /><published>2023-03-18T00:00:00+00:00</published><updated>2023-03-18T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/03/18/RelatingActionsWithDataflow</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/03/18/RelatingActionsWithDataflow.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/RelatingActionsWithDataflow_splash.png" /> 
</p>
<p>Modularity and reuse are key concerns when it comes to programming
languages. While languages without many modularity and reuse features may be
quick and easy to write – think shell scripts – they ultimately fail to scale. 
PSS provides a wealth of mechanisms for structuring test content for reuse
that are familiar to users of object-oriented languages. That said, PSS provides
unique approaches to modularity and reuse as well. The PSS <code class="language-plaintext highlighter-rouge">modeling layer</code> 
is strongly declarative,
and this has significant implications on the approach that PSS takes to 
provide reuse features for composing declarative behaviors.</p>

<p>In this post, we will start to look at declarative data relationships via the
PSS <code class="language-plaintext highlighter-rouge">buffer</code> construct.</p>

<!--more-->

<h1 id="rewinding-a-bit">Rewinding a Bit…</h1>
<p>Recall that, in the last post, we were creating very simple multi-core
read/write tests, such as what is shown in the diagram below:</p>

<div class="mermaid" align="center">
graph TD;
    A[Core0\nWrite]--&gt;B[Core1\nCopy];
    B--&gt;C[Core0\nCheck];
</div>

<p>In order for our test to make sense, we needed a few relationships to hold:</p>
<ul>
  <li>The source address for our <em>Copy</em> address needed to be the same as the
destination address of the <em>Write</em></li>
  <li>The source address for the <em>Check</em> action needed to be same as the
destination address of the <em>Copy</em></li>
  <li>The source and destination addresses of the <em>Copy</em> needed to be 
different. We didn’t want to clobber our previously-written data until
we’ve had a chance to check it, after all.</li>
</ul>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>

    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">WriteCopyCheck</span> <span class="p">{</span>
        <span class="n">Write</span>             <span class="n">write</span><span class="p">;</span>
        <span class="n">Copy</span>              <span class="n">copy</span><span class="p">;</span>
        <span class="n">Check</span>             <span class="n">check</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="n">write</span><span class="p">;</span>
            <span class="n">copy</span><span class="p">;</span>
            <span class="n">check</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">constraint</span> <span class="p">{</span>
            <span class="c1">// Copy reads from same location that Write populated</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span> 
            <span class="c1">// Check reads from the same location that Copy populated</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">dst</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span>
            <span class="c1">// All actions write the same number of words</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>

            <span class="c1">// Ensure that src/dst regions do not overlap</span>
            <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">&gt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the last post, we took a bit of a shortcut and modeled all of these 
relationships as data constraints in a <em>compound action</em>. While the code above
is perfectly legal and valid in PSS (hopefully you had a chance to try out
the example code with a PSS tool), it doesn’t lend itself to reuse. The specific
problem is that the <em>Check</em> action has some required data relationships that are not 
expressed as part of the action. And, the fact that that we’ve built these 
actions without expressing how they can be related by data means that users
will need to dig into the code to understand the internal variables and 
constraints – clearly not what we expect from modular code.</p>

<h1 id="from-data-to-temporal-declarative-relationships">From Data to Temporal Declarative Relationships</h1>

<p>If you’re coming from a SystemVerilog background, data constraints are most
likely the declarative programming feature that you’re most familiar with. 
SystemVerilog supports declarative descriptions with respect to data, but
not with respect to time (temporally declarative).</p>

<p>What does this mean?</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">class</span> <span class="n">my_vseq</span> <span class="k">extends</span> <span class="n">uvm_sequence</span><span class="p">;</span>
    <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
        <span class="n">my_subseq</span> <span class="n">seq1</span> <span class="o">=</span> <span class="n">my_subseq</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">my_subseq</span> <span class="n">seq2</span> <span class="o">=</span> <span class="n">my_subseq</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>

        <span class="n">seq1</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_subsqr</span><span class="p">);</span>
        <span class="n">seq2</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_subsqr</span><span class="p">);</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</code></pre></div></div>

<p>The UVM sequence shows two sub-sequences being run sequentially. SystemVerilog
doesn’t provide any features that allow us to directly relate these two 
sequences declaratively (ie using constraints) while retaining their temporal
relationship. If we need a data relationship to hold across  <code class="language-plaintext highlighter-rouge">seq1</code> and 
<code class="language-plaintext highlighter-rouge">seq2</code>, then we need to group our two classes together in a larger class,
express the data relationship as a constraint in the containing class, 
solve the two sequences together, then deal with selectively executing each
of the sub-sequences in the desired temporal relationship.</p>

<p>It’s certainly not impossible, but can force us into some awkward design patterns 
of collecting lots of otherwise-unrelated classes such that they can be solved 
together before separating them to run over time.</p>

<h1 id="toward-a-declarative-api">Toward a Declarative API</h1>
<p>The cross-action constraints that we used in the previous post are one 
temporally-declarative feature that PSS provides. PSS allows us to express how 
action execution is 
related temporally, add constraints on top, and let the PSS tool worry about how to
group data and constraints such that both the data and temporal relationships
hold over time.</p>

<p>But, PSS goes beyond that as well. PSS provides specific data types for 
expressing the way that data that is shared or passed between temporally-related 
actions, and specific ways for actions to note when they input (require) 
data from other actions and when they output (produce) data for other actions. 
We’ll see more details on how this I/O <code class="language-plaintext highlighter-rouge">contract</code> for actions helps in the future. 
For now, it’s a great feature to assist in making PSS descriptions more modular 
and reusable.</p>

<h1 id="updating-the-memory-test-actions">Updating the Memory-Test Actions</h1>

<p>All of the data relationships in our memory test are between 
sequentially-executing actions. PSS provides the <code class="language-plaintext highlighter-rouge">buffer</code> data type to express
passing data sequentially between actions. The semantics of a <code class="language-plaintext highlighter-rouge">buffer</code> object
match our intuition based on the dictionary definition: it’s a place to store
data produced by one action before being consumed by some other action.</p>

<p>A <code class="language-plaintext highlighter-rouge">buffer</code> is a built-in data type in PSS that is a compound data structure.
In other words, it’s like a <code class="language-plaintext highlighter-rouge">struct</code> in C/C++ or Rust, and like a class 
(but without the methods) in some other languages.</p>

<p>In our application, there are two pieces of data that the actions need agree 
on: address offset and number of words being copied.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">buffer</span> <span class="nc">mem_b</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We declare these fields inside a data type of kind <code class="language-plaintext highlighter-rouge">buffer</code> to declare our
flow object. Note that these fields are declared <code class="language-plaintext highlighter-rouge">rand</code> because the represent
relationships between the producing and consuming actions, and because 
we intend to constrain them. We will use that <code class="language-plaintext highlighter-rouge">mem_b</code> type 
across our <code class="language-plaintext highlighter-rouge">Write</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, and <code class="language-plaintext highlighter-rouge">Check</code> actions to represent data-flow
relationships. When we update our <em>Write</em>
action to use the buffer, we’ll replace the local <em>offset</em> and <em>words</em> 
fields with references into the buffer field.</p>

<p>Now, let’s compare the old and new versions of the <em>Write</em> action to see
the difference.</p>

<p><strong>Old</strong></p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Write</span> <span class="p">{</span>
  <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>
  <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>

  <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
    <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">write32</span><span class="p">(</span>
        <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)),</span> 
          <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><strong>New</strong></p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Write</span> <span class="p">{</span>
  <span class="k">output</span> <span class="n">mem_b</span> <span class="n">dat_o</span><span class="p">;</span>
  <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>

  <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
    <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">dat_o</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">write32</span><span class="p">(</span>
        <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dat_o</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)),</span> 
          <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Note that we’ve added an output to the action, and replaced use of the local
variables <em>offset</em> and <em>words</em> with references to the fields of the buffer
object output. While remaining functionally the same as before, our <em>Write</em>
action is now much more specific about its participation in the scenario.</p>

<p>When we depict PSS elements graphically, we show an action’s buffer inputs and 
outputs as shown below. Note that the output buffer is shown sequentially
<em>after</em> the <em>Write</em> action, since it is only available after the <em>Write</em> action
is complete.</p>

<div class="mermaid" align="center">
flowchart TD;
    write(Write)--&gt;mem_b([mem_b])
</div>

<p>Okay, let’s update the <em>Copy</em> and <em>Check</em> actions as well. Note that we
have moved the constraints that ensure that the source and destination 
areas do not overlap into the action. This, in addition to using flow objects
to relate the actions, helps to keep things modular and encapsulated.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Copy</span> <span class="p">{</span>
  <span class="k">input</span> <span class="n">mem_b</span>  <span class="n">dat_i</span><span class="p">;</span>
  <span class="k">output</span> <span class="n">mem_b</span> <span class="n">dat_o</span><span class="p">;</span>
  <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>

  <span class="c1">// Ensure we copy the same number of words</span>
  <span class="k">constraint</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">dat_o</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>

  <span class="c1">// Ensure that src/dst regions do not overlap</span>
  <span class="k">constraint</span> <span class="p">(</span><span class="n">dat_i</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">dat_i</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dat_o</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">dat_i</span><span class="o">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">dat_o</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">dat_i</span><span class="o">.</span><span class="n">words</span><span class="p">));</span>

  <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">dat_o</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">read32</span><span class="p">(</span>
        <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span>     
          <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dat_i</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)));</span>
      <span class="n">write32</span><span class="p">(</span>
        <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> 
          <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dat_o</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)),</span>
        <span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Our updated <em>Copy</em> action will look like this when we show it in a 
diagram:</p>

<div class="mermaid" align="center">
flowchart TD;
    mem_b_i([mem_b]) --&gt; copy(Copy) --&gt; mem_b_o([mem_b])
</div>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Check</span> <span class="p">{</span>
  <span class="k">input</span> <span class="n">mem_b</span> <span class="n">dat_i</span><span class="p">;</span>
  <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>

  <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">read32</span><span class="p">(</span>
        <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> 
          <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dat_i</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">"0x%08x: expect %d ; receive %d"</span><span class="p">,</span> 
          <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dat_i</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="updating-the-memory-test-scenario">Updating the Memory-Test Scenario</h1>
<p>Now that our actions are updated to capture the data they require and produce,
we can turn our attention to assembling a scenario. Recall that our original
scenario looked like this, with constraints enforcing all relationships:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">WriteCopyCheck</span> <span class="p">{</span>
  <span class="n">Write</span>             <span class="n">write</span><span class="p">;</span>
  <span class="n">Copy</span>              <span class="n">copy</span><span class="p">;</span>
  <span class="n">Check</span>             <span class="n">check</span><span class="p">;</span>

  <span class="k">activity</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">;</span>
    <span class="n">copy</span><span class="p">;</span>
    <span class="n">check</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">constraint</span> <span class="p">{</span>
    <span class="c1">// Copy reads from same location that Write populated</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span> 
    <span class="c1">// Check reads from the same location that Copy populated</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">dst</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span>
    <span class="c1">// All actions write the same number of words</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>

    <span class="c1">// Ensure that src/dst regions do not overlap</span>
    <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="p">)</span> <span class="o">||</span>
     <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">&gt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Instead of using constraints, we will connect the input and
output buffers on the action together. How to do we form those
connections? The <code class="language-plaintext highlighter-rouge">bind</code> statement.</p>

<h2 id="the-activity-bind-statement">The Activity Bind Statement</h2>
<p>The activity <code class="language-plaintext highlighter-rouge">bind</code> statement is used to connect action I/O
ports together. In its simplest form, a <code class="language-plaintext highlighter-rouge">bind</code> statement 
connects a single input and output. For example:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">WriteCopyCheck</span> <span class="p">{</span>
  <span class="n">Write</span>             <span class="n">write</span><span class="p">;</span>
  <span class="n">Copy</span>              <span class="n">copy</span><span class="p">;</span>
  <span class="n">Check</span>             <span class="n">check</span><span class="p">;</span>

  <span class="k">activity</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">;</span>
    <span class="n">copy</span><span class="p">;</span>
    <span class="n">check</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">write</span><span class="o">.</span><span class="n">dat_o</span> <span class="n">copy</span><span class="o">.</span><span class="n">dat_i</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">copy</span><span class="o">.</span><span class="n">dat_o</span> <span class="n">check</span><span class="o">.</span><span class="n">dat_i</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>In this case, we are specifying that the output of the <code class="language-plaintext highlighter-rouge">Write</code>
action and input of the <code class="language-plaintext highlighter-rouge">Copy</code> action are connected, and the
output of the <code class="language-plaintext highlighter-rouge">Copy</code> action and input of the <code class="language-plaintext highlighter-rouge">Check</code> action 
are connected.</p>

<p>We might visualize this as follows.</p>

<div class="mermaid" align="center">
flowchart TB;

  write-.-&gt;mem_b_1
  mem_b_1-.-&gt;copy
  copy-.-&gt;mem_b_2
  mem_b_2-.-&gt;check

  subgraph Dataflow
    mem_b_1([mem_b])
    mem_b_2([mem_b])
  end
  subgraph Procedure
    write(Write)--&gt;copy(Copy)--&gt;check(Check)
  end
</div>

<p>We have two views of the scenario. In the <em>Procedure</em> portion we have 
the temporal relationship between actions (write, copy, check). In the
<em>Dataflow</em> portion, we can see the data objects relating various 
actions.</p>

<h1 id="extending-the-scenario">Extending the Scenario</h1>
<p>As mentioned in the beginning of the post, the <code class="language-plaintext highlighter-rouge">buffer</code> construct
is a feature that enables encapsulation and reuse.
Let’s leverage that reusability to extend our scenario to see how 
this works in practice. Let’s 
say that we want to perform two copies back to back instead of a
single one. All we need to do is add in the second <code class="language-plaintext highlighter-rouge">copy</code> action
and connect it into the scenario with <code class="language-plaintext highlighter-rouge">binds</code>.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Write2xCopyCheck</span> <span class="p">{</span>
  <span class="n">Write</span>             <span class="n">write</span><span class="p">;</span>
  <span class="n">Copy</span>              <span class="n">copy1</span><span class="p">;</span>
  <span class="n">Copy</span>              <span class="n">copy2</span><span class="p">;</span>
  <span class="n">Check</span>             <span class="n">check</span><span class="p">;</span>

  <span class="k">activity</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">;</span>
    <span class="n">copy1</span><span class="p">;</span>
    <span class="n">copy2</span><span class="p">;</span>
    <span class="n">check</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">write</span><span class="o">.</span><span class="n">dat_o</span> <span class="n">copy1</span><span class="o">.</span><span class="n">dat_i</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">copy1</span><span class="o">.</span><span class="n">dat_o</span> <span class="n">copy2</span><span class="o">.</span><span class="n">dat_i</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">copy2</span><span class="o">.</span><span class="n">dat_o</span> <span class="n">check</span><span class="o">.</span><span class="n">dat_i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<div class="mermaid" align="center">
flowchart LR

  write-.-&gt;mem_b_1
  mem_b_1-.-&gt;copy1
  copy1-.-&gt;mem_b_2
  mem_b_2-.-&gt;copy2
  copy2--&gt;mem_b_3
  mem_b_3-.-&gt;check

  subgraph Dataflow
    mem_b_1([mem_b])
    mem_b_2([mem_b])
    mem_b_3([mem_b])
  end
  subgraph Procedure
    write(Write)--&gt;copy1(Copy)--&gt;copy2(Copy)--&gt;check(Check)
  end
</div>

<p>First off, there is a reduction in the number of lines of code required
to setup this scenario compared to what would have been required if we
used plain data constraints. Secondly, input/output ports on actions express the 
<code class="language-plaintext highlighter-rouge">interface</code> of an action to the outside world. It’s a way for a 
library developer (or, just my colleague who wrote some actions) to 
express where I should focus as an end user of the action.</p>

<h1 id="flow-object-pools-and-binding">Flow-Object Pools and Binding</h1>
<p>There is one final thing to be aware of with PSS flow objects, and that
is the <code class="language-plaintext highlighter-rouge">pool</code> construct. We’ll largely gloss over it until we hit
cases where we really need to use pools. For now, it’s important to 
understand that actions need to be connected to the same pool in 
order to be connected via a flow object like a buffer. You’ll often
see code like what is shown below to create a pool for a flow object
type and connect all action I/O references of that flow-object 
type to the pool.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">mem_b</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>
    <span class="k">pool</span> <span class="n">mem_b</span>      <span class="n">mem_b_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_b_p</span> <span class="o">*</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<h1 id="wrapping-up-and-looking-forward">Wrapping up and Looking Forward</h1>
<p>In this post, we looked at the <code class="language-plaintext highlighter-rouge">buffer</code> declarative data-flow construct. 
We’ve seen how this can help to make our actions more reusable and 
better encapsulated. The <code class="language-plaintext highlighter-rouge">buffer</code> construct provides a way to relate
actions via sequential data transfer. As you might guess, PSS also 
provides similar constructs for enabling actions to be related by
data in other ways. We’ll look at those mechanisms in future posts.</p>

<p>For now, feel free to look at the full code listing and run it 
through your favorite PSS processing tool. Try adding new constraints
on sub-actions within the scenario and try further-expanding the scenario.</p>

<p>If you’re interested in reading more about buffers, pools, and other flow
objects, have a look at section 5.1 in the LRM referenced below ([1])</p>

<p>I’m a big proponent of using real-world examples to introduce concepts in a
practical context. In the next post, I’ll introduce an example that we will
use as a vehicle to introduce the next series of PSS modeling topics.</p>

<h2 id="references">References</h2>
<ul>
  <li>[1] <a href="https://www.accellera.org/downloads/standards/portable-stimulus">PSS LRM</a></li>
  <li>[2] <a href="https://bitsbytesgates.com/code_html/2023/03/memtest_buffer.html">MemTest PSS Code (Viewing)</a></li>
  <li>[3] <a href="https://bitsbytesgates.com/code/2023/03/memtest_buffer.pss">MemTest PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Modularity and reuse are key concerns when it comes to programming languages. While languages without many modularity and reuse features may be quick and easy to write – think shell scripts – they ultimately fail to scale. PSS provides a wealth of mechanisms for structuring test content for reuse that are familiar to users of object-oriented languages. That said, PSS provides unique approaches to modularity and reuse as well. The PSS modeling layer is strongly declarative, and this has significant implications on the approach that PSS takes to provide reuse features for composing declarative behaviors. In this post, we will start to look at declarative data relationships via the PSS buffer construct.]]></summary></entry><entry><title type="html">Declarative Programming and Multi-Core Tests</title><link href="https://bitsbytesgates.com/pss/2023/03/11/DeclarativeMultiCoreTests.html" rel="alternate" type="text/html" title="Declarative Programming and Multi-Core Tests" /><published>2023-03-11T00:00:00+00:00</published><updated>2023-03-11T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/03/11/DeclarativeMultiCoreTests</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/03/11/DeclarativeMultiCoreTests.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/PSSMultiCoreTests_splash.png" /> 
</p>

<p>As humans, we often pride ourselves on our ability to multi-task. Not 
only can we participate in a meeting, we can we simultaneously prepare the 
slides for the next meeting. Sadly, science has some bad news about 
our perception to multitask vs our actual ability. In reality, like a 
single-core processor, our mind is rapidly context switching between tasks
to provide an illusion of simultaneous focus on multiple tasks. Re-establishing
sole focus on a task can take 20 minutes and, during that time, productivity 
suffers by as much as 40%. Suffice it to say that we’re really working at 
half speed when constantly multitasking.</p>

<p>What does multi-tasking have to do with PSS and bare-metal test creation? Well,
there is another task that I’ve observed humans consistently find challenging:
parallel and, especially, multi-core programming. I think there’s actually 
a connection between this and the challenges our brain has in multi-tasking. 
With a sequential program, I can reason step-by-step as to what happens. 
I can do the same for some portions of a parallel program. But, whenever 
the parallel threads interact, I need to reason about their possible 
relationships at that point in time. What happens
under each possible ordering of threads reaching the synchronization point? 
It’s this last point that, I think, really stresses our multi-tasking ability.
Not only do we need to envision what is happening in the context of one
thread, but need to simultaneously envision the set of possible actions the
other threads may be taking.</p>

<!--more-->

<h2 id="specific-bare-metal-multi-core-test-challenges">Specific Bare-Metal Multi-Core Test Challenges</h2>

<p>Creating bare-metal, multi-core tests poses challenges beyond just the core
challenges of managing parallel behavior described above. Keep in mind that,
because we don’t have an OS to manage the processor cores, our test will 
need to be partitioned into per-core test programs that synchronize with
each other.</p>

<div class="mermaid" align="center">
graph TD;
    A[Core0\nWrite]--&gt;B[Core1\nCopy];
    B--&gt;C[Core0\nCheck];
</div>

<p>The diagram above shows the test flow of a bring-up test that, on the surface,
is quite simple:</p>
<ul>
  <li>Write some memory from Core0</li>
  <li>Read that memory from Core1, and write some data elsewhere (copy)</li>
  <li>Read the memory written by Core1 from Core0 and check that it’s correct</li>
</ul>

<p>From this simple test flow, we will need to create two core-specific tests that
coordinate to achieve the desired activity. The diagram below shows what 
our test core-specific tests need to do:</p>

<div class="mermaid" align="center">
flowchart TB
    c01-. notify .-&gt;c10
    c11-. notify .-&gt;c02
    subgraph Core1
    c1s[["Core1 Start"]]
    c1s--&gt;c10
    c10(["Wait: Core0::Write"])
    c10--&gt;d
    d[Core1\nCopy]
    d--&gt;c11
    c11(["Notify: Copy Complete"])
    c11--&gt;c1e
    c1e[["Core1 End"]]
    end
    subgraph Core0
    c0s[["Core0 Start"]]
    c0s--&gt;a
    a[Core0\nWrite]
    a--&gt;c01
    c01(["Notify: Write Complete"])
    c01--&gt;c02
    c02(["Wait: Core1::Copy Complete"])
    c02--&gt;e
    e[Core0\nCheck]
    e--&gt;c0e
    c0e[["Core0 End"]]
    end
</div>

<ul>
  <li>Core 0
    <ul>
      <li>Wakes up and writes to the specified memory location</li>
      <li>Notifies Core 1 that the write is complete</li>
      <li>Waits for Core 1 to notify that the read/write is complete</li>
      <li>Read the data from the specified location</li>
    </ul>
  </li>
  <li>Core 1
    <ul>
      <li>Wakes up and waits for Core 0 to write to the specified memory location</li>
      <li>Reads the specified location and writes to another</li>
      <li>Notifies Core 0</li>
    </ul>
  </li>
</ul>

<p>In this case, we are working with three operations distributed across two 
cores. As we introduce more behaviors spread across more processor cores,
the individual tests only become more complex.</p>

<h2 id="pss-and-declarative-descriptions">PSS and Declarative Descriptions</h2>

<p>You may have heard PSS described as a <em>declarative language</em> and wondered
what that really meant in practice. PSS being a declarative-first language
is very important in enabling some of the capabilities of PSS. That said,
the definition of ‘declarative language’ is a bit flexible.</p>

<blockquote>
  <p>In computer science, declarative programming is a programming paradigm — a 
style of building the structure and elements of computer programs — that 
expresses the logic of a computation without describing its control flow.</p>
</blockquote>

<p>Put another way:</p>
<blockquote>
  <p>Declarative programming is a non-imperative style of programming in which 
programs describe their desired results without explicitly listing 
commands or steps that must be performed.</p>
</blockquote>

<p>The PSS <code class="language-plaintext highlighter-rouge">modeling layer</code> that we looked at in the last post is heavily 
constraint-based, exposing the declarative programming basis for that portion 
of the language. We also see the declarative
basis in how PSS approaches implementing multi-core test programs by focusing
the test writer on capturing the desired <code class="language-plaintext highlighter-rouge">intent</code> of the test with respect to
parallel execution rather than capturing the implementation of synchronization
across threads.</p>

<p>As we see more of the PSS language and its applications, the implications and
results of PSS having a declarative <code class="language-plaintext highlighter-rouge">modeling layer</code> will become clearer. For 
now, focus on two things:</p>
<ul>
  <li>We need to think in relationships and rules instead of computation steps.</li>
  <li>We can focus much more on what we <em>want</em> to happen in our tests instead of
on <em>how</em> we’re going to get our tests to do that.</li>
</ul>

<p>When it comes to our multi-core test, this means that we are free to focus
on what interesting patterns of memory access we want to form, and leave 
the task of creating self-synchronizing per-core test programs to our
PSS tool.</p>

<h2 id="pss-and-the-multi-core-memory-test">PSS and the Multi-Core Memory Test</h2>

<p>Let’s revisit our multi-core memory test – this time showing the PSS 
approach. First, a warning. We’re pretty early in looking through all the 
constructs supported by the PSS language, so don’t worry if you don’t 
recognize or understand the details of every language construct.</p>

<div class="mermaid" align="center">
graph TD;
    A[Core0\nWrite]--&gt;B[Core1\nCopy];
    B--&gt;C[Core0\nCheck];
</div>

<h3 id="modeling-the-leaf-level-actions">Modeling the Leaf-Level Actions</h3>

<p>First, let’s create Write, Copy, and Check actions. Let’s keep our data
generation and checking simple by using an incrementing data pattern.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>
    <span class="n">addr_handle_t</span>       <span class="n">base_addr</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">Write</span> <span class="p">{</span>
        <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write32</span><span class="p">(</span>
                    <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)),</span> 
                    <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Okay, what do we have going on here? First off, let’s talk about two new
data types: addr_handle_t and executor_claim. PSS defines the addr_handle_t
type to represent an abstract reference to memory on the target system. 
You can think of this as a sort of pointer if you’re a C programmer. Unlike
in C, though, we don’t directly manipulate an addr_handle_t variable.</p>

<p>PSS defines the <em>executor_claim_s</em> type to allow an action to specify 
on which core it runs. The term <em>executor</em> encompasses both processor
cores and elements of the testbench that execute behavior. As a user, we need
to be able to direct actions to run on specific cores using relevant 
characteristics of the cores. The executor <em>claim</em> data structure is
templated with a data type that allows us to specify that relevant data.</p>

<p>Finally, we have two random variables to specify a offset and size for 
the write, and an exec block that specifies the behavior to run
when the action executes. In this case, call the <em>write32</em> PSS 
built-in method to write an incrementing value to a memory location.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">Copy</span> <span class="p">{</span>
        <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">src</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">dst</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">read32</span><span class="p">(</span>
                    <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span>     
                        <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">i</span><span class="p">)));</span>
                <span class="n">write32</span><span class="p">(</span>
                    <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> 
                        <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="n">i</span><span class="p">)),</span> 
                    <span class="n">tmp</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Okay, many familiar things with the Copy action. Here, we’re also selecting
a core to run on (<code class="language-plaintext highlighter-rouge">core</code>) and have a random <code class="language-plaintext highlighter-rouge">src</code> and <code class="language-plaintext highlighter-rouge">dst</code> offset that 
point to different areas in memory.</p>

<p>In this case, our <code class="language-plaintext highlighter-rouge">exec body</code> block reads from the source area and writes
to the destination area.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>

    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">Check</span> <span class="p">{</span>
        <span class="kd">rand</span> <span class="n">executor_claim_s</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span> <span class="n">core</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mh">0xFFFFFF</span><span class="p">]</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">256</span><span class="p">]</span>      <span class="n">words</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">read32</span><span class="p">(</span>
                    <span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">base_addr</span><span class="p">,</span> 
                        <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">error</span><span class="p">(</span><span class="s">"0x%08x: expect %d ; receive %d"</span><span class="p">,</span> 
                        <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, our <em>Check</em> action reads back words from a region of memory and expects
to find an incrementing pattern of data.</p>

<h3 id="a-convenience-action">A Convenience Action</h3>
<p>In order to perform a write, copy, check operation with these three actions, we
need to ensure that some relationships hold. Let’s create a convenience action
where we can place those constraints.</p>

<p>As a side note, PSS provides much richer mechanisms for managing memory and
coordination between actions. But let’s keep things simple for now.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">memtest_c</span> <span class="p">{</span>

    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">WriteCopyCheck</span> <span class="p">{</span>
        <span class="n">Write</span>             <span class="n">write</span><span class="p">;</span>
        <span class="n">Copy</span>              <span class="n">copy</span><span class="p">;</span>
        <span class="n">Check</span>             <span class="n">check</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="n">write</span><span class="p">;</span>
            <span class="n">copy</span><span class="p">;</span>
            <span class="n">check</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">constraint</span> <span class="p">{</span>
            <span class="c1">// Copy reads from same location that Write populated</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span> 
            <span class="c1">// Check reads from the same location that Copy populated</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">dst</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">offset</span><span class="p">;</span>
            <span class="c1">// All actions write the same number of words</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">write</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">words</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">words</span><span class="p">;</span>

            <span class="c1">// Ensure that src/dst regions do not overlap</span>
            <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">src</span> <span class="o">&gt;</span> <span class="n">copy</span><span class="o">.</span><span class="n">dst</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">words</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">WriteCopyCheck</code> action provides us a simple and reusable 
write/copy/check operation that we can use and customize without
worrying about the constraints inside.</p>

<h3 id="modeling-the-cores-and-memory">Modeling the Cores and Memory</h3>

<p>Let’s come back to how we describe cores. The leaf-level actions use a data
structure named <code class="language-plaintext highlighter-rouge">core_s</code> to describe information about the processor cores.
We can choose to put any type of data in this data structure to describe
key attributes about the processor cores in our system. For now, let’s 
just give each core a numeric ID.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="nc">core_s</span> <span class="p">:</span> <span class="n">executor_trait_s</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>     <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>PSS defines two built-in component types to represent an individual executor
and a group of executors. Assuming we have 4 cores, let’s define a 
corresponding set of executors and group them.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="nc">core_s</span> <span class="p">:</span> <span class="n">executor_trait_s</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>     <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">executor_c</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span>         <span class="n">core</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">executor_group_c</span><span class="o">&lt;</span><span class="n">core_s</span><span class="o">&gt;</span>   <span class="n">cores</span><span class="p">;</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span> <span class="n">aspace</span><span class="p">;</span>
    <span class="n">memtest_c</span>                  <span class="n">memtest</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init</span> <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">cores</span><span class="o">.</span><span class="n">add_executor</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="c1">// Define a memory region</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span> <span class="n">region</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x8000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">memtest</span><span class="o">.</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the snippet above, we’ve declared an executor for each core and specified 
its unique <code class="language-plaintext highlighter-rouge">id</code>. Each individual core is added to the <code class="language-plaintext highlighter-rouge">cores</code> group of 
executors. As you might guess, this entire scheme is designed to handle 
much more complex associations of cores and groups of cores.</p>

<p>We also declare an address space that contains a region of memory. The memory
region starts at 0x8000_0000 and is 0x1000_0000 in size. The <code class="language-plaintext highlighter-rouge">add_region</code> 
call shown in the exec block returns an address handle, which we assign
to the <code class="language-plaintext highlighter-rouge">base_addr</code> field in the memtest component. Our Write/Copy/Check 
actions will be able to access the memory region via this handle.</p>

<h3 id="creating-tests">Creating Tests</h3>

<p>Let’s start by writing a test that is identical to the test flowchart that
we’ve been looking at:</p>

<div class="mermaid" align="center">
graph TD;
    A[Core0\nWrite]--&gt;B[Core1\nCopy];
    B--&gt;C[Core0\nCheck];
</div>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">Copy_0_1_0</span> <span class="p">{</span>
        <span class="k">activity</span> <span class="p">{</span>
            <span class="k">do</span> <span class="nn">memtest_c</span><span class="p">::</span><span class="n">WriteCopyCheck</span> <span class="k">with</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">check</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Simply by adding a few extra constraints (rules) on top of our convenience
Write/Copy/Check action, we can achieve exactly the scenario of writing
data from Core 0, Copying it using Core 1, then checking the result from Core 0.
Notice that, in this case, the size of data being created and copied is random.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">Copy_same_core</span> <span class="p">{</span>
        <span class="k">activity</span> <span class="p">{</span>
            <span class="k">do</span> <span class="nn">memtest_c</span><span class="p">::</span><span class="n">WriteCopyCheck</span> <span class="k">with</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">copy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span><span class="p">;</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">check</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With a slightly different set of rules, we can say that we want the same core
to perform the write, copy, and check. The actual core (0..3) will be 
randomly selected</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="kd">action</span> <span class="nc">Copy_check_diff_core</span> <span class="p">{</span>
        <span class="k">activity</span> <span class="p">{</span>
            <span class="k">do</span> <span class="nn">memtest_c</span><span class="p">::</span><span class="n">WriteCopyCheck</span> <span class="k">with</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">check</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">id</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Changing the rules again, we can require the core writing data to be different
from the core checking data. The one copying data is left completely random.</p>

<h2 id="conclusion">Conclusion</h2>
<p>While the human mind may not lend itself to efficiently reasoning about concurrency,
automation can go a long way to simplifying the creation of multi-core tests. In this 
post, we’ve seen a few ways in which the declarative modeling approach that PSS defines
helps in focusing the user on capturing <em>what</em> to test, and delegating the task of
making happen – the <em>how</em> – to the PSS test-synthesis tool. This lets us quickly
change the rules of the test to focus in on specific scenarios – how much data 
is being transferred, for example – and the generated test follows. This results in 
a huge boost in test-creation productivity vs manually coding (or copy/paste/modifying)
individual tests.</p>

<p>If you have access to a PSS processing tool, please try out the example code
(link below). You should be able to observe the multi-core synchronization code 
that the PSS tool emits to explicitly schedule and synchronize behavior across
multiple processor cores.</p>

<p>In the next post, we’ll start to learn about the features PSS provides to help 
actions communicate in a reusable and modular fashion.</p>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://www.npr.org/2008/10/02/95256794/think-youre-multitasking-think-again">https://www.npr.org/2008/10/02/95256794/think-youre-multitasking-think-again</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Declarative_programming">https://en.wikipedia.org/wiki/Declarative_programming</a></li>
  <li><a href="https://bitsbytesgates.com/code_html/2023/03/memtest.html">MemTest PSS Code (Viewing)</a></li>
  <li><a href="https://bitsbytesgates.com/code/2023/03/memtest.pss">MemTest PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[As humans, we often pride ourselves on our ability to multi-task. Not only can we participate in a meeting, we can we simultaneously prepare the slides for the next meeting. Sadly, science has some bad news about our perception to multitask vs our actual ability. In reality, like a single-core processor, our mind is rapidly context switching between tasks to provide an illusion of simultaneous focus on multiple tasks. Re-establishing sole focus on a task can take 20 minutes and, during that time, productivity suffers by as much as 40%. Suffice it to say that we’re really working at half speed when constantly multitasking. What does multi-tasking have to do with PSS and bare-metal test creation? Well, there is another task that I’ve observed humans consistently find challenging: parallel and, especially, multi-core programming. I think there’s actually a connection between this and the challenges our brain has in multi-tasking. With a sequential program, I can reason step-by-step as to what happens. I can do the same for some portions of a parallel program. But, whenever the parallel threads interact, I need to reason about their possible relationships at that point in time. What happens under each possible ordering of threads reaching the synchronization point? It’s this last point that, I think, really stresses our multi-tasking ability. Not only do we need to envision what is happening in the context of one thread, but need to simultaneously envision the set of possible actions the other threads may be taking.]]></summary></entry><entry><title type="html">PSS Fundamentals: Actions, Components, and Test Generation</title><link href="https://bitsbytesgates.com/pss/2023/03/03/ActionsComponents_and_TestGeneration.html" rel="alternate" type="text/html" title="PSS Fundamentals: Actions, Components, and Test Generation" /><published>2023-03-03T00:00:00+00:00</published><updated>2023-03-03T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/03/03/ActionsComponents_and_TestGeneration</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/03/03/ActionsComponents_and_TestGeneration.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/PSSFundamentals_ActionsComponents_splash.png" /> 
</p>
<p>Complex engineering endeavors require complex calculations. It’s open to 
debate as to when the first engineering project that required complex 
calculations occurred. What we do know is that those 
calculations would have been done by hand. And this 
state largely remained until the broad availability of the electronic 
calculator in the 1950s and 1960s, even as engineering projects 
and the technology we used to accomplish them become more ambitious.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/US-Veterans-Bureau-Computing-Division-1924.jpg" height="480" />
<em><figcaption>Computing Division of the US Veterans Bureau, 1924. Image Courtesy of the Computer History Museum.</figcaption></em>
</p>

<p>But this doesn’t mean that “computers” (those individuals performing
computations with pen and ink or simple mechanical machines) were left 
to compute everything from the ground up. Fortunately, books were published 
containing mathematical tables that provided the pre-computed results of 
standard trigonometric 
functions for various input values. The data in these books of 
mathematical tables would, of course, have been produced
laboriously by some other “computer” or “computers” working with pen 
and paper. But, they were invaluable at increasing the speed with 
which complex calculations could be completed by hand.</p>

<!--more-->

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/LogTrigTablesBook.jpg" height="320" />
<em><figcaption>Logarithmic and Trigonometric Tables Book. Image courtesy of the Smithsonian.</figcaption></em>
</p>

<p>What does this have to do with Portable Test and Stimulus (PSS)? 
PSS is specifically designed to enable PSS processing tools to 
pre-compute the result of complex test scenario relationships in order
to make the best use of instructions running at a few Hertz on a simulated 
RTL model of the design processor. But, before we get to how PSS creates tests, 
we need to learn about two fundamental PSS concepts: Actions and Components</p>

<h2 id="actions-and-layered-test-modeling">Actions and Layered Test Modeling</h2>
<p>Our next key topic is the Action. As it so happens, several languages
and description formats use the notion of <em>Action</em>. After all, it 
is a very intuitive term to capture an element that is all about
describing and encapsulating behavior. Before digging into actions,
it is helpful to understand how PSS divides a description of test 
behavior into two portions.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/ModelingRealizationLayers.png" />
<em><figcaption>PSS Modeling and Realization Layers.</figcaption></em>
</p>

<p>The upper portion, called the Modeling Layer, contains the constraintt-driven 
features for modeling test scenarios, and is responsible for capturing the 
space of interesting and useful behaviors.</p>

<p>In contrast, the realization layer is more-or-less 
intended to carry out the instructions of the modeling layer, and 
contains familiar procedural statements such as appear in other 
programming languages like C, Java, and Python. The realization layer
is also where we’ll find constructs for reading and writing registers
and memory. While the realization layer makes local decisions, often
related to handshaking with the device it controls, the modeling layer
is intended to make the big-picture decisions about how the system
is exercised.</p>

<h3 id="connecting-modeling-and-realization-layers">Connecting Modeling and Realization Layers</h3>
<p>As the diagram suggests, <em>Actions</em> bridge the boundary between modeling and 
realization layer because they can contain both modeling and realization 
aspects. In all cases, actions group the data, constraints, and implementation 
for a given behavior.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">action</span> <span class="nc">check_reg_reset_vals</span> <span class="p">{</span>
    <span class="kt">list</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">reset_vals</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x0000_0000</span><span class="p">,</span> <span class="mh">0x0180_2FFF</span><span class="p">,</span> <span class="mh">0x8000_0000</span><span class="p">};</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="n">start</span><span class="p">;</span>

    <span class="k">constraint</span> <span class="n">start</span> <span class="k">in</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">reset_vals</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
        <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">off</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">repeat</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span> <span class="n">reset_vals</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">off</span> <span class="o">=</span> <span class="p">((</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">reset_vals</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">off</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">read32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">reset_vals</span><span class="p">[</span><span class="n">off</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">error</span><span class="p">(</span><span class="s">"Failed to read register at 0x%08x: read 0x%08x ; expected %08x"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">reset_vals</span><span class="p">[</span><span class="n">off</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The example above is an action that checks the reset value of registers in the
design. It contains a list of register expected values, and a random variable
that will specify the order in which the action checks the reset values – 
just to be sure that the order in which we access registers doesn’t change
behaviors. This is our modeling layer.</p>

<p>The realization layer of the example is contained in the <code class="language-plaintext highlighter-rouge">body</code> block. This
is the code that carries out the ‘higher-level’ decisions made by the 
modeling layer. In this case, we:</p>
<ul>
  <li>Loop over the set of registers we need to check</li>
  <li>Compute the offset and address of the selected register which are 
relative to a random starting point.</li>
  <li>Read it, check against the expected value, and report any mismatches.</li>
</ul>

<p>Even this tiny action begins to show some of the value of modeling scenarios
with PSS. Our code is similar to what we might write in C and, if anything, is
a bit more compact. Let’s come back to this example to see how PSS can help
us with generating test variants.</p>

<p>One other thing that we’ll come back to are activities. The action above is
called an <code class="language-plaintext highlighter-rouge">atomic</code> action. An atomic action is a leaf-level action that
is implemented in terms of procedural code. We can also implement the 
behavior of an action in terms of other actions. This so-called <code class="language-plaintext highlighter-rouge">activity</code>
provides us an expanded set of modeling features.</p>

<h2 id="components">Components</h2>
<p><code class="language-plaintext highlighter-rouge">Components</code> are the other key PSS fundamentals construct for this post. The 
requirement for <code class="language-plaintext highlighter-rouge">components</code> stems from the observation that actions in
a system <code class="language-plaintext highlighter-rouge">act on</code> a specific context. A DMA transfer action must <code class="language-plaintext highlighter-rouge">act on</code> 
a <em>specific</em> DMA controller, because there are likely to
be several in a system. A DMA transfer action needs to know things like
what the base address is for the DMA controller registers. The PSS <code class="language-plaintext highlighter-rouge">Component</code> 
construct fills this requirement for a persistent, static entity to model
physical entities, the resources they contain, and the operations that 
can be performed on them.</p>

<div class="language-pss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">component</span> <span class="nc">dma_c</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">mem2mem_a</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">subsys_c</span> <span class="p">{</span>
    <span class="n">dma_c</span>           <span class="n">dma0</span><span class="p">;</span>
    <span class="n">dma_c</span>           <span class="n">dma1</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Components may be composed hierarchically, much as designs are. So, if your
subsystem design contains two instances of a DMA controller IP, your
PSS component that represents the subsystem from a test perspective will
as well.</p>

<p>Components is another topic that we will revisit in greater depth in a 
future post. For now, their fundamental attributes are:</p>
<ul>
  <li>The component tree remains constant for the lifetime of the test</li>
  <li>A component type groups the supported behaviors and resources required by 
those behaviors</li>
  <li>Each action execution is associated with a corresponding instance of
a component</li>
</ul>

<h2 id="test-creation-flow">Test Creation Flow</h2>
<p>PSS breaks the execution of a PSS model into two large phases:</p>
<ul>
  <li>Solve  – Constraints are solved, random variable values are assigned, etc</li>
  <li>Target – Behavior executes on the target platform</li>
</ul>

<p>The goal is to enable separating or combining these phases depending 
on the characteristics of the environment.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/PSSTestGenFlow.png" />
<em><figcaption>PSS Pre-Gen Test Generation Flow.</figcaption></em>
</p>

<p>The figure above shows a typical <em>pre-generation</em> flow targeted at 
producing bare-metal test software for SoC integration verification.
In this case, simplifying computations performed on the target 
platform is a key goal, since the simulated RTL processor model runs
at a very low effective clock speed.</p>

<p>Looking back at our ‘register reset test’ action, the implementation
code might look like the following:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x10000004</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mh">0x01802FFF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"Failed to read register at 0x%08x: read 0x%08x ; expected %08x"</span><span class="p">,</span>
         <span class="mh">0x10000004</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0x01802FFF</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x10000008</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"Failed to read register at 0x%08x: read 0x%08x ; expected %08x"</span><span class="p">,</span>
        <span class="mh">0x10000008</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x10000000</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"Failed to read register at 0x%08x: read 0x%08x ; expected %08x"</span><span class="p">,</span>
        <span class="mh">0x10000000</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Note that, in this case, the PSS processing tool has pre-computed the random 
starting index, unrolled the loop, and pre-computed addresses in order to minimize 
instructions executed on the target platform. It could also have locally-computed
a random value between 0 and 2 for the starting index. Due to the abstraction
level at which the test behavior is defined, the PSS processing tool has many
implementations options that can be traded off against the requirements of the
implementation platform.</p>

<p>Much as mathematical tables helped human
computers to maximize the results they were able to produce by hand, the PSS
semantics that enable pre-computation of results help PSS-created tests maximize
test throughput on simulated hardware platforms.</p>

<h2 id="looking-forward">Looking Forward</h2>
<p>In this post, we have learned about two key PSS constructs: <em>actions</em> and <em>components</em>. 
<em>Actions</em> describe model-level behavior and connect that high-level behavior to 
test realization implementation via exec blocks. <em>Components</em> describe structure,
and group behaviors (actions) with the resources they require. From now on, every
example will be built from <em>Actions</em> and <em>Components</em>, and we will add new ways
that PSS enables actions and components to interact.</p>

<p>In the next post, we will begin to look in more detail at the declarative basis
of the PSS language. Being, first and foremost, declarative makes PSS a bit 
different as languages go, but also enables many of its most impressive capabilities.</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Complex engineering endeavors require complex calculations. It’s open to debate as to when the first engineering project that required complex calculations occurred. What we do know is that those calculations would have been done by hand. And this state largely remained until the broad availability of the electronic calculator in the 1950s and 1960s, even as engineering projects and the technology we used to accomplish them become more ambitious. Computing Division of the US Veterans Bureau, 1924. Image Courtesy of the Computer History Museum. But this doesn’t mean that “computers” (those individuals performing computations with pen and ink or simple mechanical machines) were left to compute everything from the ground up. Fortunately, books were published containing mathematical tables that provided the pre-computed results of standard trigonometric functions for various input values. The data in these books of mathematical tables would, of course, have been produced laboriously by some other “computer” or “computers” working with pen and paper. But, they were invaluable at increasing the speed with which complex calculations could be completed by hand.]]></summary></entry><entry><title type="html">Automating Bare-Metal Tests with PSS</title><link href="https://bitsbytesgates.com/pss/2023/02/25/AutomatingBareMetalTestsWithPSS.html" rel="alternate" type="text/html" title="Automating Bare-Metal Tests with PSS" /><published>2023-02-25T00:00:00+00:00</published><updated>2023-02-25T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/02/25/AutomatingBareMetalTestsWithPSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/02/25/AutomatingBareMetalTestsWithPSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/AutomatingBareMetalSoCTestsWithPSS_splash.png" /> 
</p>
<p>As a technologist, it’s tempting to focus on what is new 
(at least, new to me) – especially when choosing what to write about.
I’m periodically reminded that there is immense value in returning
to topics. Returning to a topic might raise awareness with a different
set of readers, but it’s also highly likely that I’ll learn something
new about the topic, or that my perspective on the topic will evolve 
in the process.</p>

<p>This post marks the beginning of just such a “back to basics” series
that focuses on the <a href="https://www.accellera.org/downloads/standards/portable-stimulus">Accellera Portable Test and Stimulus</a> 
(PSS) language. PSS is a specification language for modeling behavior 
to test. It specifically focuses on providing features that help 
in creating bare-metal software-driven system-level tests. Consequently,
this ‘Intro to PSS’ series will focus on the task of the bare-metal
software-driven test writer, and the value PSS provides.</p>

<!--more-->

<h2 id="programming-languages-categories">Programming Languages Categories</h2>
<p>When it comes to programming languages, there are two big 
categories: general-purpose programming languages and domain-specific
programming languages. General-purpose programming languages such
as C/C++, Java, Python, and Rust are designed to be able to 
implement any algorithm or behavior. The “any…” part comes 
with a caveat, of course: any algorithm or behavior given sufficient
expertise and time.</p>

<p>There are classes of problems that have such
well-defined expert solutions that it’s considered wasteful
to actually apply large amounts of expert-programmer 
resource to create a bespoke solution each time they arise. This is where 
domain-specific languages (DSL) come into play. A domain-specific language 
provides a way to capture a problem in a way that a domain expert finds 
familiar, along with enough information to enable a synthesis tool to 
produce an optimal implementation in a general-purpose language.</p>

<h2 id="cases-where-dsls-shine">Cases where DSLs shine</h2>
<p>As you may have guessed, PSS is a domain-specific language. In this case,
one targeted at capturing system-level test behavior in terms 
familiar to a domain expert.
Let’s take a look at another very popular application for domain-specific
languages to better understand the value and tradeoffs that they provide.</p>

<p>An excellent example of an application of domain-specific languages 
is building lexical analyzers (lexers) and parsers.  People that 
define languages think in terms of language grammars – typically
captured in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur Form</a> 
(BNF). For example, here is a snippet of BNF grammar from the PSS 
language-reference manual.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action_body_item ::=
 activity_declaration
 | override_declaration
 | constraint_declaration
 | action_field_declaration
</code></pre></div></div>

<p>Coding a parser by hand from this description involves a fair amount of 
analysis to, for example, identify the keywords that would cause a parser
to proceed down one branch vs another, and how many tokens of
‘lookahead’ are needed in each case to disambiguate choices. While these
are critical implementation decisions, they’re difficult for a human to
make by hand since they often involve ‘global’ thinking about the whole
of a sizable language grammar. In other words, not areas of thinking that
to which the untrained human mind lends itself.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action_body_item:
 activity_declaration
 | override_declaration
 | constraint_declaration
 | action_field_declaration
 ;
</code></pre></div></div>

<p>Re-expressing the BNF in the terms of a domain-specific language is an
almost-trivial exercise for a domain expert in language design. The 
code snippet above is in <a href="https://www.antlr.org/">ANTLR4</a> format. There 
are a few small changes in format, and a few things that are conveyed 
typographically in a printed language grammar are conveyed differently
to support programmatic processing, but overall the DSL description
is easy to learn for a domain expert.</p>

<p>By capturing our language grammar in a domain-specific language format,
we’re able to make use of a parser/lexer builder tool to derive an 
efficient implementation of a language parser for this language. The 
parser-builder tool is able to easily and quickly make high-quality
global optimizations that would have been very time consuming and 
error-prone for a human to make. And, if we change the grammar at 
some point, we only need to re-run the the parser-builder tool to derive
a new (and still optimal) parser implementation.</p>

<p>Looking at a few domain-specific languages, they tend to shine when:</p>
<ul>
  <li>There exists a natural (innate or acquired) way for a domain expert to 
capture a domain problem.</li>
  <li>Deterministic, automated methods exist to derive an optimized 
implementation from the domain-specific description</li>
  <li>There is a significant difference between the best way to describe a 
problem and the best way to implement it in a general-purpose 
programming language</li>
  <li>Achieving a good implementation requires global and/or concurrent 
optimization.</li>
</ul>

<h2 id="where-does-bare-metal-testing-fit">Where does Bare-Metal Testing fit?</h2>
<p>With that in mind, let’s look back at our target application for PSS:
creation of bare-metal software-driven tests. In a typical 
system-development flow, development and verification of hardware and
software proceed on different paths up to a point. Of course, there 
can be some cross-over in the process, but the time when software
really starts to run on the hardware for which it is intended is
once the hardware system is assembled and verified.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/Hw_Sw_VDiagram_640.png" /> 
</p>

<p>Once a stable hardware-like representation of the hardware system 
exists, the integration team can really get started on completing
software for the system. Note that I said “hardware-like”. In many
cases, this representation of the hardware system will be a hardware
emulator, or an FPGA prototype. The key is that the representation
has sufficient stability and performance to support 
software-development efforts.</p>

<p>Two key factors to a successful hardware/software integration process are 
maximizing the stability of the hardware platform and having an efficient
path to reproduce and produce minimized testcases for any bugs found
by the integration team. The quality, quantity, and flexibility of the
bare-metal tests used to verify the system-level hardware platform has
a huge impact on success here.</p>

<h2 id="what-are-bare-metal-tests">What are Bare-Metal Tests?</h2>
<p>In order to appreciate some of the key benefits that PSS has to offer 
in creating bare-metal software-driven tests, it’s useful to understand
a bit more about about the characteristics of bare-metal software tests.</p>

<p>As their name suggests, bare-metal software tests run directly on the
processor cores of a design. Unlike production software, they don’t 
run on top of an operating system or real-time operating system (RTOS),
and consequently don’t have access to services that operating systems
provide, such as:</p>
<ul>
  <li>Dynamic memory allocation</li>
  <li>Threads and processes</li>
  <li>Multi-processor scheduling infrastructure</li>
  <li>Device-driver infrastructure</li>
</ul>

<p>There are very good reasons that bare-metal tests opt to run directly
on the hardware and forego the use of an operating system.</p>

<p>Early software-driven integration testing is performed using a hardware
simulator to provide maximum debug visibility. Simulating a full system
at RTL is a slow process. Even simple operating systems run a 
not-insignificant amount of code prior to execution of the application,
all of which is running very very slowly on a simulated RTL model of 
a processor. Running bare-metal tests enables running more actual test
code.</p>

<p>The code that an operating system runs on start-up assumes that a the
hardware platform is stable. For example, for proper operation, it 
will require that memory accesses to different regions, and very possibly
atomic operations, are working. It will require that exceptions and 
interrupts are stable. Instability in the hardware platform is likely
to manifest itself in kernel panic, “blue screen of death”, or other 
generic error signal that is unlikely to point the developer to the
root cause with any accuracy. We can create much more focused tests
for ensuring stability in various aspects of the platform that can
produce much more accurate failure signatures, allowing the developer
to zero in on the root cause much more quickly.</p>

<p>Finally, writing bare-metal tests gives us much more fine-grained
control over the hardware. The goal of an OS is to produce an 
optimal balance between overall throughput, scheduling fairness,
and other factors such as power consumption. The bare-metal testers
goal is often to hit corner cases that such a ‘balanced’ approach
to running code doesn’t lend itself to.</p>

<h2 id="so-how-does-pss-help">So, how does PSS Help?</h2>
<p>So, we have good reasons for writing our early software-driven 
tests as bare-metal software. But this doesn’t really make them
any easier to write. Over the next few posts we will explore how
the PSS domain-specific language helps to boost test-writing
productivity, while still enabling us to derive lean and mean
bare-metal software-driven tests. We will see how PSS processing
tools bridge the abstraction gap between a PSS-level description
and good bare-metal implementation code. We will see how a PSS
description enables PSS processing tools to make good global
optimizations that are difficult and error-prone for humans. It
remains to be seen whether PSS is considered to provide a natural 
(innate or acquired) way to capture system-level tests. I hope 
you’ll have the information to assess this for yourself by the
end of this series.</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[As a technologist, it’s tempting to focus on what is new (at least, new to me) – especially when choosing what to write about. I’m periodically reminded that there is immense value in returning to topics. Returning to a topic might raise awareness with a different set of readers, but it’s also highly likely that I’ll learn something new about the topic, or that my perspective on the topic will evolve in the process. This post marks the beginning of just such a “back to basics” series that focuses on the Accellera Portable Test and Stimulus (PSS) language. PSS is a specification language for modeling behavior to test. It specifically focuses on providing features that help in creating bare-metal software-driven system-level tests. Consequently, this ‘Intro to PSS’ series will focus on the task of the bare-metal software-driven test writer, and the value PSS provides.]]></summary></entry><entry><title type="html">New Year, New Space</title><link href="https://bitsbytesgates.com/intro/2023/02/16/NewYearNewSpace.html" rel="alternate" type="text/html" title="New Year, New Space" /><published>2023-02-16T00:00:00+00:00</published><updated>2023-02-16T00:00:00+00:00</updated><id>https://bitsbytesgates.com/intro/2023/02/16/NewYearNewSpace</id><content type="html" xml:base="https://bitsbytesgates.com/intro/2023/02/16/NewYearNewSpace.html"><![CDATA[<p>We’ve more than gotten started on the new year. In fact, DVCon – reliably
and predictably held during the last few days of February and initial 
few of March is right around the corner. And, here I am just getting the
first post of the year out.</p>

<p>Getting a late start on blog posts this year isn’t for lack of interesting
ideas and projects to, though. Here are a few things you can look forward 
to in the coming Blog year.</p>

<!--more-->

<h1 id="new-space">New Space</h1>
<p>First, about the new space… For many years, I hosted the bitsbytesgates 
blog on the blogspot.com platform.
It was (relatively) easy to type up posts, and simple was good. That said,
the more technical content I put out (code snippets and such), the more I 
started to hit the usability edges of the blogspot environment. So, like
so many of my peers, I decided it was time to take the plunge and move 
to a new platform, and that this was the year to do it.</p>

<p>Going forward, you can find the bitsbytesgates blog at <a href="https://bitsbytesgates.com">https://bitsbytesgates.com</a>.</p>

<h1 id="python-functional-verification">Python Functional Verification</h1>
<p>Using Python for functional verification continues to be an interest of
mine. Declarative descriptions have also been an interest of mine for some time. 
This year, I want to look more deeply at how some of those declarative
approaches to capturing aspects of verification environments can be deployed
in Python to make Python-based functional verification even more productive.</p>

<h1 id="constrained-random-generation-and-functional-coverage">Constrained-Random Generation and Functional Coverage</h1>
<p>If you’ve been following the blog for a while, you’re aware of some of the
Python-based projects that bring constrained-random generation and 
functional coverage capture and manipulation into Python. Using these
capabilities in Python continues to be key, but I’m looking at making 
some of these capabilities available to projects not implemented in 
Python.</p>

<h1 id="portable-test-and-stimulus-pss">Portable Test and Stimulus (PSS)</h1>
<p>I’ve been involved in the Accellera standards committee for 
Portable Test and Stimulus (PSS) since its inception, but haven’t written
much about it here … until this year. I’m very optimistic about the 
opportunity PSS has to substantially improve the way that we approach
system-level tests – and, especially, the creation of bare-metal software
test content. Look for more about PSS, starting with a ground-up tour, in
the coming year.</p>

<h1 id="conclusion">Conclusion</h1>
<p>With that, welcome to the new blog space, and to a new year of posts. And,
if you happen to be attending DVCon 2023 in San Jose, I hope we get a
chance to interact live and in person!</p>]]></content><author><name></name></author><category term="Intro" /><summary type="html"><![CDATA[We’ve more than gotten started on the new year. In fact, DVCon – reliably and predictably held during the last few days of February and initial few of March is right around the corner. And, here I am just getting the first post of the year out. Getting a late start on blog posts this year isn’t for lack of interesting ideas and projects to, though. Here are a few things you can look forward to in the coming Blog year.]]></summary></entry></feed>