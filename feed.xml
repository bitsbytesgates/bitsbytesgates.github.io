<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://bitsbytesgates.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bitsbytesgates.com/" rel="alternate" type="text/html" /><updated>2025-02-12T02:34:35+00:00</updated><id>https://bitsbytesgates.com/feed.xml</id><title type="html">Bits, Bytes, and Gates</title><subtitle>There&apos;s oh so much fun to be had. At the leading edge,  at the bleeding edge, at the confluence of bits, bytes, and gates.</subtitle><entry><title type="html">PSS: Getting Outside the Box</title><link href="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html" rel="alternate" type="text/html" title="PSS: Getting Outside the Box" /><published>2025-02-11T00:00:00+00:00</published><updated>2025-02-11T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSGettingOutsideTheBox_splash.png" /> 
</p>

<p>In the <a href="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html">last post</a>, 
we showed a SystemVerilog implementation of a PSS model
that printed “Hello World!”. Interesting, perhaps, but quite a ways from 
being useful. In order to be useful, our PSS model needs to interact with
the environment surrounding it.</p>

<p>This post will cover more details about how a PSS model interacts with 
the environment around it, and look at an object-oriented interface between
PSS and a SystemVerilog environment.</p>

<!--more-->

<p>Both PSS and SystemVerilog are object-oriented languages. With language
interoperability, our goal is to keep each language’s view of inteacting
with the “other” consistent with its own norms and conventions. Because
both languages are object-oriented, we want SystemVerilog to see its
interactions with PSS in object-oriented terms, and vice versa.</p>

<p>While we’re looking at an API in the context of our Zuspec PSS to SystemVerilog
transpiler, the goal is to define a language interoperability approach that
will work with many PSS tools.</p>

<p>Essentially, what we want is this:</p>
<div class="mermaid" align="center">
flowchart TD
    subgraph Model1 ["PSS Model1"]
      BFM1_1["BFM1"]
      BFM1_2["BFM2"]
    end
    subgraph Model2 ["PSS Model2"]
      BFM2_1["BFM1"]
      BFM2_2["BFM2"]
    end

    subgraph Sim ["Simulation"]
      BFM1
      BFM2
      BFM3
      BFM4
    end
    Model1 --&gt; Sim
    Model2 --&gt; Sim

</div>

<p>In other words, we want an integration mechanism that supports:</p>
<ul>
  <li>Multiple, independent, instances of PSS model implementations that run concurrently.</li>
  <li>Multiple “logical streams” within each PSS model instance that
interact with the SystemVerilog testbench</li>
</ul>

<p>The biggest obstacle to achieving this is that both PSS and SystemVerilog
use global functions to implement interactions with the outside world. 
Global functions do not allow us to leverage object-oriented language constructs, so 
we will need to add some infrastructure on top.</p>

<h1 id="the-basics">The Basics</h1>
<p>PSS provides <code class="language-plaintext highlighter-rouge">import</code> functions to allow the PSS model to interact 
with the outside world.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">bfm_c</span> <span class="p">{</span>
  <span class="kd">action</span> <span class="nc">write</span> <span class="p">{</span>
    <span class="c1">// </span>
    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
      <span class="n">bfm_write</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above, two functions are declared – one to perform
a read via a BFM, and one to perform a write. These are global
functions, accessible from all PSS contexts.</p>

<p>The PSS LRM specifies how function parameter and return types are 
mapped to SystemVerilog and C. Theoretically, we could map
the functions themselves to <code class="language-plaintext highlighter-rouge">export</code> tasks and functions
in SystemVerilog.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">interface bfm;
  automatic task bfm_write(int unsigned addr, int unsigned data);
  endtask
  export "DPI-C" task bfm_write;

  automatic task bfm_read(output int unsigned data, input int unsigned addr);
  endtask
  export "DPI-C" task bfm_read;

endinterface</code></pre></figure>

<p>The example above shows SystemVerilog <code class="language-plaintext highlighter-rouge">export</code> tasks that mirror the
PSS <code class="language-plaintext highlighter-rouge">import</code> functions. Conceptually, calling <code class="language-plaintext highlighter-rouge">bfm_write</code> in PSS
would translate into a call to the <code class="language-plaintext highlighter-rouge">bfm_write</code> task in SystemVerilog. 
If we do that, though, we have no awareness of multiple PSS model
instances, and little implementation flexibility.  Fortunately, a 
little methodology and a little code generation can help us
get the object-oriented interfaces that we want!</p>

<h2 id="introducing-the-api-class">Introducing the API Class</h2>
<p>Zuspec-SV (our PSS to SV transpiler) defines an Import API class that
contains a virtual method definition for each and every Import function
in the PSS model.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">class pss_import_api extends backend_api;
   
  virtual task bfm_write(int unsigned addr, int unsigned data);
  endtask

  virtual task bfm_read(output int unsigned data, input int unsigned addr);
  endtask

endclass</code></pre></figure>

<p>The code above shows what would be produced for the <code class="language-plaintext highlighter-rouge">bfm_write</code> and
<code class="language-plaintext highlighter-rouge">bfm_read</code> functions shown earlier. The <code class="language-plaintext highlighter-rouge">import</code> API class inherits
from another API class that defines built-in functions that the PSS
model needs to access. Implementing the API can be done simply by
creating a class that inherits from <code class="language-plaintext highlighter-rouge">pss_import_api</code> and providing
implementations of the tasks and functions.</p>

<h2 id="connecting-our-api-implementation">Connecting our API Implementation</h2>
<p>Once we have a SystemVerilog class with properly-implemented methods, 
we need to connect the PSS model implementation to it. This is where
things get a bit tool-specific.</p>

<p>PSS defines a scenario model as the combination of a tree of 
<em>components</em> and a hierarchy of <em>actions</em> that execute in the
context of the components. <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> refers to this 
component/action combination as an <em>Actor</em>. An <em>Actor</em> is 
implemented as a class that accepts the import API class 
as an argument to its constructor.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_top__Entry_actor extends actor_c;
        pss_top comp_tree;
        pss_import_api api;
        executor_base_c default_executor;

        function new(pss_import_api api=null);
           ...
        endfunction
      ...
    endclass</code></pre></figure>

<p>As we saw in the <em>Hello World</em> example, we run a PSS model
by creating an instance of the <em>Actor</em> and calling the
<em>run</em> task.</p>

<h2 id="full-example">Full Example</h2>
<p>Let’s take a step-by-step look at the simple API implementation example
in <code class="language-plaintext highlighter-rouge">zuspec-examples</code>. You can find the full example 
<a href="https://github.com/zuspec/zuspec-examples/tree/main/sv/simple_read_write">here</a>.</p>

<p>If you want to try this example yourself, be sure to update your <code class="language-plaintext highlighter-rouge">Zuspec-SV</code>
version. You can do so in the <code class="language-plaintext highlighter-rouge">zuspec-examples</code> project by running the
following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% ./packages/python/bin/pip install -U zuspec-sv
</code></pre></div></div>

<p>You will need at least version 0.0.9 to run this example.</p>

<p>Let’s start with the PSS code:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Entry</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">bfm_read</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"PSS read data %d"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We declare two import functions – one that writes data via a bus functional 
model (BFM), and one that reads data via a bus functional model.</p>

<p>We then declare a (very) simple PSS Action that calls the <code class="language-plaintext highlighter-rouge">write</code> function
twice, calls the <code class="language-plaintext highlighter-rouge">read</code> function once, and displays the return value.</p>

<h3 id="implementing-the-api">Implementing the API</h3>

<p><code class="language-plaintext highlighter-rouge">Zuspec-SV</code> creates the following API class based on the import functions
declared within the PSS model:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_import_api #(type BaseT=zsp_sv::empty_t) extends backend_api #(BaseT);
        virtual task bfm_write(
                input int unsigned addr,
                input int unsigned data);
            `ZSP_FATAL(("Import function bfm_write is not implemented"));
        endtask
        virtual task bfm_read(
                output int unsigned __retval,
                input int unsigned addr);
            `ZSP_FATAL(("Import function bfm_read is not implemented"));
        endtask
    endclass</code></pre></figure>

<p>Note that the signature of the <code class="language-plaintext highlighter-rouge">bfm_read</code> task is a bit different. This 
is because SystemVerilog tasks do not support a return value, so the
result must be returned via an output parameter. Fortunately, this is
all well-defined by the rules in the PSS LRM.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">package simple_read_write_pkg;
    import pss_types::*;

    class api_impl extends pss_import_api;
        virtual task bfm_write(
            input int unsigned addr,
            input int unsigned data);
            $display("bfm_write: 'h%08h 'h%08h", addr, data);
        endtask

        virtual task bfm_read(
            output int unsigned __retval,
            input int unsigned addr);
            $display("bfm_read: 'h%08h", addr);
            __retval = 42;
        endtask
    endclass

endpackage</code></pre></figure>

<p>Our testbench environment is responsible for providing code, like 
that shown above, to provide an implementation for the import functions.
Our implementation, here, is quite simple: We print a message when either 
task is called, and return the value <code class="language-plaintext highlighter-rouge">42</code> from the <code class="language-plaintext highlighter-rouge">read</code> function.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module simple_read_write;
    import simple_read_write_pkg::*;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic api_impl api = new();
        pss_top__Entry actor = new(api);

        actor.run();
    end
endmodule</code></pre></figure>

<p>Finally, we can put everything together and run our PSS model. The 
code above creates an instance of our implementation of the API 
class, and passes it to the constructor of our PSS <code class="language-plaintext highlighter-rouge">Actor</code> class.
When we run the simulation, we should see something like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bfm_write: 'h00000000 'h12345678
bfm_write: 'h00000004 'h12345678
bfm_read: 'h00000004
PSS read data 42
</code></pre></div></div>

<h1 id="summary-and-whats-next">Summary and What’s Next</h1>
<p>We’ve looked at the funadamentals of a strategy to integrate two 
object-oriented languages, via global functions, 
in an object-oriented way. This approach
gives us flexibility in changing how APIs are implemented using 
the standard object-oriented approaches that we’re used to.</p>

<p>But, we’re not done just yet. You can likely imagine how this 
approach supports multiple indepdent PSS model instances. But,
how does it support API implementations coming from different
sources, and multiple independent streams of activity within
one PSS model? In the next post, we’ll start to dig into how
to interface PSS to verifcation IP (VIP) and bus functional models (BFMs).</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[In the last post, we showed a SystemVerilog implementation of a PSS model that printed “Hello World!”. Interesting, perhaps, but quite a ways from being useful. In order to be useful, our PSS model needs to interact with the environment surrounding it. This post will cover more details about how a PSS model interacts with the environment around it, and look at an object-oriented interface between PSS and a SystemVerilog environment.]]></summary></entry><entry><title type="html">Transpilation and PSS</title><link href="https://bitsbytesgates.com/pss/2025/02/05/Transpilation_and_PSS.html" rel="alternate" type="text/html" title="Transpilation and PSS" /><published>2025-02-05T00:00:00+00:00</published><updated>2025-02-05T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/05/Transpilation_and_PSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/05/Transpilation_and_PSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSTranspilation_splash.png" /> 
</p>

<p>You’re probably familiar with compilers. They take a high-level input description – 
typically a programming language – and distill it down to an efficient 
low-level implementation. Typically the implementation is machine code or 
bytecode. In other words, as close as possible to what will actually execute 
given the language ecosystem.</p>

<p>You might be less familiar with transpilers (or 
source-to-source compilers, as they are <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">also known</a>). Transpilers convert
an input in one programming language to output in another programming language
with a similar level of abstraction. Transpilers have been in use for a very 
long time. For example, the C++ language was originally implemented with 
<a href="https://en.wikipedia.org/wiki/Cfront">Cfront</a>, a transpiler that converted
C++ input to C code that any C compiler could process. More recently, the 
<a href="https://www.typescriptlang.org/">Typescript</a> and 
<a href="https://en.wikipedia.org/wiki/ECMAScript">Javascript/ECMAScript</a> ecosystems
have used transpilation extensively to allow the languages to evolve while
maintaining an impressive level of backward compatibility with older 
implementations of the language.</p>

<p>The next few posts will start to explore what we can do by transpiling
test scenarios in PSS into implementations in existing programming languages.</p>

<!--more-->

<h1 id="is-pss-a-programming-language">Is PSS a Programming Language?</h1>
<p>Both compilers and transpilers are software concepts, so it’s worth asking
whether PSS language is a programming language. Portions of the language 
do provide the features of a standard programming language – if/else,
loops, functions, and data structures. In this portion of the language,
these constructs retain the same <em>imperative</em> semantics as the 
equivalent constructs in software programming languages.</p>

<p>The other major portion of the language has <em>declarative</em> semantics.
This means that we focus on capturing the <em>rules</em> of our test scenarios
instead of capturing how we will <em>implement</em> our test scenarios.</p>

<h2 id="why-be-declarative">Why be declarative?</h2>

<p>Take, for example, test scenarios that exercise a multi-channel DMA
controller. When our test exercises multiple channels at the same
time, it needs to use unique channels. With PSS, we can simply 
state that this is a rule: DMA channels are <em>resources</em> that 
can only be used by a single behavior at a time.</p>

<p>In contrast, if we are writing our tests in a regular programming 
language, we would need to design a channel-allocation algorithm 
to manage DMA channels for our tests. Actually, we would
probably need several algorithms to handle all the corner cases
that our tests need to cover.</p>

<p>The declarative nature of the PSS language increases our testing
productivity by allowing us to capture the rules of our scenarios
and automate the work of implementing tests.</p>

<h1 id="creating-model-implementations">Creating Model Implementations</h1>
<p>Capturing tests in this way has huge productivity benefits. It also
has a (subjective) downside: we need to use a <em>constraint solver</em> 
to evaluate the model and select the data and operation schedule 
that will be used to exercise the design. Constraints solvers are 
marvelous tools for ripping through reams of constraints, but 
they’re not considered <em>fast</em> when compared to the execution speed 
of regular procedural programming languages. In addition, 
constraint solvers typically require substantial resources to run.</p>

<p>This need to <em>solve</em> the PSS model to generate specific tests, 
along with different verification-platform characteristics,
has resulted in two common ways to produce tests from a PSS model:</p>

<ul>
  <li><strong>On-the-Fly Solving</strong> - This model is typically used in simulation.
A special PSS interpreter and constraint solver run in parallel with
the simulation and make choices as they are needed.</li>
  <li><strong>Pre-Run Test Generation</strong> - This model is typically used when 
the test will run on a processor core within the design. In this model,
the entire test is produced as source code prior to the start of 
test execution.  We want to keep the code that runs on the processor 
core simple for many reasons, and pre-solving the PSS model allows 
us to do this.</li>
</ul>

<p>Both of these models are useful and important, but the on-the-fly
model is very interesting because it suggests that we might be able
to leverage the constraint solver within our SystemVerilog simulators
to provide the solving needed to evaluate our PSS models.</p>

<h1 id="transpiling-pss-to-systemverilog">Transpiling PSS to SystemVerilog</h1>
<p>I’ve been working PSS infrastructure, in general, for a while. More
recently, I’ve focused on using that infrastructure to implement the
beginnings of a PSS to SystemVerilog transpiler.</p>

<p>The general flow is shown below.</p>

<div class="mermaid" align="center">
block-beta
%% columns 5
  block:Source
    columns 1
    PssFiles["PSS Files"]
    Files1
    Files2
    Files3
    Files["PSS Source"]
    style Files1 fill:transparent,stroke:transparent,color:transparent
    style Files2 fill:transparent,stroke:transparent,color:transparent
    style Files3 fill:transparent,stroke:transparent,color:transparent
    style Files fill:transparent,stroke:transparent
  end
  block:Pkgs
    columns 1
    ScenarioPkg["Scenario-Specific Types"]
    ModelPkg["Model-Specific Shared Types"]
    Spacer1
    Spacer2
    Spacer3["Generated SV"]
    style Spacer1 fill:transparent,stroke:transparent,color:transparent
    style Spacer2 fill:transparent,stroke:transparent,color:transparent
    style Spacer3 fill:transparent,stroke:transparent
  end
  block:Runtime
    columns 1
    ScenarioPkg2["Scenario-Specific Types"]
    ModelPkg2["Model-Specific Shared Types"]
    ClassLib["Shared Class Library"]
    SVSolver["SystemVerilog Runtime"]
    Runtime1["Runtime"]
    style Runtime1 fill:transparent,stroke:transparent
  end
  Source--&gt;Pkgs
  Pkgs--&gt;Runtime
</div>

<p>Specifically:</p>
<ul>
  <li>The <a href="https://github.com/zuspec/zuspec-sv/">Zuspec-SV</a> tool processes the PSS model 
source to produce an implementation 
for an Action</li>
  <li>It produces two SystemVerilog packages. The first contains types specific to the action 
being implemented. The second contains types shared across all actions captured in the model</li>
  <li>These packages are compiled along with a supporting class library and the user’s testbench,
and executed by a SystemVerilog simulator.</li>
</ul>

<h1 id="a-simple-example">A simple example</h1>

<p>Let’s take a look at a tiny example from the 
<a href="https://github.com/zuspec/zuspec-examples">Zuspec Examples</a> project.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="nn">std_pkg</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">Hello</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>You can find the soure <a href="https://github.com/zuspec/zuspec-examples/blob/main/sv/hello_world/hello_world.pss">here</a>.</p>

<p>This extremely-simple PSS model prints ‘Hello World!’ to the simulation log.</p>

<p>Have a look at the root SystemVerilog module to see how the SystemVerilog
model implementation is invoked:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module top;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic pss_top__Entry actor = new();
        actor.run();
        $finish;
    end

endmodule</code></pre></figure>

<h1 id="where-do-we-go-from-here">Where do we go from here?</h1>

<p>Transpiling PSS to SystemVerilog provides a useful interesting implementation 
option for PSS, both because of the solver within the simulator and because
PSS is frequently used with UVM testbenches.</p>

<p>If you’re interested in trying out the PSS ‘Hello World’ example, have a look
at the instructions in the 
<a href="https://github.com/zuspec/zuspec-examples/blob/main/README.md">README</a> file.</p>

<p>The <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> transpiler is under active development, but the approach 
looks very promising.  Over the next few posts, we’ll have  look at 
additional PSS constructs that we can implement in SystemVerilog and,
more importantly, see how PSS interacts the testbench and design.</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[You’re probably familiar with compilers. They take a high-level input description – typically a programming language – and distill it down to an efficient low-level implementation. Typically the implementation is machine code or bytecode. In other words, as close as possible to what will actually execute given the language ecosystem. You might be less familiar with transpilers (or source-to-source compilers, as they are also known). Transpilers convert an input in one programming language to output in another programming language with a similar level of abstraction. Transpilers have been in use for a very long time. For example, the C++ language was originally implemented with Cfront, a transpiler that converted C++ input to C code that any C compiler could process. More recently, the Typescript and Javascript/ECMAScript ecosystems have used transpilation extensively to allow the languages to evolve while maintaining an impressive level of backward compatibility with older implementations of the language. The next few posts will start to explore what we can do by transpiling test scenarios in PSS into implementations in existing programming languages.]]></summary></entry><entry><title type="html">What’s Next for PSS?</title><link href="https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext.html" rel="alternate" type="text/html" title="What’s Next for PSS?" /><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/PSSFuture_splash.png" /> 
</p>

<p>As the year winds down, it’s a good time to think about the coming year and the
areas where I’d like to have an impact. One area of particular
interest this year is the Portable Test and Stimulus (PSS) standard. The Accellera 
PSS working group released the 3.0 version of the PSS LRM in August, and I’ve felt
fortunate to have been involved with PSS Working Group (PSWG) from its inception,
and to see how the growing body of features in PSS have allowed the language to 
enable test-content portability across simulation, emulation, and post-silicon
targets.</p>

<p>The release of PSS 3.0 also provides an opportunity to step back and consider 
the future of PSS – not just incremental additions to its current field of use,
but also how its use could expand to other portions of the design and verification process.</p>

<!--more-->

<p>Today, the PSS language provides powerful features for capturing test 
scenarios. It’s particularly adept at capturing IP programming sequences
that are reusable from IP to system level.</p>

<div class="mermaid" align="center">
block-beta
columns 1
  block:Areas
    A["Arch"]
    B["Sw Models"]
    C["Impl (RTL)"]
    D["DV (Sim)"]
    E["DV (Emu)"]
    F["Prototying"]
    G["Si Bring-Up"]
    H["Si Validation"]
  end
</div>

<p>Currently, the use of PSS centers around DV, prototyping, and silicon
bring-up. PSS has plenty of room in which to expand adoption in 
these areas, but there are also many others areas where PSS 
could play and add value.</p>

<p>Looking forward, there are three key areas where I’m looking to see growth
in the PSS language and ecosystem:</p>

<h2 id="develop-pss-core-language">Develop PSS Core Language</h2>

<p>An evolving language is critical to maintaining interest and users. 
Needs, styles, and approaches change over time, and a programming
language must react to these changes in requirement in order to remain
relevant. My informal observation is that, since the mid-2010s, more 
programming languages are shortening the interval between updates
to the language. I’m happy to see the PSS language continuing to
grow and evolve in the context of the Accelera PSWG.</p>

<h2 id="grow-pss-ecosystem">Grow PSS Ecosystem</h2>

<p>Ecosystems are key to the success of any programming language. Having a 
vibrant ecosystem means that users of a language will have access to 
code snippets, expertise, and reusable libraries created by other users
of the language. Vibrant ecosystems also act as a pipeline, getting 
students interested in and familiar with the language.</p>

<p>I’d also like to see more publicly-available examples and libraries. 
Having real live code out there to play with is a critical part of
learning a new technology.</p>

<h2 id="exploration-of-new-applications">Exploration of New Applications</h2>

<p>New applications and integrations is the area in which I most like to play.
Each phase of the design process shown above has its own unique 
requirements that it places – most often on <em>how</em> the language is 
processed, but sometimes on the features provided by the language itself
as well.</p>

<p>There are key differences in test requirements across the different platforms
shown in the diagram above, and worth exploring how that impacts how 
tests are implemented. But, in addition, there might be some other interesting
roles for PSS across the process. Could we use PSS, for example, to implement
an architectural model of the design?</p>

<h1 id="thinking-forward">Thinking Forward</h1>
<p>Given these three areas, it’s reasonable to ask how we can “move the needle” 
in each of them. To a certain extent, continued evolution of the core
language might have the simplest answer since there’s a well-established 
group (the Accellera PSWG) with members from across the industry that meet 
weekly to discuss that topic.</p>

<p>Advancing the other two areas poses a technology-access challenge. It’s 
fine to speculate on how PSS might contribute to the design process, 
for example. However, I’d argue that what most people really want to see
are implementations (proof-of-concept or production) that deliver 
concrete results.</p>

<p>The same holds for building knowledge of PSS. It’s fine to read descriptions
about how PSS works and how to use it to create test scenarios. Real learning
takes places when people are able to work with the language themselves and
internalize the key concepts of the language.</p>

<h2 id="pss-and-open-source">PSS and Open Source</h2>
<p>Open source software has been a powerful enabler of exploration in other ecosystems. 
Having open source resources encourages people to learn about a technology. 
It also provides a basis for experimentation that doesn’t require an interested
party to start at zero.</p>

<h2 id="zuspec">Zuspec</h2>
<p>Starting in 2025, I’ll be starting to write more about components within the 
<em>Zuspec</em> umbrella project. Consequently, it’s worth providing a brief 
introduction to what <em>Zuspec</em> is, what it’s not, and what to expect.</p>

<p>Zuspec is a collection of functionality for working with the style of
action-centric dataflow descriptions used by the PSS language. The
philosophy of the component libraries is to keep things as modular as
possible to maximize the reuse opportunities even as we discover different
ways in which to productively use and apply these descriptions.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/Zuspec_crop.png" style="width: 200px" />
</p>

<p>The <em>Zuspec</em> name is a portmanteau of zusammen (German for together) and ‘spec’,
and reflects my ambition for PSS to be a specification that brings together
disciplines such as design and verification that are quite separate today.</p>

<p>From a technical perspective, the vast majority of Zuspec components are 
implemented as C++ libraries (for speed) that also have Python bindings, 
making it easy to use a small amount of Python to mix them together 
into an application.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/ZuspecProjectMap.png" style="width: 800px" />
</p>

<p>Zuspec is much more of a technology framework than a tool today. You won’t find
any fancy GUIs. And, it’s in an early state of development and testing: 
you should expect to find bugs. That said, my hope is that if these 
components can help me to explore new areas of PSS application they can
enable others to do the same. Starting in the new year, I’ll be writing
more about the components and what they allow us to do with a 
PSS-based description</p>

<h1 id="pss-looking-forward">PSS Looking Forward</h1>

<p>I continue to see PSS as having a bright future. It’s providing strong value
in the areas of test-content reuse, with a focus on simulation, emulation, 
and silicon bring-up. And, as more people learn about PSS and get 
hands-on experience with the language and its capabilities, I’m confident 
that adoption will continue to grow. I also see great possibilities for the 
language to expand its application space into domains adjacent to where it 
is applied today.</p>

<p>In the coming year, I’m looking forward to writing more about what PSS 
enables today, and what it could enable in the future. And, of course,
expect to hear more about other tools and technologies related to design
and verification. There is always something new to learn and explore!</p>

<h1 id="references">References</h1>
<ul>
  <li>Accellera - https://accellera.org</li>
  <li>PSS Tutorial Video - https://www.accellera.org/resources/videos/portable-stimulus-tutorial-2024</li>
  <li>PSS LRM - https://www.accellera.org/downloads/standards/portable-stimulus</li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[As the year winds down, it’s a good time to think about the coming year and the areas where I’d like to have an impact. One area of particular interest this year is the Portable Test and Stimulus (PSS) standard. The Accellera PSS working group released the 3.0 version of the PSS LRM in August, and I’ve felt fortunate to have been involved with PSS Working Group (PSWG) from its inception, and to see how the growing body of features in PSS have allowed the language to enable test-content portability across simulation, emulation, and post-silicon targets. The release of PSS 3.0 also provides an opportunity to step back and consider the future of PSS – not just incremental additions to its current field of use, but also how its use could expand to other portions of the design and verification process.]]></summary></entry><entry><title type="html">Easy Access to Python Libraries with a SystemVerilog Convenience API</title><link href="https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API.html" rel="alternate" type="text/html" title="Easy Access to Python Libraries with a SystemVerilog Convenience API" /><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API</id><content type="html" xml:base="https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/11/PyHDL_IF_Convenience_API.png" /> 
</p>

<p>In the last post 
(<a href="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html">DPI Isn’t Enough: Making Python Part of Your SV Testbench</a>), 
we looked at how to use the <a href="https://fvutils.github.io/pyhdl-if">PyHDL-IF</a> library 
to call SystemVerilog from Python. 
This is, in some sense, the most challenging Python and SV interaction to implement. 
And, as the title suggests, it’s something that definitely requires
more than just the raw features of the SystemVerilog DPI.</p>

<p>That said, there are many cases where we simply want to access some functionality
that is readily-available in Python and not readily-available in SystemVerilog. 
In these cases, we don’t need to call back into SystemVerilog from Python. 
Arguably, we <strong>could</strong> simply use SystemVerilog DPI To call the relevant 
<a href="https://docs.python.org/3/c-api/">Python C API</a>. The PyHDL-IF library uses the
Python C API internally to implement cross-calling between SystemVerilog and
Python, and it’s always good to have it as an option. The downside is that code that
uses the C API tends to be rather verbose, so let’s see if we can improve the
situation with a SystemVerilog convenience API.</p>

<!--more-->

<h1 id="pyhdl-if-architecture">PyHDL-IF Architecture</h1>

<p>The PyHDL-IF implements the interface between Python and HDLs with a layered architecture.</p>

<div class="mermaid" align="center">
block-beta
columns 1
  block:UIApp
  columns 1
    TitleApp["App-Specific Interfaces"]
    style TitleApp fill:transparent,stroke:transparent
    block:UICodeAPIs
      UICall["Method Call"]
      UITlm["TLM"]
    end
  end
  block:UIMid
  columns 1
    TitleMid["Convenience API"]
  end
  block:UIDirect
  columns 1
    TitleDirect["CPython API"]
  end
</div>

<p>In the <a href="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html">last post</a>,
we looked at an example built on top of the ‘Call’ API. This is the API that manages blocking cross-calling
between Python and a HDL. Using this API requires us to mark up our Python API with decorators and generate
SystemVerilog source to implement the API in the SystemVerilog environment.</p>

<p>We could use this same approach to “wrap up” the API of a Python library and expose it to SystemVerilog. But,
it often makes sense to use one of the lower-level interface APIs. Let’s look at an example.</p>

<h1 id="loading-json-data">Loading JSON Data</h1>

<p>UVM testbench environments can be highly-configurable when used for complex, configurable IPs. Capturing 
the configuration data in a JSON or YAML file is helpful in keeping all the settings in one place. 
The challenge arises when we want to acccess that data from our UVM environment. Current options include:</p>

<ul>
  <li><strong>Integrate a parser implemented in C via SV DPI</strong></li>
  <li><strong>Implement a parser in SystemVerilog</strong></li>
</ul>

<p>Both of these involve a fair amount of (likely project-specific) work and debugging. In contrast, reading 
a JSON file in Python and iterating through the top-level entries is trivial:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">json</span>

<span class="n">datafile</span> <span class="o">=</span> <span class="s">"data1.json"</span>

<span class="n">fp</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span>
<span class="n">data_s</span> <span class="o">=</span> <span class="n">fp</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
<span class="n">fp</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">data_s</span><span class="p">)</span>
<span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Key: %d %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Key: %s"</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></code></pre></figure>

<h1 id="svpython-convenience-api">SV/Python Convenience API</h1>
<p>Using the PyHDL-IF library, we actually have several options for leveraging Python to access JSON data. 
Let’s look at using <a href="https://fvutils.github.io/pyhdl-if/sv_api.html#systemverilog-api">SystemVerilog convenience API</a>. 
This API is object-oriented and higher level than the raw CPython API (which we also can use).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="k">import</span> <span class="n">pyhdl_if</span><span class="o">::*</span><span class="p">;</span>

    <span class="k">initial</span> <span class="k">begin</span>
        <span class="k">automatic</span> <span class="kt">string</span> <span class="n">datafile</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">json</span><span class="p">,</span> <span class="n">data_fp</span><span class="p">,</span> <span class="n">data_s</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_dict</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_list</span> <span class="n">keys</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="n">value</span><span class="p">$</span><span class="n">plusargs</span><span class="p">(</span><span class="s">"data=%s"</span><span class="p">,</span> <span class="n">datafile</span><span class="p">))</span> <span class="k">begin</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Error: no datafile specified"</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">finish</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">py_gil_enter</span><span class="p">();</span>

        <span class="c1">// Import Python's 'json' package </span>
        <span class="n">json</span> <span class="o">=</span> <span class="n">py_import</span><span class="p">(</span><span class="s">"json"</span><span class="p">);</span>

        <span class="c1">// Open and read the specified data file</span>
        <span class="n">data_fp</span> <span class="o">=</span> <span class="n">py_call_builtin</span><span class="p">(</span><span class="s">"open"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="n">datafile</span><span class="p">),</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span><span class="o">}</span><span class="p">));</span>
        <span class="n">data_s</span> <span class="o">=</span> <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"read"</span><span class="p">);</span> 
        <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"close"</span><span class="p">);</span>

        <span class="c1">// Parse the data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">py_dict</span><span class="o">::</span><span class="n">mk</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"loads"</span><span class="p">,</span> 
            <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span><span class="n">data_s</span><span class="o">}</span><span class="p">)));</span>

        <span class="c1">// Get the list of keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">keys</span><span class="p">();</span>

        <span class="c1">// Iterate based on the list size</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">keys</span><span class="p">.</span><span class="nb">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0d %0s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">to_str</span><span class="p">());</span>
        <span class="k">end</span>

        <span class="c1">// Use an iterator</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">py_iter</span> <span class="n">i</span><span class="o">=</span><span class="n">keys</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span> <span class="p">)</span> <span class="k">begin</span>
            <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">it</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0s"</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">to_str</span><span class="p">());</span>
        <span class="k">end</span>

        <span class="n">py_gil_leave</span><span class="p">();</span>
    <span class="k">end</span></code></pre></figure>

<p>The code above accomplishes the same thing as the pure-Python code that reads a JSON file. 
While the SystemVerilog code involves roughly twice as many lines as the pure-Python code,
it <em>is</em> pure SystemVerilog. And, it didn’t require us to do any code generation or any
special “tagging” of Python code. Let’s look in more detail at what’s happening in this
code, and how the PyHDL-IF convenience API helps us out.</p>

<h2 id="calling-built-in-functions">Calling Built-in Functions</h2>
<p>One of the first things we need to do is to read the contents of the JSON data file. 
The Python <code class="language-plaintext highlighter-rouge">open</code> function is a built-in. This means that it’s not contained in 
another package or module that needs to be imported.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="n">data_fp</span> <span class="o">=</span> <span class="n">py_call_builtin</span><span class="p">(</span><span class="s">"open"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="n">datafile</span><span class="p">),</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span><span class="o">}</span><span class="p">));</span></code></pre></figure>

<p>PyHDL-IF provides the <code class="language-plaintext highlighter-rouge">py_call_builtin</code> function to call built-ins. The PYthon C API
requires function arguments to be Python objects, and to be packed in a Tuple. The
<code class="language-plaintext highlighter-rouge">py_tuple::mk_init</code> function handles creating the properly-sized tuple. The helper
function <code class="language-plaintext highlighter-rouge">py_from_str</code> creates a Python string object from a SystemVerilog string value.</p>

<h2 id="calling-methods">Calling Methods</h2>
<p>The <code class="language-plaintext highlighter-rouge">open</code> function returns a Python stream object. We want to read all the data from
the file and then close the file.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="n">data_s</span> <span class="o">=</span> <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"read"</span><span class="p">);</span> 
        <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"close"</span><span class="p">);</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">call_attr</code> function implemented by the <code class="language-plaintext highlighter-rouge">py_object</code> SV class handles looking up the
requested attribute within the Python object and calling it. In this case, 
both <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">close</code> methods take no arguments.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="c1">// Parse the data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">py_dict</span><span class="o">::</span><span class="n">mk</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"loads"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span><span class="n">data_s</span><span class="o">}</span><span class="p">)));</span></code></pre></figure>

<p>Python views everything as an object. Consequently, the <code class="language-plaintext highlighter-rouge">loads</code> method within
the <code class="language-plaintext highlighter-rouge">json</code> package is just an attribute with the json package object. This means
that we can call it in the same way we would invoke a method on a class-type object.
We happen to know that the return of the <code class="language-plaintext highlighter-rouge">loads</code> method is a Python dictionary (<code class="language-plaintext highlighter-rouge">dict).
Therefore, we can directly convert the return value to a </code>py_dict` object. This allows
us to use convenience methods to access the data.</p>

<h2 id="iterating">Iterating</h2>
<p>Now that we have a Python dictionary containing the JSON data, we likely will 
want to iterate over it. The PyHDL-IF objects also provide some convenience 
APIs to help simplify this process as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="c1">// Get the list of keys</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">keys</span><span class="p">();</span>

    <span class="c1">// Iterate based on the list size</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">keys</span><span class="p">.</span><span class="nb">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0d %0s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">to_str</span><span class="p">());</span>
    <span class="k">end</span></code></pre></figure>

<p>A Python dictionary returns it key set as a list. Perhaps the simplest way
to iterate over the items of list is to get each element via its index,
as shown above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="c1">// Use an iterator</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">py_iter</span> <span class="n">i</span><span class="o">=</span><span class="n">keys</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span> <span class="p">)</span> <span class="k">begin</span>
        <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">it</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0s"</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">to_str</span><span class="p">());</span>
    <span class="k">end</span></code></pre></figure>

<p>The list object also implements Python’s <em>iteration</em> interface. PyHDL-IF
also provides helper types and functions around this interface. We can
still use a SystemVerilog <em>for</em> loop. The difference is that the iteration
variable is actually a Python iterator object. Here, again, the convenience
API simplifies the user code compared to using the raw CPython API.</p>

<h1 id="conclusion">Conclusion</h1>
<p>The PyHDL-IF Python convenience API enables you to call Python code from
SystemVerilog without the need to generate any application-specific 
code, and with less work that directly using the CPython API would require.
This reduction of effort makes is incredibly simple to augment the capabilities
of your existing testbench with those of a library from the vast Python ecosystem.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li><a href="https://fvutils.github.io/pyhdl-if/">PyHDL-IF Documentation</a></li>
  <li><a href="https://fvutils.github.io/pyhdl-if/sv_api.html">PyHDL-IF SV Convenience API</a></li>
  <li><a href="https://docs.python.org/3/c-api/index.html">CPython API</a></li>
</ul>]]></content><author><name></name></author><category term="Python" /><summary type="html"><![CDATA[In the last post (DPI Isn’t Enough: Making Python Part of Your SV Testbench), we looked at how to use the PyHDL-IF library to call SystemVerilog from Python. This is, in some sense, the most challenging Python and SV interaction to implement. And, as the title suggests, it’s something that definitely requires more than just the raw features of the SystemVerilog DPI. That said, there are many cases where we simply want to access some functionality that is readily-available in Python and not readily-available in SystemVerilog. In these cases, we don’t need to call back into SystemVerilog from Python. Arguably, we could simply use SystemVerilog DPI To call the relevant Python C API. The PyHDL-IF library uses the Python C API internally to implement cross-calling between SystemVerilog and Python, and it’s always good to have it as an option. The downside is that code that uses the C API tends to be rather verbose, so let’s see if we can improve the situation with a SystemVerilog convenience API.]]></summary></entry><entry><title type="html">DPI Isn’t Enough: Making Python Part of Your SV Testbench</title><link href="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html" rel="alternate" type="text/html" title="DPI Isn’t Enough: Making Python Part of Your SV Testbench" /><published>2024-11-04T00:00:00+00:00</published><updated>2024-11-04T00:00:00+00:00</updated><id>https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB</id><content type="html" xml:base="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/11/DPI_Isnt_Enough_splash.png" /> 
</p>

<p>I’ve been using Python for verification since early 2019 for personal projects,
and have found both the language and the rich ecosystem of general and
special-purpose libraries to be incredibly helpful in quickly and efficiently 
bringing up a testbench environment. <a href="https://www.cocotb.org">cocotb</a>, 
the most popular integration between Python and HDL simulators, integrates with 
the simulator at the signal level. This isn’t a problem as long as you fully adopt 
Python as your testbench
methodology and implement everything in Python – from test scenario down to BFMs 
interacting with signals. Sometimes this is the case, but often we have an existing
SystemVerilog environment that we’d like to mix some Python into.  We might have an 
existing BFM implemented in SystemVerilog that we’d like to call from Python. 
We might have an existing UVM environment from which we want to call a Python library.</p>

<p>SystemVerilog simulators support the Direct Procedure Interface (DPI), of course,
which allows SystemVerilog to call C code and for C code to call SystemVerilog.
Unfortunately, DPI on its own, doesn’t provide the features that we need for 
a fully-featured integration between Python and a HDL simulation. As you might
surmise, though, I’m about to describe a library 
(<a href="https://github.com/fvutils/pyhdl-if">PyHDL-IF</a>) that fills in the missing pieces.
Before we get there, though, let’s have a look at how we’d like to interact
with Python in a SystemVerilog testbench</p>

<!--more-->

<h1 id="using-python-from-sv-and-vice-versa">Using Python from SV and Vice Versa</h1>

<h2 id="calling-python-from-sv">Calling Python from SV</h2>

<p>Requirements:</p>
<ul>
  <li>Be able to keep things dynamic
    <ul>
      <li>Don’t require any Python library-specific SV code in order to use the library</li>
      <li>Be able to look up Python elements by name, etc</li>
    </ul>
  </li>
  <li>Ideally, have some utilities on the SV side to make this easier</li>
</ul>

<p>This is actually pretty easy, since the CPython interpreter has a C API. 
If we expose the C API via SystemVerilog DPI, we can make the same calls from
SystemVerilog that we would make from a C/C++ application. The C API
is fairly low-level and detailed, but we can always add a layer of SystemVerilog
utility classes on top.</p>

<p>This type of integration works well for using Python libraries to access 
data (ie JSON, YAML, etc), when we want to manipulate data using a library
like Pandas, or when we want to use a Python library to generate reference
data. In other words, as long as our SV call to Python returns immediately.</p>

<h2 id="calling-sv-from-python">Calling SV from Python</h2>

<p>Python gets much more interesting – and useful – in a SystemVerilog 
testbench when a Python method call from SystemVerilog can 
consume simulation time.</p>

<p>This allows us to implement active elements of a our testbench, 
such as tests, in Python. It also allows us to call existing
testbench elements, such Bus Functional Models (BFMs), from Python.</p>

<p>This usecase is where SystemVerilog DPI poses some technical challenges. 
Both SystemVerilog and Python implement cooperative multi-threading, 
Unfortunately, the requirements that they place on how threaded behavior 
interacts with the outside world (and vice versa) prevent cross-calling
in a ‘blocking’ manner between the two languages.</p>

<h2 id="additional-requirements">Additional Requirements</h2>

<p>Beyond the raw capability to cross-call between SystemVerilog and Python,
there a few additional requirements that vastly simplify the ability
to create reusable infrastructure.</p>
<ul>
  <li>Reusable functionality should be implemented by Python and SystemVerilog
code only. Application-specific DPI C code brings platform dependencies
and exposes us to implementation details of how different simulators 
deal implement DPI. These are things you want to deal with as infrequently 
as possible, and certainly not every time you add a new Python+SV library.</li>
  <li>Any generated code should be, at most, application-specific. Specifically,
the end user shouldn’t need to re-generate application-specific code.</li>
</ul>

<h1 id="pyhdl-if-package">PyHDL-IF Package</h1>

<div class="mermaid" align="center">
block-beta
columns 1
  block:UICode
  columns 1
    Title["App-Specific Code"]
    style Title fill:transparent,stroke:transparent
    block:UICodeLanguages
        UIPython["Python"]
        UIEmpty["Spacer"]
        style UIEmpty fill:transparent,stroke:transparent,color:transparent
        UISystemVerilog["SystemVerilog"]
    end
  end
  block:Codegen
  columns 1
    block:CodegenI
      CodegenM1["CodegenM1"]
      CodegenPad["CodegenPad"]
      CodegenM2["CodegenM2"]
      style CodegenM1 fill:transparent,stroke:transparent,color:transparent
      style CodegenPad fill:transparent,stroke:transparent,color:transparent
      style CodegenM2 fill:transparent,stroke:transparent,color:transparent
    end
    CodegenTitle["Code Generator"]
    style CodegenTitle fill:transparent,stroke:transparent
  end
  UIPython --&gt; CodegenM1
  CodegenM2 --&gt; UISystemVerilog
  block:Library
  columns 1
    block:LibraryI
      LibraryPy["Python"]
      LibraryDpi["DPI"]
      LibrarySV["SystemVerilog"]
    end
    LibraryTitle["Core PyHDL-IF Library"]
    style LibraryTitle fill:transparent,stroke:transparent
  end
</div>

<p>With those use models and requirements in mind, let’s take a look at the
PyHDL-IF library. This library is designed to implement the low-level
details of interfacing between Python and SystemVerilog at the 
method-call level, such that you can focus on writing SystemVerilog
and Python and ignore the low-level details implemented in C.</p>

<p>The PyHDL-IF package has several components, but the two most-relevant
ones for us are shown in the diagram above.
PyHDL-IF provides a SystemVerilog API for calling into Python, and
Python and DPI libraries to support calling back into SystemVerilog 
from Python. It also provides a SystemVerilog code generator to create
SystemVerilog class APIs to simplify the process of cross-calling 
between the two languages.</p>

<h1 id="an-example">An Example</h1>
<p>To better understand all of this, let’s walk through an example. You can find 
the full code of this example here: <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/call/dpi/call_sv_bfm">call_sv_bfm example</a></p>

<div class="mermaid" align="center">
block-beta
block:Outer
columns 1
  block:Inner
  columns 2
    block:Python
    columns 1
      PySeq(["Python Sequence"])
      PyPad1["Python Pad"]
      PyPad2["Python Pad"]
      PyTitle["Python"]
      style PyTitle fill:transparent,stroke:transparent
      style PyPad1 fill:transparent,stroke:transparent,color:transparent
      style PyPad2 fill:transparent,stroke:transparent,color:transparent
    end
    block:SvTB
    columns 1
      WbBfm["Wishbone BFM"]
      SvPad["Pad"]
      Init["Initial Block"]
      SvTbTitle["SystemVerilog TB"]
      style SvTbTitle fill:transparent,stroke:transparent
      style SvPad fill:transparent,stroke:transparent,color:transparent
    end

    Init --&gt; PySeq
    PySeq --&gt; WbBfm
  end
end
</div>

<p>Here’s a block diagram of what’s happening. We have a SystemVerilog testbench
that contains an instance of a Wishbone BFM written in SystemVerilog. Our
goal is to write a test in Python that will call tasks in the BFM. We want
to start that Python test from SystemVerilog as well.</p>

<p>Let’s dig into some details on how this all fits together.</p>

<h2 id="python-bfm-interface">Python BFM Interface</h2>
<p>Let’s start with the Python interface to the Wishbone BFM. You can find the full source here:
<a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/call/dpi/call_sv_bfm/call_sv_bfm.py">call_sv_bfm.py</a></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">ctypes</span> <span class="k">as</span> <span class="n">ct</span>
<span class="kn">import</span> <span class="n">hdl_if</span> <span class="k">as</span> <span class="n">hif</span>

<span class="nd">@hif.api</span>
<span class="k">class</span> <span class="nc">WishboneInitiator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@hif.imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span> <span class="p">:</span> <span class="n">ct</span><span class="p">.</span><span class="n">c_uint32</span><span class="p">,</span> <span class="n">data</span> <span class="p">:</span> <span class="n">ct</span><span class="p">.</span><span class="n">c_uint32</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@hif.imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span> <span class="p">:</span> <span class="n">ct</span><span class="p">.</span><span class="n">c_uint32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ct</span><span class="p">.</span><span class="n">c_uint32</span><span class="p">:</span>
        <span class="k">pass</span></code></pre></figure>

<p>A class decorated with the <em>api</em> decorator specifies a cross-language
API. Methods within that class that are decorated with <em>import</em> or <em>export</em>
decorators support cross-language calling.</p>

<p>Methods are described with respect to Python:</p>
<ul>
  <li>When an <em>Import</em> method is called from Python, the matching 
SystemVerilog method is called</li>
  <li>When an <em>Export</em> method is called from SystemVerilog, the 
matching Python method is called.</li>
</ul>

<p>Both Python and SystemVerilog have special rules about coroutine methods.
In both languages, a coroutine method can call another coroutine method 
or a non-coroutine method. However, a non-coroutine method cannot invoke
a coroutine method. It’s critical to keep this aligned between SystemVerilog
and Python:</p>
<ul>
  <li>An <em>async</em> Python method matches with a SystemVerilog <em>task</em></li>
  <li>A plain Python method matches with a SystemVerilog <em>function</em></li>
</ul>

<p>The API class, with it’s decorators is used for two purposes. One, somewhat
obviously, is to implement the Python side of a cross-language API. The
other is to generate SystemVerilog to implement the SystemVerilog portion 
of the API.</p>

<h2 id="systemverilog-bfm">SystemVerilog BFM</h2>
<p>Let’s move on and take a look at the Wishbone BFM that we will access 
using the API class that we’ve defined above. You can find the full code here:
<a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/call/dpi/call_sv_bfm/wb_init_bfm.sv">wb_init_bfm.sv</a></p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">WishboneInitiatorBFM</span><span class="p">(</span>
    <span class="kt">input</span>           <span class="n">clock</span><span class="p">,</span>
    <span class="kt">input</span>           <span class="n">reset</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>        <span class="n">adr</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>        <span class="n">dat_w</span><span class="p">,</span>
    <span class="kt">input</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>             <span class="n">dat_r</span><span class="p">,</span>
    <span class="kt">output</span>                  <span class="n">cyc</span><span class="p">,</span>
    <span class="kt">input</span>                   <span class="n">err</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>         <span class="n">sel</span><span class="p">,</span>
    <span class="kt">output</span>                  <span class="n">stb</span><span class="p">,</span>
    <span class="kt">input</span>                   <span class="n">ack</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span>              <span class="n">we</span>
<span class="p">);</span>
<span class="c1">// ...</span>

    <span class="k">task</span> <span class="n">bfm_write</span><span class="p">(</span><span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">adr_v</span><span class="p">,</span> <span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">dat_v</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="c1">// Works with the state machine to perform a write</span>
    <span class="k">endtask</span>

    <span class="c1">// ...</span>

        <span class="kt">class</span> <span class="n">WishboneInitiatorImpl</span> <span class="k">extends</span> <span class="n">WishboneInitiator</span><span class="p">;</span>
        <span class="kt">virtual</span> <span class="k">task</span> <span class="nb">write</span><span class="p">(</span><span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">data</span><span class="p">);</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="k">endtask</span>

        <span class="kt">virtual</span> <span class="k">task</span> <span class="n">read</span><span class="p">(</span>
            <span class="kt">output</span> <span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">retval</span><span class="p">,</span> <span class="kt">input</span> <span class="kt">int</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">);</span>
            <span class="n">bfm_read</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">endtask</span>

    <span class="k">endclass</span>

    <span class="n">WishboneInitiatorImpl</span>       <span class="n">m_api_obj</span><span class="p">;</span>

    <span class="c1">// Register ourselves with the PyHDL-IF object registry</span>
    <span class="k">initial</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">init</span>
        <span class="n">m_api_obj</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">end</span>

    <span class="c1">// ...</span>
<span class="k">endmodule</span></code></pre></figure>

<p>Key portions of the BFM interface code are shown above. The BFM defines 
<em>bfm_read</em> and <em>bfm_write</em> tasks that are used to drive read and write operations
via the signal-level interface.</p>

<p>The BFM defines a local class (<em>WishboneInitiatorImpl</em>) that inherits from 
a class (<em>WishboneInitiator</em>) that is generated from the Python class specification
of the API. The derived class here implements the <em>read</em> and <em>write</em> tasks in 
terms of the BFM’s existing tasks.</p>

<p>Finally, the BFM module creates an instance of the API implementation class.</p>

<h2 id="python-test-class">Python Test Class</h2>
<p>Okay, thus far we have a SystemVerilog BFM and a Python API definition for
calling it. Now, let’s look at the test code that uses that API. You can find the
full source here:
<a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/call/dpi/call_sv_bfm/call_sv_bfm.py">call_sv_bfm.py</a></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">ctypes</span> <span class="k">as</span> <span class="n">ct</span>
<span class="kn">import</span> <span class="n">hdl_if</span> <span class="k">as</span> <span class="n">hif</span>

<span class="nd">@hif.api</span>
<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@hif.exp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bfm</span> <span class="p">:</span> <span class="n">ct</span><span class="p">.</span><span class="n">py_object</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
            <span class="n">wr_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'[Py] writing: </span><span class="si">{</span><span class="n">wr_val</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">bfm</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="mh">0x8000_0000</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="n">wr_val</span><span class="p">)</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="k">await</span> <span class="n">bfm</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mh">0x8000_0000</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'[Py] readback: </span><span class="si">{</span><span class="n">rd</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">wr_val</span> <span class="o">==</span> <span class="n">rd</span></code></pre></figure>

<p>Our test code is encapsulated in a Python class with an <code class="language-plaintext highlighter-rouge">async</code> method.
Our test method expects to receive a handle to the BFM API, which it will 
use to perform reads and writes.</p>

<h2 id="top-level-testbench">Top-level Testbench</h2>
<p>Finally, let’s take a look at the top-level testbench that pulls it all 
together. You can find the full source here:
<a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/call/dpi/call_sv_bfm/call_sv_bfm.sv">call_sv_bfm.sv</a></p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">call_sv_bfm</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">pyhdl_if</span><span class="o">::*</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">call_sv_bfm_pkg</span><span class="o">::*</span><span class="p">;</span>

    <span class="c1">// ...</span>

    <span class="n">WishboneInitiatorBFM</span>    <span class="n">init_bfm</span><span class="p">(</span>
        <span class="p">.</span><span class="n">clock</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span>
        <span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">reset</span><span class="p">),</span>
        <span class="p">.</span><span class="n">adr</span><span class="p">(</span><span class="n">adr</span><span class="p">),</span>
        <span class="p">.</span><span class="n">dat_r</span><span class="p">(</span><span class="n">dat_r</span><span class="p">),</span>
        <span class="p">.</span><span class="n">dat_w</span><span class="p">(</span><span class="n">dat_w</span><span class="p">),</span>
        <span class="p">.</span><span class="n">stb</span><span class="p">(</span><span class="n">stb</span><span class="p">),</span>
        <span class="p">.</span><span class="n">cyc</span><span class="p">(</span><span class="n">cyc</span><span class="p">),</span>
        <span class="p">.</span><span class="n">ack</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
        <span class="p">.</span><span class="n">we</span><span class="p">(</span><span class="n">we</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">initial</span> <span class="k">begin</span>
        <span class="k">automatic</span> <span class="n">Test</span> <span class="n">test</span><span class="p">;</span>

        <span class="n">pyhdl_if_start</span><span class="p">();</span>

        <span class="p">#</span><span class="mi">50</span><span class="n">ns</span><span class="p">;</span>
        <span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Create an instance of the Test class and run</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"%0t --&gt; run"</span><span class="p">,</span> <span class="p">$</span><span class="kt">time</span><span class="p">);</span>
        <span class="n">test</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
        <span class="n">test</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">init_bfm</span><span class="p">.</span><span class="n">m_api_obj</span><span class="p">.</span><span class="n">m_obj</span><span class="p">);</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"%0t &lt;-- run"</span><span class="p">,</span> <span class="p">$</span><span class="kt">time</span><span class="p">);</span>
        <span class="p">$</span><span class="nb">finish</span><span class="p">;</span>
    <span class="k">end</span>

<span class="k">endmodule</span></code></pre></figure>

<p>The top-level testbench instances the BFM. This results in the BFM creating an
instance of the Python class that can be used to call the BFM. The result is 
a SystemVerilog class that holds a handle to the corresponding Python class.</p>

<p>The top-level ‘initial’ block in the test module creates an instance of the
<code class="language-plaintext highlighter-rouge">Test</code> Python class. As with the BFM, the result is a SystemVerilog class
that holds a handle to the matching Python class.</p>

<p>Finally, we call the <code class="language-plaintext highlighter-rouge">run</code> method on the Test class and pass a handle to the
BFM’s Python class. The run method will, of course, call back into 
SystemVerilog to invoke the BFM’s methods.</p>

<h2 id="summary">Summary</h2>
<p>We’ve quickly walked through an example of integrating Python and SystemVerilog
such that we can implement Python methods that make task calls into the simulator.
This can allow us to either quickly graft some Python onto am existing BFM we 
have in our testbench. It could allow us to easily add an existing SystemVerilog
BFM to our existing cocotb Python testbench and call it from our Python tests.
There are, of course, more applications and usecases for PyHDL-IF. We’ll look at those
in future posts.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="https://www.cocotb.org">cocotb</a>,</li>
  <li><a href="https://github.com/fvutils/pyhdl-if">PyHDL-IF library</a></li>
</ul>]]></content><author><name></name></author><category term="Python" /><summary type="html"><![CDATA[I’ve been using Python for verification since early 2019 for personal projects, and have found both the language and the rich ecosystem of general and special-purpose libraries to be incredibly helpful in quickly and efficiently bringing up a testbench environment. cocotb, the most popular integration between Python and HDL simulators, integrates with the simulator at the signal level. This isn’t a problem as long as you fully adopt Python as your testbench methodology and implement everything in Python – from test scenario down to BFMs interacting with signals. Sometimes this is the case, but often we have an existing SystemVerilog environment that we’d like to mix some Python into. We might have an existing BFM implemented in SystemVerilog that we’d like to call from Python. We might have an existing UVM environment from which we want to call a Python library. SystemVerilog simulators support the Direct Procedure Interface (DPI), of course, which allows SystemVerilog to call C code and for C code to call SystemVerilog. Unfortunately, DPI on its own, doesn’t provide the features that we need for a fully-featured integration between Python and a HDL simulation. As you might surmise, though, I’m about to describe a library (PyHDL-IF) that fills in the missing pieces. Before we get there, though, let’s have a look at how we’d like to interact with Python in a SystemVerilog testbench]]></summary></entry><entry><title type="html">Of Register Models and Standards</title><link href="https://bitsbytesgates.com/pss/2023/10/31/OfRegisters_and_Standards.html" rel="alternate" type="text/html" title="Of Register Models and Standards" /><published>2023-10-31T00:00:00+00:00</published><updated>2023-10-31T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/10/31/OfRegisters_and_Standards</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/10/31/OfRegisters_and_Standards.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/10/OfRegistersAndStandards_splash.png" />
</p>

<p>Memory-mapped registers play an integral part in configuring and driving
the operation of the vast majority of digital designs today. As a 
consequence, it’s not surprising that each language and methodology 
involved in the design, verification, and documentation of digital
designs has its own way of interacting with registers. Fortunately,
standard languages and descriptions exist that allow these language-
and methodology-specific formats to be created from a single central
description.</p>

<p>This post focuses on the results of a weekend project that allows 
a Portable Test and Stimulus (PSS) register access layer to be created 
from SystemRDL input.</p>

<!--more-->

<h1 id="why-so-many-rals">Why so Many RALs?</h1>
<p>Nearly every design and verification environment defines a way to access
and manipulate registers. UVM provides a set of classes for capturing
the definition of register fields, register banks, and address maps. It’s
common when writing low-level firmware or tests in C to have either 
pre-processor defines or C ‘structs’ that specify the layout of fields
within registers and registers within the device memory map. PSS, as well,
defines a set of data structures to use in specifying the layout of 
registers.</p>

<p>Why go to this effort? The simple answer is that it makes code much easier
to create and understand, which makes mistakes much less likely.</p>

<p>Consider the following register, which captures two aspects of how a DMA
transfer is carried out.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/10/WB_DMA_Channel_SZ_Reg.png" />
</p>

<p>Let’s assume that we want to configure the 
DMA engine to transfer a total of 128 words, with a chunk size of
4 words.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">uint32_t</span> <span class="n">tot_chk_sz_v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">tot_chk_sz_v</span> <span class="o">|=</span> <span class="mi">128</span><span class="p">;</span> <span class="c1">// set total size</span>
  <span class="n">tok_chk_sz_v</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
  <span class="n">write32</span><span class="p">(</span><span class="n">chk_sz_reg</span><span class="p">,</span> <span class="n">tot_chk_sz_v</span><span class="p">);</span></code></pre></figure>

<p>This code certainly accomplishes the job. It will result in the 
intended values being written into the register. However, other than comments, 
there is nothing in this code to provide meaning to the constants that are used.
If you’re like me, revisiting this code after a few months will have you
reaching for the DMA Engine’s programmers’ guide to remember what all
those numbers mean.</p>

<p>Using a register-access layer makes our code more readable. For example,
here is that same code in C using a struct-based register access layer:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="n">fwperiph_dma_ch_sz</span> <span class="n">tot_chk_sz_v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">tot_chk_sz_v</span><span class="p">.</span><span class="n">tot_sz</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="n">tot_chk_sz_v</span><span class="p">.</span><span class="n">chk_sz</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">write32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">ch_sz</span><span class="p">,</span> <span class="n">tot_chk_sz_v</span><span class="p">.</span><span class="n">value</span><span class="p">);</span></code></pre></figure>

<p>Even without going into detail on exactly what is happening here, the
code conveys a much better picture of what is happening. And, we don’t
need to worry about shifting and masking our data to cause it to be 
placed in the right bit positions.</p>

<h1 id="register-description-standards">Register-description Standards</h1>
<p>This is great, but across a project we’re likely to need to have 
register access layers for UVM, C, and (just maybe) PSS. Clearly, 
environment-specific register-access layers helps us be productive. But, 
having to create each by hand has a high cost. Fortunately, there exist
a couple of standard description language for capturing the layout of 
registers. This allows us to capture the register layout once, and 
use automation tools to generate the specific 
register-access layers that we need.</p>

<h2 id="ip-xact--registers-and-more-in-xml">IP-XACT – Registers (and more) in XML</h2>
<p><a href="https://www.accellera.org/downloads/standards/ip-xact">IP-XACT</a> has been 
around in one flavor or another since around 2004. Its purpose is 
to document the external and programming interfaces of IPs
in a machine readable format. While this mission is much more expansive
than just capturing registers, IP-XACT also supports capturing 
register definitions.</p>

<p>In IP-XACT, our DMA transfer-size register description looks like this:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml">    <span class="nt">&lt;ipxact:register&gt;</span>
        <span class="nt">&lt;ipxact:name&gt;</span>SZ<span class="nt">&lt;/ipxact:name&gt;</span>
        <span class="nt">&lt;ipxact:addressOffset&gt;</span>'h4<span class="nt">&lt;/ipxact:addressOffset&gt;</span>
        <span class="nt">&lt;ipxact:size&gt;</span>32<span class="nt">&lt;/ipxact:size&gt;</span>
        <span class="nt">&lt;ipxact:field&gt;</span>
          <span class="nt">&lt;ipxact:name&gt;</span>tot_sz<span class="nt">&lt;/ipxact:name&gt;</span>
          <span class="nt">&lt;ipxact:description&gt;</span>Total transfer size (in words)<span class="nt">&lt;/ipxact:description&gt;</span>
          <span class="nt">&lt;ipxact:bitOffset&gt;</span>0<span class="nt">&lt;/ipxact:bitOffset&gt;</span>
          <span class="nt">&lt;ipxact:bitWidth&gt;</span>12<span class="nt">&lt;/ipxact:bitWidth&gt;</span>
          <span class="nt">&lt;ipxact:volatile&gt;</span>true<span class="nt">&lt;/ipxact:volatile&gt;</span>
          <span class="nt">&lt;ipxact:access&gt;</span>read-write<span class="nt">&lt;/ipxact:access&gt;</span>
        <span class="nt">&lt;/ipxact:field&gt;</span>
        <span class="nt">&lt;ipxact:field&gt;</span>
          <span class="nt">&lt;ipxact:name&gt;</span>chk_sz<span class="nt">&lt;/ipxact:name&gt;</span>
          <span class="nt">&lt;ipxact:description&gt;</span>Chunk size<span class="nt">&lt;/ipxact:description&gt;</span>
          <span class="nt">&lt;ipxact:bitOffset&gt;</span>16<span class="nt">&lt;/ipxact:bitOffset&gt;</span>
          <span class="nt">&lt;ipxact:bitWidth&gt;</span>9<span class="nt">&lt;/ipxact:bitWidth&gt;</span>
          <span class="nt">&lt;ipxact:volatile&gt;</span>true<span class="nt">&lt;/ipxact:volatile&gt;</span>
          <span class="nt">&lt;ipxact:access&gt;</span>read-write<span class="nt">&lt;/ipxact:access&gt;</span>
        <span class="nt">&lt;/ipxact:field&gt;</span>
    <span class="nt">&lt;/ipxact:register&gt;</span></code></pre></figure>

<p>IP-XACT captures all the data we need, and provides a great interchange
format between tools. The one thing it’s (subjectively) not good at is
providing a human-friently description. XML, after all, is quite 
verbose.</p>

<h2 id="systemrdl--a-language-for-describing-registers">SystemRDL – A language for describing registers</h2>
<p>That brings us to 
<a href="https://www.accellera.org/downloads/standards/systemrdl">SystemRDL</a>. 
SystemRDL is a domain-specific language (DSL) specifically designed for 
capturing the structure and layout of registers.</p>

<p>In SystemRDL, our DMA transfer-size register description looks like 
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg fwperiph_dma_channel_sz {
    field {
        desc = "Total transfer size (in words)";
        hw = rw;
        sw = rw;
    } tot_sz[11:0];
    field {
        desc = "Chunk size";
        hw = rw;
        sw = rw;
    } chk_sz[24:16];
};
</code></pre></div></div>

<p>While the code above captures the same information as the previous 
IP-XACT snippet, the SystemRDL description is shorter and (arguably) 
much easier for a human to capture. Ease of use is generally the benefit 
of using a domain-specific language. The cost is the 
expense (dollars, development time, etc) of tools to support
a domain-specific language.</p>

<h1 id="peakrdl--tools-for-processing-systemrdl">PeakRDL – Tools for processing SystemRDL</h1>
<p>That brings me to <a href="https://www-archive.fossi-foundation.org/latchup/">Latch-Up</a> – 
the excellent FOSSi Foundation conference that acts as the US version of 
<a href="https://orconf.org/">ORConf</a>. I was fortunate to be able to attend this year 
and, as always, learned a great deal about developments in the open-source 
hardware development space.</p>

<p>It was at Latch-Up that I first became aware of 
<a href="https://github.com/SystemRDL/PeakRDL">PeakRDL</a>.
PeakRDL is a collection of tools focused on the SystemRDL language.</p>

<p>In addition to tools for parsing and transforming SystemRDL descriptions
into various output formats, PeakRDL provides a 
<a href="https://code.visualstudio.com/">VSCode</a> extension that supports syntax
highlighting for SystemRDL files.</p>

<h1 id="peakrdl-pss---connecting-systemrdl-to-pss">PeakRDL-pss - Connecting SystemRDL to PSS</h1>
<p>Ever since I saw PeakRDL at Latch-Up in April, my TODO list has contained
an item dedicated to adding support for the PSS register-access layer.
Fortunately, PeakRDL has a well-defined extension mechanism that allows 
new input formats and output formats to be supported without touching the
core of the tool.</p>

<p>Last weekend, I was starting to hand-write yet another PSS register 
description when I thought “why not tackle that TODO-list item and
actually create the PSS exporter? How hard could it really be?”.</p>

<p>And, the great news is that it was really straightforward. I used
an existing extension module as a reference, and completed most
of the work in an afternoon. You can find the source 
<a href="https://github.com/mballance/PeakRDL-pss">here</a> if you’re really
interested. It’s about 300 lines of pretty simple code.</p>

<p>Our example DMA engine register, when rendered as PSS, looks like
the following. One implementation detail that the PSS export
plug-in handles is insertion of ‘reserved’ fields between 
register fields that are not contiguous.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    struct fwperiph_dma_channel_sz : packed_s&lt;&gt; {
        bit[12] tot_sz;
        bit[4] reserved;
        bit[9] chk_sz;
    }
</code></pre></div></div>

<h1 id="conclusions-and-next-steps">Conclusions and next steps</h1>
<p>Register access layers are key to making testbench and firmware
code that interacts with registers easy to understand and maintain.
Standard register-description languages allow developers to capture the
layout of registers using a easy-to-read and maintain language, then
use automation tools like PeakRDL to automate generation of the
environment-specific register access layer code.</p>

<p>In terms of next steps for PSS support in PeakRDL, the long-term goal 
is to finish documenting the extension and get is up-streamed to the 
PeakRDL organization.
Until then, you can try out the flow by installing PeakRDL, then
installing the PSS extension from the GitHub repository.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">  % pip <span class="nb">install </span>peakrdl
  % pip <span class="nb">install </span>git+https://github.com/mballance/PeakRDL-pss
  % peakrdl pss <span class="nt">-o</span> my_register_model.pss my_register_model.rdl</code></pre></figure>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Memory-mapped registers play an integral part in configuring and driving the operation of the vast majority of digital designs today. As a consequence, it’s not surprising that each language and methodology involved in the design, verification, and documentation of digital designs has its own way of interacting with registers. Fortunately, standard languages and descriptions exist that allow these language- and methodology-specific formats to be created from a single central description. This post focuses on the results of a weekend project that allows a Portable Test and Stimulus (PSS) register access layer to be created from SystemRDL input.]]></summary></entry><entry><title type="html">Relating Actions with Dataflow Part2 – Parallelism</title><link href="https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2.html" rel="alternate" type="text/html" title="Relating Actions with Dataflow Part2 – Parallelism" /><published>2023-05-07T00:00:00+00:00</published><updated>2023-05-07T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/05/07/RelatingActionsWithDataflowPart2.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/05/RelatingActionsPart2_splash.png" />
</p>

<p>A few posts back (<a href="https://bitsbytesgates.com/_posts/2023-03-18-RelatingActionsWithDataflow.html">Relating Actions with Dataflow</a>), 
we talked about using <code class="language-plaintext highlighter-rouge">buffer</code> objects to form a relationship 
between actions that execute sequentially. Because the actions 
execute sequentially, this
relationship looks a lot like function call or the transfer of a 
transaction. What is actually happening is actually a bit more 
involved and much more powerful. Let’s use the DMA engine’s 
‘peripheral interface’ as a vehicle to explore this declarative 
data exchange aspect of the PSS language.</p>

<!--more-->

<h1 id="dma-as-a-service">DMA as a Service</h1>
<p>Many high-speed devices have a built-in DMA engine to offload the
system processor from managing data transfers, and maximize 
overall system performance. For other devices, whether to use
DMA comes down to the characteristics of the system. Some systems
may need the extra throughput that DMA provides, while others
may need the area savings that using a processor to manage
data transfers brings. For this type of device, our DMA Engine’s
peripheral interface provides a compromise approach: devices
can be designed such they can optionally use the channel of
an external DMA engine. This way, whether to use DMA or not
is up to the system architect and not up to the individual
IP designer.</p>

<p>This capability of our DMA engine means that we need to test it
as a feature of the DMA IP using PSS. If we purely focus on 
this, our life is (relatively) straightforward. 
However, because we want our PSS
content to be reusable, we also need to think about how the
PSS test content we create for the DMA engine will interact
with PSS test content created for DMA-optional devices. We will
definitely want these two aspects to easily work together
when testing a system where the architect has provisioned
a device with an external DMA engine channel!</p>

<h1 id="dma-as-a-service-theory-of-operations">DMA as a Service: Theory of Operations</h1>

<p>The DMA engine that we’re working with has a fairly simple 
interface when it comes to supporting external devices.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/05/DMA_HandshakeOperation.png" />
</p>

<p>As shown in the diagram above from the DMA manual, the
peripheral interface involves two signals. The peripheral
device asserts the <em>req</em> line when it wants attention from 
the DMA channel. Once the channel associated with the 
peripheral device is prioritized, the DMA engine 
transfers a burst (1-N) of data to the destination
address and toggles the <em>ack</em> signal.</p>

<p>Over the course of transferring a block of data, a 
peripheral device and the DMA engine are likely to
interact many times.</p>

<h2 id="key-takeaways--and-pss-rules">Key takeaways – and PSS Rules</h2>

<p>Now that we understand a bit more about how the DMA engine
provides “DMA as a service”, it’s time to start organizing
what we know into a set of ‘rules’ that we can use with PSS.
As you’ve likely identified already, a fair portion of a 
PSS model involves ‘rules’ about data relationships 
(constraints), ‘rules’ about what how resources are 
allocated, etc.</p>

<p>Here’s what we know thus far:</p>
<ul>
  <li>A peripheral device and DMA channel have a 1:1 relationship.
We must ensure that the correct channel is used for a given device</li>
  <li>The DMA engine must be told about the external device’s address.</li>
  <li>The channel resource for the DMA channel to which the peripheral
device is connected must be held for the duration of the transfer.</li>
  <li>The action representing the DMA transfer activity must run in 
parallel with the action representing the peripheral device activity.</li>
</ul>

<p>Okay, so this is a bit different from operations we’ve previously
modeled with PSS. The overall data transfer operation between
memory and the device occurs at the same time as the device is
formatting that data and sending it to the world outside 
our system. This certainly means that we can’t use the 
<code class="language-plaintext highlighter-rouge">buffer</code> that we previously used to relate two actions because
the actions are not evaluated sequentially.  Fortunately, PSS 
provides a <code class="language-plaintext highlighter-rouge">stream</code> data type for specifying a data 
relationship between two actions that are run in parallel.</p>

<h2 id="data-to-agree-on">Data to Agree On</h2>

<p>Much like a <code class="language-plaintext highlighter-rouge">buffer</code> type, a <code class="language-plaintext highlighter-rouge">stream</code> type is a struct-like type that
holds user-defined fields. while a <code class="language-plaintext highlighter-rouge">buffer</code> object is used to form
a relationship between two actions that execute sequentially, a 
<code class="language-plaintext highlighter-rouge">stream</code> object is used to form a relationship between two actions
that execute in parallel.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">stream</span> <span class="nc">PeriphDmaStream</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>             <span class="n">periph_addr</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>       <span class="n">mem_h</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">xfer_sz</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>        <span class="n">xfer_cnt</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The definition above is for a PSS <code class="language-plaintext highlighter-rouge">stream</code> type that captures the
data that the peripheral device action and the DMA transfer action
must agree on. As you might note, this aligns quite nicely with the
list that we already assembled:</p>
<ul>
  <li>The two actions must agree on the DMA channel to use</li>
  <li>They must agree on the address of the peripheral device, as well
as where data is stored in memory.</li>
  <li>They must agree on how data will be transferred.</li>
</ul>

<h2 id="actions-to-match">Actions to Match</h2>

<p>Now that we’ve captured the data to be shared, let’s sketch out 
the actions that will actually participate in this two-part
transfer. Bear in mind that our goal is that another team can
implement a ‘peripheral’ action for their IP in order to make
use of our DMA controller.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">action</span> <span class="nc">Mem2Dev</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">PeriphDmaStream</span>       <span class="n">ctrl_i</span><span class="p">;</span>
        <span class="k">lock</span> <span class="n">Channel</span>                <span class="n">channel</span><span class="p">;</span>

        <span class="c1">// Acquire the requested channel</span>
        <span class="k">constraint</span> <span class="n">channel</span><span class="o">.</span><span class="n">instance_id</span> <span class="o">==</span> <span class="n">ctrl_i</span><span class="o">.</span><span class="n">channel</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="c1">// Configure the DMA channel in peripheral mode</span>
            <span class="c1">// Program parameters</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Now, here is the matching peripheral-device action:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">Uart</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// Configured during component-tree construction</span>
    <span class="kt">int</span>        <span class="n">dma_channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>    <span class="n">xmit_addr</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">SendMsgDma</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">PeriphDmaStream</span> <span class="n">ctrl_o</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">channel</span>     <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">dma_channel</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">periph_addr</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">xmit_addr</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">mem_h</span>       <span class="o">=</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">addr_h</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">constraint</span> <span class="p">{</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">xfer_cnt</span> <span class="o">==</span> <span class="n">dat_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
            <span class="n">ctrl_o</span><span class="o">.</span><span class="n">xfer_sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Remember that the DMA engine acts as an assistant in this case.
Consequently, the UART action takes in the data buffer representing
memory to be transmitted. The corresponding receive action would
produce the buffer of memory created from the received data. 
In contrast, the DMA action only accepts instructions on 
how to setup and manage the transfer.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">Uart</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// Configured during component-tree construction</span>
    <span class="kt">int</span>        <span class="n">dma_channel</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>    <span class="n">xmit_addr</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">SendMsgDma</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>
        <span class="k">output</span> <span class="n">PeriphDmaStream</span> <span class="n">ctrl_o</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kd">action</span> <span class="nc">SendMsgPio</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>           <span class="n">dat_i</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In addition to making intuitive sense, this modeling approach has
the big benefit of ensuring that the dataflow for UART actions 
is the same whether or not DMA is being used (see above).</p>

<h2 id="creating-scenarios">Creating Scenarios</h2>

<p>Let’s create a small scenario that combines the PSS model for our
DMA engine with the PSS model for our UART to create a scenario
where we use the DMA to automate the data transfer process.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">WbDma</span>              <span class="n">dma</span><span class="p">;</span>
    <span class="n">Uart</span>               <span class="n">uart</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">Scenario</span> <span class="p">{</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Dev</span>   <span class="n">uart_tx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">SendMsgDma</span> <span class="n">uart_dma_tx</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="c1">// ... Create data to transmit</span>

            <span class="c1">// Bind control I/O together</span>
            <span class="k">bind</span> <span class="n">uart_tx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_tx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="n">uart_tx_dma</span><span class="p">;</span>
                <span class="n">uart_dma_tx</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above, we bind the control input/output of the
two actions together and traverse them in parallel. Because the
two actions are connected, they will ‘agree’ on the parameters
of the DMA transfer – specifically, which channel to use,
what the source and destination addresses are, etc.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">WbDma</span>              <span class="n">dma</span><span class="p">;</span>
    <span class="n">Uart</span>               <span class="n">uart</span><span class="p">;</span>

    <span class="kd">action</span> <span class="nc">Scenario</span> <span class="p">{</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Dev</span>   <span class="n">uart_tx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">SendMsgDma</span> <span class="n">uart_dma_tx</span><span class="p">;</span>
        <span class="nn">WbDma</span><span class="p">::</span><span class="n">Dev2Mem</span>   <span class="n">uart_rx_dma</span><span class="p">;</span>
        <span class="nn">Uart</span><span class="p">::</span><span class="n">RecvMsgDma</span> <span class="n">uart_dma_rx</span><span class="p">;</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="c1">// ... Create data to transmit</span>

            <span class="k">bind</span> <span class="n">uart_tx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_tx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">bind</span> <span class="n">uart_rx_dma</span><span class="o">.</span><span class="n">ctrl_o</span> <span class="n">uart_dma_rx</span><span class="o">.</span><span class="n">ctrl_i</span><span class="p">;</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="k">parallel</span> <span class="p">{</span><span class="n">uart_tx_dma</span><span class="p">;</span> <span class="n">uart_dma_tx</span><span class="p">;</span> <span class="p">}</span>
                <span class="k">parallel</span> <span class="p">{</span><span class="n">uart_rx_dma</span><span class="p">;</span> <span class="n">uart_dma_rx</span><span class="p">;</span> <span class="p">}</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>

<p>Buffers and Streams – the PSS mechanism for relating sequential-
and parallel-executing actions act as APIs that allow actions
to interact and cooperate, despite the fact that they may have 
been created by multiple teams for different projects.</p>

<p>Using these <em>action APIs</em> also allows us to easily
scale up our test scenarios while maintaining the validity of the
test. We can build our test-specific rules on top of the rules 
that are built-in to the scenario because of the actions we include
and their relationships. Combined with the automation provided by
random generation, being able to build on top of a well-defined
set of existing scenario rules significantly boosts our 
scenario creation productivity.</p>

<p>Over the past few posts, we’ve looked at some key aspects of the
Accellera Portable Test and Stimulus (PSS) language:</p>
<ul>
  <li>How PSS helps in creating bare-metal SoC tests</li>
  <li>Key elements of the PSS language: actions, components, flow objects, and resources</li>
  <li>Creating multi-core tests with PSS</li>
  <li>Managing memory and accessing registers with PSS</li>
  <li>Modeling random scenarios using rules action relationship rules</li>
</ul>

<p>I hope this has provided a more in-depth view of the PSS language, 
its goals, and its capabilities. As you might guess, though, this intro
to PSS has really only scratched the surface in terms of PSS language
features and modeling approaches. The good news is that there are a 
plethora of open-source hardware designs out there that we can use
to explore these topics!</p>

<h1 id="references">References</h1>
<ul>
  <li>[1] Wishbone DMA Core <a href="https://opencores.org/projects/wb_dma">project page</a></li>
  <li>[2] Wishbone DMA Core <a href="https://bitsbytesgates.com/imgs/2023/03/dma_doc.pdf">manual</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[A few posts back (Relating Actions with Dataflow), we talked about using buffer objects to form a relationship between actions that execute sequentially. Because the actions execute sequentially, this relationship looks a lot like function call or the transfer of a transaction. What is actually happening is actually a bit more involved and much more powerful. Let’s use the DMA engine’s ‘peripheral interface’ as a vehicle to explore this declarative data exchange aspect of the PSS language.]]></summary></entry><entry><title type="html">Interacting with Devices via PSS Registers</title><link href="https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters.html" rel="alternate" type="text/html" title="Interacting with Devices via PSS Registers" /><published>2023-04-18T00:00:00+00:00</published><updated>2023-04-18T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/18/InteractingWithDevicesViaRegisters.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/InteractingWithDevicesViaPssRegisters_splash.png" /> 
</p>
<p>We’ve been looking at properly modeling the types of behaviors that we want
to exercise on our DMA IP for the last few posts. Of course, until we can 
actually start programming the DMA registers, all of our modeling won’t
actually <em>do</em> anything.</p>

<p>PSS provides two primary ways to connect the model of test behavior we 
want to exercise to the device on which we will exercise that behavior:</p>
<ul>
  <li>Calling functions that are implemented in the target environment</li>
  <li>Using PSS features to read/write registers and memory</li>
</ul>

<p>Both of these approaches have benefits and drawbacks. If functions
already exist to program IP registers, leveraging these from PSS
helps to get tests up and running more quickly. However, functions
are typically only implemented in a single language. Greater 
portability is achieved by directly describing the interactions
between PSS model and device registers in PSS.</p>

<p>This post will look at describing the register interface 
using the PSS register model.</p>

<!--more-->

<h1 id="registers-in-different-contexts">Registers in Different Contexts</h1>

<p>Looking across the various contexts in which registers appear, it 
quickly becomes clear that the critical capabilities are
quite different.</p>

<ul>
  <li>Within the RTL implementation of an IP, registers communicate
control values set by firmware to the implementing logic and
feed back status data from hardware to firmware. In addition,
some degree of change event may be useful (eg register written).
In other words, data storage and the structure of that data
are the key care-abouts here.</li>
  <li>In a UVM block-level verification environment, there are a
significant number of overlapping requirements. A UVM register
model captures the structure of data within registers (eg 
named fields), and layout of registers within memory. A
UVM register model enables a shadow copy of register 
contents to be maintained for debug and analysis purposes.
Since access to registers is typically via a memory-mapped
address space, the register model supports mapping between
high-level changes to register values and writes to the
addresses of those modified registers. All in all, the UVM
register model may be the most complex that we work with.</li>
  <li>At system level, we interact with the registers in our
IP blocks and subsystems using firmware. When we’re 
writing this firmware by hand, it’s typical to have a 
set of C ‘#define’ macros that help to calculate the 
address of registers, and that extract and set the value
of register fields. At this level, there’s little to 
no value in caching a copy of the last known value of
a device register.</li>
</ul>

<p>Because PSS has a system-level focus, it’s probably no surprise 
that it focuses on the key capabilities required at system
level: being able to efficiently model how registers fit into
the address space space of a device, and efficiently read and
write them. Unlike the UVM register model, the PSS register
model doesn’t maintain a copy of the data stored in registers.</p>

<h1 id="the-pss-register-model">The PSS Register Model</h1>
<p>The PSS register model focuses on capturing the field layout
of each register, the layout of device registers in the
memory map, and on providing efficient mechanisms for
reading and writing to the device registers.</p>

<p>The key elements to be aware of are:</p>
<ul>
  <li>Register group component that collects registers and sub-groups of registers together</li>
  <li>Register component that describes a single register – often in-line</li>
  <li>Register definition struct that describes the fields of a register</li>
</ul>

<p>Both the register group and register components are pre-defined components
defined by the PSS <em>Core Library</em>. While they are not built-in constructs
in the language, they are special types that tools are expected to 
implement specially.</p>

<h2 id="register-group">Register Group</h2>

<p>We define a register group to contain the top-level registers and register
groups of a device (eg our DMA engine). Or, any time we collections of 
registers that we want to use mulitple times.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/WB_DMA_TopLevel_Channel_Regs.png" />
</p>

<p>Let’s look at the first part of the DMA Engine registers (shown above). We have
some control registers that are common across all of the DMA channels. Then, 
groups of registers that are replicated for each channel.</p>

<p>We will create a register group for the full set of DMA engine registers
and a register group for the per-channel registers. The full DMA engine
register group will contain both the individual registers and an array
of the per-channel register groups.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaChannelRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="n">WbDmaChannelRegs</span>        <span class="n">channels</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<h2 id="register-definition-struct-and-component">Register Definition Struct and Component</h2>

<p>Each register is composed of some number of fields. When these fields have
special meaning, we define a <code class="language-plaintext highlighter-rouge">packed struct</code> to capture the field layout.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/WB_DMA_Channel_SZ_Reg.png" />
</p>

<p>The image above shows the layout of the <em>size</em> register within the block
of per-channel registers. We declare the struct below to capture the 
layout of the fields in the register. Note that the start of the first 
field in the struct corresponds to the lowest bit in the register.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">struct</span> <span class="nc">WbDmaChannelSz</span> <span class="p">:</span> <span class="n">packed_s</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>           <span class="n">TOT_SZ</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>            <span class="n">RESERVED_1</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>            <span class="n">CHK_SZ</span><span class="p">;</span>
    <span class="kt">bit</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>            <span class="n">RESERVED_2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The struct shown above just defines the layout of data within a
register.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaChannelRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaChannelCSR</span><span class="o">&gt;</span>         <span class="n">CSR</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaChannelSZ</span><span class="o">&gt;</span>          <span class="n">SZ</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SrcAddr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SrcAddrMask</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">DstAddr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">DstAddrMask</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">LinkListPtr</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>                 <span class="n">SwPtr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>When declaring a register within a register group, we add a field
of type <code class="language-plaintext highlighter-rouge">reg_c</code> that is parameterized with the data type 
that describes the register. This core data type could be a packed
struct as is shown above. It could also be an integer in cases where
giving names to all the fields isn’t so important.</p>

<p>For example, we use packed structs to define the layout of the CSR
and SZ fields. Address and address-mask fields are defined using
plain integer data types.</p>

<p>From this point on, we simply build up. We define a register struct
for any register whose field layout we care about. We add a 
type-parameterized <code class="language-plaintext highlighter-rouge">reg_c</code> field for each register to its containing
register group, and fields of <code class="language-plaintext highlighter-rouge">reg_group_c</code> type for instances
of register groups.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">WbDmaRegs</span> <span class="p">:</span> <span class="n">reg_group_c</span> <span class="p">{</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="n">WbDmaCSR</span><span class="o">&gt;</span>         <span class="n">CSR</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_MSK_A</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_MSK_B</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_SRC_A</span><span class="p">;</span>
    <span class="n">reg_c</span><span class="o">&lt;</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">&gt;</span>          <span class="n">INT_SRC_B</span><span class="p">;</span>

    <span class="n">WbDmaChannelRegs</span>        <span class="n">channels</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>For the DMA engine, this process results in a top-level register block
for the IP such as the one shown above. In this case, we have a few
individual registers and an array of channel register groups.</p>

<h1 id="the-pss-register-model-in-the-real-world">The PSS Register Model in the Real World</h1>

<p>In the prior sections, we manually created a PSS register model.
In practice this is quite rare because, in a production environment,<br />
all of the various register descriptions 
(RTL, UVM, firmware, documentation, etc)
are derived automatically from a single description. That 
central description might be captured in a spreadsheet or
CSV file, IP-XACT document [3], or a SystemRDL description [1].</p>

<p>Personally, I’m very interested in SystemRDL. My feeling is that
it’s easier to create and modify than IP-XACT, and I just learned
about an open source toolchain named 
<a href="https://github.com/orgs/SystemRDL">PeakRDL</a> that can be used to 
derive various outputs from it.</p>

<p>As you begin to look at applying PSS in your environment, it’s
a good idea to understand what single representation your
organization uses for register information, and what 
facilities exist for adding new automatically-derived
output formats.</p>

<h1 id="instantiating-and-connecting-the-register-model">Instantiating and Connecting the Register Model</h1>

<p>Our PSS register model is simply a mechanism for associating
the addresses and bit patterns of memory-mapped registers
with symbolic representations. Consequently, we need to 
connect our register model to an address space before we
can actually use it for reading and writing registers.</p>

<h2 id="connecting-to-register-space">Connecting to Register Space</h2>
<p>Registers are always mapped at some location within the 
address space. In order to determine the correct address
to use when accessing a register, we need to know where
its containing register model is located in memory.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x8000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The code above shows defining a region within the memory
map that is defined as non-allocatable. In other words,
we cannot use <code class="language-plaintext highlighter-rouge">addr_claim_s</code> fields within actions to
claim memory from this region. Note that 
<code class="language-plaintext highlighter-rouge">add_nonallocatable_region</code> returns an address handle that we save.
We will use this handle to specify where the register block 
is located.</p>

<h2 id="connecting">Connecting</h2>
<p>In this little example, the register model that we’re focusing on
is the one and only register model. This is not the case most 
of the time. It’s much more frequently the case that the register
model for our IP is just one part of much larger system-level
register model.</p>

<p>Generally speaking, PSS provides two different strategies for
associating a component with the register model it should use,
and associating the register model with the base address it 
must use:</p>
<ul>
  <li>We can create a large register model that has a base address
and distribute references to register sub-models to components</li>
  <li>We can create a register model per consumer component and 
calculate a base address to associate with each.</li>
</ul>

<h3 id="large-register-model--distribute-refs">Large Register Model ; Distribute Refs</h3>

<p>In this scheme, our DMA component has a reference to the 
register model, not an instance:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>

    <span class="c1">// Handle to the register model</span>
    <span class="kd">ref</span> <span class="n">WbDmaRegs</span>           <span class="n">regs</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>The code that uses the register model doesn’t care whether it is
using a reference or an instance of a register model. Either way,
registers get written and read.</p>

<p>The register for all instances of our DMA engine are included in
the top-level register model, as shown below.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">pure</span> <span class="kd">component</span> <span class="nc">SysRegModel</span> <span class="p">:</span> <span class="n">reg_group_c</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">WbDmaRegs</span>           <span class="n">dma0</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, our system-level register model is instanced at the top
level of the component tree.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>

    <span class="n">SysRegModel</span>                              <span class="n">regs</span><span class="p">;</span>

    <span class="n">WbDma</span>                                    <span class="n">dma0</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="c1">// ...</span>
        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">regs</span><span class="o">.</span><span class="n">set_handle</span><span class="p">(</span><span class="n">mmio_h</span><span class="p">);</span>

        <span class="n">dma</span><span class="o">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">dma0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>A few things are going on here:</p>
<ul>
  <li>After obtaining a handle to the root of the memory-mapped I/O
space, we configure this as the base address of the system
register map by calling the <code class="language-plaintext highlighter-rouge">set_handle</code> function on the system
register model.</li>
  <li>Next, we hook set the register-model reference field in the 
dma0 component instance to point to its instance of the 
register in the system register model.</li>
</ul>

<p>And, with that we’re done. The advantages of this approach are that
we’re only concerned with the base address of the full register
space and it might be easier to construct this ‘super’ register
model using automation tools. We also have the option to directly
reach down through the register model to access registers. 
The biggest downside is a loss of some degree of modularity.</p>

<h3 id="individual-register-models--distribute-base-addresses">Individual Register Models ; Distribute Base Addresses</h3>

<p>This approach is nearly mirror image of the previous approach. 
In this approach, each component with registers “owns” its 
register block and we distribute base-address handles.</p>

<p>So, here’s the DMA component:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>

    <span class="c1">// DMA register model</span>
    <span class="n">WbDmaRegs</span>           <span class="n">regs</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Note that we have full register model instance here, instead of
just a reference.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="n">addr_handle_t</span>                            <span class="n">mmio_h</span><span class="p">;</span>

    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>          <span class="n">region</span><span class="p">;</span>

        <span class="c1">// ...</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">mmio_h</span> <span class="o">=</span> <span class="n">aspace</span><span class="o">.</span><span class="n">add_nonallocatable_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">dma</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">set_handle</span><span class="p">(</span><span class="n">make_handle_from_handle</span><span class="p">(</span><span class="n">mmio_h</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>At the top level, things are a bit different as well. There is not
unified top-level register model. Instead of setting the DMA 
register-model handle within the DMA component, we set the base address
handle on the register-model instance within the DMA component. Note
that we need to compute the proper offset to create the correct address
handle for the DMA registers.</p>

<h1 id="using-the-register-model">Using the Register Model</h1>
<p>Now that we have our register model integrated and connected, we can
write PSS test realization code to program a DMA channel to perform
a transfer.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
        <span class="c1">// Setup the transfer size</span>
        <span class="n">WbDmaChannelSZ</span> <span class="n">sz</span><span class="p">;</span>
        <span class="n">sz</span><span class="o">.</span><span class="n">CHK_SZ</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">sz</span><span class="o">.</span><span class="n">TOT_SZ</span> <span class="o">=</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// We always work in words</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">SZ</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>

        <span class="c1">// Configure source and destination addresses</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">INT_SRC_A</span><span class="o">.</span><span class="n">write_val</span><span class="p">(</span><span class="n">addr_value</span><span class="p">(</span><span class="n">src_i</span><span class="o">.</span><span class="n">addr_h</span><span class="p">));</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">INT_DST_A</span><span class="o">.</span><span class="n">write_val</span><span class="p">(</span><span class="n">addr_value</span><span class="p">(</span><span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span><span class="p">));</span>

        <span class="c1">// Enable the channel</span>
        <span class="n">WbDmaChannelCSR</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">CH_EN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>

        <span class="c1">// Wait for the transfer to complete</span>
        <span class="k">repeat</span> <span class="p">{</span>
            <span class="n">csr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">.</span><span class="n">CSR</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
            <span class="c1">// ...</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">DONE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>First, we’ll want to configure a couple of details about the 
size of the transfer. For this, we use the WbDmaChannelSZ packed struct to 
properly format data to write to the register.</p>

<p>Next, we’ll setup the source and destination addresses. For these, we will
use the <code class="language-plaintext highlighter-rouge">write_val</code> function to just write the address value to the register.</p>

<p>We need to enable the channel before the transfer will start. To do this, 
we want to modify a bit within the configuration and status register while
leaving the other fields as-is. To do this, we can read the value of the
CSR into a register struct, set the <code class="language-plaintext highlighter-rouge">CH_EN</code> bit, then write it back 
to the register.</p>

<p>At this point, the DMA engine will begin transferring memory. Finally, we
need to wait until the channel’s <code class="language-plaintext highlighter-rouge">DONE</code> bit is set. This signals that the
transfer is complete. Here, again, we use the register struct to make it
easy to extract the bits that we care about.</p>

<p>This code is concise and easy to write – generally much more so than
the equivalent hand-coded bare-metal C code. The great thing, of course,
is that the resulting implementation is just as efficient as if it 
were hand-coded in C.</p>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>

<p>We have now worked through all the key topics in exercising the 
memory to memory copy functionality of our DMA engine. We’ve looked
at:</p>
<ul>
  <li>Buffers to represent data transfer between sequential actions</li>
  <li>Memory management to remove complexity from our tests</li>
  <li>Resource management to ensure concurrent test behavior doesn’t
collide over resource usage like DMA channels</li>
  <li>And finally, using the PSS register model to capture the layout
of registers and register blocks, and access device registers.</li>
</ul>

<p>But, if you remember, there is one other key part of the DMA
engine’s functionality: supporting DMA transfer for peripheral
devices without their own internal DMA engines. Modeling this
type of behavior brings unique challenges. Especially so when 
we want to be able to exercise that behavior with multiple different 
devices at the system. In the next post, we’ll look at approaches
for modeling this with PSS.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://www.accellera.org/images/downloads/standards/systemrdl/SystemRDL_2.0_Jan2018.pdf">SystemRDL 2.0 LRM</a></li>
  <li>[2] <a href="https://github.com/orgs/SystemRDL">PeakRDL</a></li>
  <li>[3] <a href="https://www.accellera.org/downloads/standards/ip-xact">IP-XACT</a></li>
  <li>[4] <a href="https://bitsbytesgates.com/code_html/2023/04/wb_dma_4_registers.html">DMA Example (Viewing)</a></li>
  <li>[5] <a href="https://bitsbytesgates.com/code/2023/04/wb_dma_4_registers.pss">DMA Example (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[We’ve been looking at properly modeling the types of behaviors that we want to exercise on our DMA IP for the last few posts. Of course, until we can actually start programming the DMA registers, all of our modeling won’t actually do anything. PSS provides two primary ways to connect the model of test behavior we want to exercise to the device on which we will exercise that behavior: Calling functions that are implemented in the target environment Using PSS features to read/write registers and memory Both of these approaches have benefits and drawbacks. If functions already exist to program IP registers, leveraging these from PSS helps to get tests up and running more quickly. However, functions are typically only implemented in a single language. Greater portability is achieved by directly describing the interactions between PSS model and device registers in PSS. This post will look at describing the register interface using the PSS register model.]]></summary></entry><entry><title type="html">PSS Concurrency and Resources</title><link href="https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources.html" rel="alternate" type="text/html" title="PSS Concurrency and Resources" /><published>2023-04-09T00:00:00+00:00</published><updated>2023-04-09T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/09/PSSConcurrencyAndResources.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/DMAModelingResourcesWithPSS_splash.png" /> 
</p>

<p>Resource contention is a challenge that arises any time concurrency and 
shared resources (data, hardware accelerators, etc) are involved. It’s one
of the big challenges, and source of bugs, in implementing code that takes
advantage of parallelism. 
When it comes to hardware resources, safe access to shared resources is 
generally managed in production by the operating system. There are two big 
reasons that using this same approach for bare-metal tests isn’t a good solution:</p>
<ul>
  <li>First, and most obvious, is that our bare-metal tests don’t have an
operating system to use in managing access to shared devices</li>
  <li>Second, and more interesting, is that our tests are constraint 
guided and seek to exercise as many unique corner cases as possible.
In contrast, the OS can focus simply on providing correct results, and
doesn’t need t be as concerned with being able to produce interesting
and unique corner cases.</li>
</ul>

<p>The good news, as you might guess, is that PSS provides constructs for modeling
available resources and how actions can make use of them without 
conflicts – whether the actions are executing sequentially or 
concurrently. Let’s dig in and learn more.</p>

<!--more-->

<h1 id="resources-and-the-dma-example">Resources and the DMA Example</h1>
<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/03/DMA_block_diagram.png" />
</p>

<p>In the DMA example, the most obvious features that must be managed
as a resource are the channels. Channels can execute memory
transfers in parallel – an important usecase for the IP. Eventually,
the OS driver for the DMA will manage satisfying requests for a 
DMA channel. But, for now, our test will need to manage allocating
channels itself.</p>

<h1 id="pss-resource-management-in-three-parts">PSS Resource Management in Three Parts</h1>

<p>There are three key parts to managing resources in PSS.</p>
<ul>
  <li>A data type to encapsulate data related to the resource kind</li>
  <li>A pool of a given resource kind that specifies the number of
available resources</li>
  <li>A resource claim on an action to acquire a resource with 
specific characteristics</li>
</ul>

<h2 id="resource-type">Resource Type</h2>

<p>A <em>resource</em> data type is declared using the <code class="language-plaintext highlighter-rouge">resource</code> keyword.
A resource type is very similar to a struct, in that it can
contain random and non-random data fields and constraints.</p>

<p>A <em>resource</em> data type has one built-in field named
<code class="language-plaintext highlighter-rouge">instance_id</code>. The <code class="language-plaintext highlighter-rouge">instance_id</code> field is a simple but effective
way to uniquely identify a resource instance.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">MemBuf</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span>        <span class="n">size</span><span class="p">;</span> <span class="c1">// Size of the data</span>
    <span class="n">addr_handle_t</span>       <span class="n">addr_h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">resource</span> <span class="nc">Channel</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In the case of the DMA engine, the key thing we need to know is
to which DMA channel an action is assigned. Consequently, our
resource type <code class="language-plaintext highlighter-rouge">Channel</code> doesn’t contain any custom fields.</p>

<h2 id="resource-pool">Resource Pool</h2>

<p>In prior posts, we’ve hand-waved a bit about where <code class="language-plaintext highlighter-rouge">buffer</code> pools
are placed, and how they are statically bound to actions.
Now that we have resources, we need to be a bit more mindful of 
pools, where they are placed, and how actions are bound to them.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="k">pool</span> <span class="n">MemBuf</span>     <span class="n">mem_buf_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">mem_buf_p</span>  <span class="o">*</span><span class="p">;</span>

    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>    <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>The bind directive connects a pool to a set of actions that 
reference that <code class="language-plaintext highlighter-rouge">flow-object</code> type. In our case, we have 
placed the resource pool inside the <code class="language-plaintext highlighter-rouge">WbDma</code> component and
bound it to all actions that claim a <code class="language-plaintext highlighter-rouge">Channel</code> resource because
channels are a property of a specific DMA engine instance. Actions
running on that instance of a DMA engine IP have access to the
available channels. Actions running on a different instance have
access to a different set of channels.</p>

<p>Note that a <code class="language-plaintext highlighter-rouge">resource</code> pool always has a size, unlike<br />
<code class="language-plaintext highlighter-rouge">buffer</code> pools that are unsized. The specified size
states exactly how many resources exist in the pool.</p>

<p>As in previous posts, our <code class="language-plaintext highlighter-rouge">WbDma</code> component is instantiated inside the
top component in the componet tree, <code class="language-plaintext highlighter-rouge">pss_top</code>.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s say we add another instance of the DMA engine:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma_1</span><span class="p">;</span>
    <span class="n">WbDma</span>                                    <span class="n">dma_2</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Everything will work as we expect with the <code class="language-plaintext highlighter-rouge">resource</code> pool 
local to each DMA component, and resource claims on actions 
within the DMA Component bound to that local pool. When an
action runs on the <code class="language-plaintext highlighter-rouge">dma_1</code> instance, it will contend with
other actions running on that component for the
available 16 channels. Likewise, for an action running 
on the <code class="language-plaintext highlighter-rouge">dma_2</code> instance.</p>

<p>What would be different if we moved the resource pool up
a level?</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>               <span class="n">aspace</span><span class="p">;</span>
    <span class="k">pool</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">Channel</span>                        <span class="n">channels_p</span><span class="p">;</span>
    <span class="k">bind</span> <span class="n">channels_p</span> <span class="o">*</span><span class="p">;</span>
    
    <span class="n">WbDma</span>                                    <span class="n">dma_1</span><span class="p">;</span>
    <span class="n">WbDma</span>                                    <span class="n">dma_2</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Now, all actions that run on either <code class="language-plaintext highlighter-rouge">dma_1</code> or <code class="language-plaintext highlighter-rouge">dma_2</code>
contend for the same set of shared channel resources 
because all actions are bound to the same resource pool.</p>

<p>Doing things this way doesn’t make sense for our DMA 
example, but certainly makes sense in other cases. For example,
consider a case where we have a family of algorithm 
accelerators - each with their own distinct actions - that all need to use
some shared resource such as a shared DMA engine. In that 
case, having all actions share the same resource pool would 
make sense.</p>

<h2 id="resource-claim">Resource Claim</h2>

<p>Finally, we reach the point where we can have our DMA actions
claim a resource. Actions claim resources using a special 
<code class="language-plaintext highlighter-rouge">lock</code> or <code class="language-plaintext highlighter-rouge">share</code> field within the action. Much like the 
<code class="language-plaintext highlighter-rouge">input</code> and <code class="language-plaintext highlighter-rouge">output</code> fields used with buffers, declaring
a resource lock or share field causes the PSS tool to make
the field point to a resource that matches any criteria
the user has specified for the resource.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
    <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
    <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
    <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>
    <span class="k">lock</span> <span class="n">Channel</span>            <span class="n">channel</span><span class="p">;</span>

    <span class="c1">// Input and output size must be the same</span>
    <span class="k">constraint</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">src_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In the case above, the only criteria the action places on the
resource is that it needs to have exclusive (lock) access to
it. No other action can use the channel at the same time.</p>

<p>It’s also possible to use constraints to add more criteria
on selection of a resource. Take the example test below:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">extend</span> <span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">TestParallelXfer</span> <span class="p">{</span>

        <span class="k">activity</span> <span class="p">{</span>
            <span class="k">parallel</span> <span class="p">{</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">do</span> <span class="nn">WbDma</span><span class="p">::</span><span class="n">Mem2Mem</span> <span class="k">with</span> <span class="n">instance_id</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In this case, we are very specific about which channels two of 
the three transfers should run on. Perhaps that is because we 
want to exercise some aspect of the arbitration scheme. 
For the third parallel transfer, we request a channel less than 8. 
The PSS tool will randomly select an appropriate channel, while not 
selecting channels 0 or 1.</p>

<h1 id="locking-vs-sharing-a-resource">Locking vs Sharing a Resource</h1>
<p>In the case of the DMA example, acquiring exclusive access to a DMA channel
(locking it) is the appropriate choice. In fact, locking resources is 
probably the most common use case. However, there are certainly valid
cases where we need to allow multiple actions to access the same resource.</p>

<p>The most straightforward case for shared access to a resource is when a
resource provides some useful information that can be read by multiple
actions. In this case, actions that wish to read the information should
acquire the resource as a <code class="language-plaintext highlighter-rouge">share(d)</code> resource. Actions wishing to write
the information should acquire the resource as a <code class="language-plaintext highlighter-rouge">lock(ed)</code> resource. 
Doing this will enable multiple actions to read information from the
resource-protected element, while ensuring that no action is 
simultaneously trying to change the stored information.</p>

<h1 id="conclusion-and-next-steps">Conclusion and Next Steps</h1>
<p>In this post, we’ve seen how PSS enables the definition of resources
that can only be used in certain ways by certain actions over time, 
and have seen how PSS resources can be applied to describe restrictions
on how DMA channels can be used over time by concurrent behavior.</p>

<p>In the next post, we’ll look at using PSS <code class="language-plaintext highlighter-rouge">registers</code> to connect the 
actions in our PSS model to the registers within the DMA engine.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://bitsbytesgates.com/code_html/2023/03/wb_dma_3.html">DMA PSS Code (Viewing)</a></li>
  <li>[2] <a href="https://bitsbytesgates.com/code/2023/03/wb_dma_3.pss">DMA PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Resource contention is a challenge that arises any time concurrency and shared resources (data, hardware accelerators, etc) are involved. It’s one of the big challenges, and source of bugs, in implementing code that takes advantage of parallelism. When it comes to hardware resources, safe access to shared resources is generally managed in production by the operating system. There are two big reasons that using this same approach for bare-metal tests isn’t a good solution: First, and most obvious, is that our bare-metal tests don’t have an operating system to use in managing access to shared devices Second, and more interesting, is that our tests are constraint guided and seek to exercise as many unique corner cases as possible. In contrast, the OS can focus simply on providing correct results, and doesn’t need t be as concerned with being able to produce interesting and unique corner cases. The good news, as you might guess, is that PSS provides constructs for modeling available resources and how actions can make use of them without conflicts – whether the actions are executing sequentially or concurrently. Let’s dig in and learn more.]]></summary></entry><entry><title type="html">PSS Memory Management Fundamentals</title><link href="https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS.html" rel="alternate" type="text/html" title="PSS Memory Management Fundamentals" /><published>2023-04-02T00:00:00+00:00</published><updated>2023-04-02T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2023/04/02/ManagingMemoryInPSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2023/04/MemoryManagement_splash.png" /> 
</p>

<p>Storage (memory) is right in the middle of all the work with do with
computer architecture. We have different kinds of memory that each have different
trade-offs around performance (latency / throughput), cost per unit,
and power consumption. We arrange memories into hierarchies with 
the goal of keeping frequently-used data in the upper 
(faster, but limited) layers, while pushing infrequently-accessed data 
to the lower (slower, but more expansive) layers.</p>

<p>Given the large amount of time time designers spend thinking about 
memory needs, it’s no surprise that creating good and capable tests 
to exercise those designs depends on being able to acquire the right 
type of memory at the right time in order to fully-exercise the 
capabilities and characteristics of the system.</p>

<!--more-->

<p>Remember, though, that we’re writing bare-metal tests. Consequently, we need 
to allocate memory for our test behaviors ahead of time in order to not waste valuable
simulation or emulation time running the ‘malloc’ and ‘free’ algorithm. 
When done by hand, static allocation can limit how reusable code is and
remove the majority of variability (ie randomness) from test scenarios. Fortunately, 
PSS provides some easy to use features that allow actions to manage memory that 
they require in a way that enables static allocation while not limiting 
variability or reuse. Let’s dig in!</p>

<h1 id="test-requirements-for-memory-management">Test Requirements for Memory Management</h1>
<p>System-level tests have three core requirements when it comes to 
memory management:</p>
<ul>
  <li>Ensure that behaviors needing distinct blocks of memory are provided non-overlapping
blocks of memory</li>
  <li>Ensure behaviors that need to share data see the same memory</li>
  <li>Ensure that a test is able to explicitly specify the general
location in memory (eg SRAM, DDR, etc) where a memory block
comes from.</li>
</ul>

<p>One of the biggest challenges with hand-written bare-metal
tests is implementing these three characteristics in a distributed
and modular way.</p>

<p>There are two parts of the PSS memory management approach:</p>
<ul>
  <li>Specification of available memory resource</li>
  <li>Specification of claims on those resources, and how the claimed data is used.</li>
</ul>

<h1 id="using-memory-in-behaviors">Using Memory in Behaviors</h1>
<p>Let’s start with the second point – how we claim memory – since we can see 
immediately how that fits into our DMA example.</p>

<p>In PSS, an action claims memory by having one or more random fields of type
<em>addr_claim_s</em>. The action can control how much memory is being requested,
and its alignment, by constraining the fields of the claim.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">buffer</span> <span class="nc">MemBuf</span> <span class="p">{</span>
    <span class="kd">rand</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span>    <span class="n">size</span><span class="p">;</span> <span class="c1">// Size of the data</span>
    <span class="n">addr_handle_t</span>   <span class="n">addr_h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// Input and output size must be the same</span>
        <span class="k">constraint</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">src_i</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>

        <span class="c1">// DMA only transfers words</span>
        <span class="k">constraint</span> <span class="p">(</span><span class="n">dst_o</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> 

        <span class="c1">// Specify size/alignment for allocation</span>
        <span class="k">constraint</span> <span class="n">dst_claim</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">dst_o</span><span class="o">.</span><span class="n">size</span><span class="p">;</span>
        <span class="k">constraint</span> <span class="n">dst_claim</span><span class="o">.</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span> <span class="o">=</span> <span class="n">make_handle_from_claim</span><span class="p">(</span><span class="n">dst_claim</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Okay, we’ve added a few things to the skeleton Mem2Mem action that
we created in the last post:</p>
<ul>
  <li>Added a <code class="language-plaintext highlighter-rouge">size</code> field to <code class="language-plaintext highlighter-rouge">MemBuf</code> to ensure that producers and consumers
of this type agree on the data size.</li>
  <li>Added an ‘addr_h’ field to <code class="language-plaintext highlighter-rouge">MemBuf</code> that will hold a handle to the allocated
memory block.</li>
  <li>Add a claim field (<code class="language-plaintext highlighter-rouge">dst_claim</code>) to the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action that will cause 
memory to be allocated for the DMA destination memory</li>
  <li>Add constraints to:
    <ul>
      <li>Relate the source and destination buffer objects.</li>
      <li>Relate the source and destination buffer objects.</li>
    </ul>
  </li>
</ul>

<p>One new thing is that we assign the address handle to a field in the output 
buffer within the <code class="language-plaintext highlighter-rouge">post_solve</code> exec block inside the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action. 
This is done in order to make the address available to the consumer of the 
buffer. Why does this work? 
PSS specifies that two actions that are connected by a buffer object 
both have a handle to exactly the same object. That means that when the 
outputting action assigns a value to a field, it is assigning to the 
exact field that the inputting action will read.</p>

<h2 id="specifying-memory-claim-lifetimes">Specifying Memory Claim Lifetimes</h2>

<p>By default, the lifetime of a memory claim is the same as the action containing
it.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the context of our example, that means that <code class="language-plaintext highlighter-rouge">dst_claim</code> would be released
as soon as the DMA transfer completes. Clearly, that’s not what we want since we
are claiming <code class="language-plaintext highlighter-rouge">dst_claim</code> in order to provide data to another action.</p>

<p>The solution is to <em>extend</em> the lifetime of the memory claim by attaching 
it to something with a longer lifetime. In this case, that thing with a 
longer lifetime is, very naturally, the output buffer, since we intend the 
lifetime of the buffer and the lifetime of our memory claim to match.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="kd">component</span> <span class="nc">WbDma</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Mem2Mem</span> <span class="p">{</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">src_i</span><span class="p">;</span>
        <span class="k">input</span> <span class="n">MemBuf</span>            <span class="n">dst_o</span><span class="p">;</span>
        <span class="kd">rand</span> <span class="n">addr_claim_s</span><span class="o">&lt;&gt;</span>     <span class="n">dst_claim</span><span class="p">;</span>

        <span class="c1">// ...</span>

        <span class="k">exec</span> <span class="k">post_solve</span> <span class="p">{</span>
            <span class="n">dst_o</span><span class="o">.</span><span class="n">addr_h</span> <span class="o">=</span> <span class="n">make_handle_from_claim</span><span class="p">(</span><span class="n">dst_claim</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// ...</span>
        
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now, when the memory we’ve claimed is passed to another action via a buffer,
the memory claim lives at least until the receiving action is complete.</p>

<div class="mermaid" align="center">
flowchart TD;
  mem_b_1 -.-&gt; mem2mem_1
  mem2mem_1 -.-&gt; mem_b_2
  mem_b_2 -.-&gt; mem2mem_2
  mem2mem_2 -.-&gt; mem_b_3
  subgraph Execution
    mem2mem_1("Mem2Mem[1]") --&gt; mem2mem_2("Mem2Mem[2]")
  end
  subgraph Dataflow
    mem_b_1(["MemBuf\nsize: 64\naddr_h=0x80000000"])
    mem_b_2(["MemBuf\nsize: 64\naddr_h=0x80001000"])
    mem_b_3(["MemBuf\nsize: 64\naddr_h=0x80002000"])
  end
</div>

<h1 id="describing-memory-resources">Describing Memory Resources</h1>
<p>In addition to claiming memory, we also need to capture the memory available
to us in the system. This is done by defining an address space with one or
more memory regions, from which memory will be allocated.</p>

<p>Address spaces are instanced in the component tree. Recall from the post about
actions and components that each action execution occurs in the context of
a component instance.</p>

<p>The address space used by a given claim is located by searching hierarchically
up the component tree from the action’s context component instance until an 
address space with the same <code class="language-plaintext highlighter-rouge">trait</code> type as the claim is found.</p>

<p>This resolution scheme means that we need to exercise care in where we place
our address space. Memory is most commonly a system property. 
If we instance our DMA Engine in two different systems, we could reasonably
expect the available memory to be different. The amount of memory is likely
to be different, as are the base addresses of key memory regions.</p>

<div class="mermaid" align="center">
flowchart TD
  subgraph PssTop["pss_top"]
    aspace[["aspace : transparen_address_space_c&lt;&gt;"]]
    mem2mem-. claim .-&gt;aspace
    subgraph WbDma["dma : WbDma"]
      mem2mem["Mem2Mem"]
    end
  end
</div>

<h2 id="capturing-available-memory">Capturing Available Memory</h2>
<p>In our simple example, we will capture the address space for our DMA
engine to use in <code class="language-plaintext highlighter-rouge">pss_top</code>.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="c1">// ...</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="n">transparent_addr_space_c</span><span class="o">&lt;&gt;</span>           <span class="n">aspace</span><span class="p">;</span>

    <span class="n">WbDma</span>                                <span class="n">dma</span><span class="p">;</span>

    <span class="k">exec</span> <span class="k">init_down</span> <span class="p">{</span>
        <span class="n">transparent_addr_region_s</span><span class="o">&lt;&gt;</span>      <span class="n">region</span><span class="p">;</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x8000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

        <span class="n">region</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0000_0000</span><span class="p">;</span>
        <span class="n">region</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000_0000</span><span class="p">;</span>
        <span class="n">aspace</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The available memory regions within the address space are specified in the 
<code class="language-plaintext highlighter-rouge">init_down</code> exec block. Here, we register two regions of memory – one at
0x8000_0000 and one at 0x0000_0000.</p>

<h1 id="putting-it-all-together">Putting it all together</h1>
<p>We’ve completed the basic updates to our PSS model that enable our DMA actions
to sensibly management memory.</p>
<ul>
  <li>We have added a memory claim to the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action to claim memory
for the destination buffer.</li>
  <li>We have added a handle to the the <code class="language-plaintext highlighter-rouge">MemBuf</code> buffer type that enables
us to properly manage the lifetime of that claimed memory.</li>
  <li>We have specified an address space with available regions of memory for 
the <code class="language-plaintext highlighter-rouge">Mem2Mem</code> action to use.</li>
</ul>

<p>At this point, the Mem2Mem action will randomly allocate memory regions from 
the two registered regions. For now, this is likely just fine. In the future,
we will need to take finer-grain control over where our memory claims are 
satisfied. Fortunately, PSS provides features to support that requirement
as well.</p>

<p>In this post, we’ve seen the steps necessarily to make use of the core 
memory-management features that PSS provides. Now that we know how to
manage memory as a test-scenario resource, we can turn our attention to
managing another type of resource: the DMA channels within the engine.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li>[1] <a href="https://www.accellera.org/downloads/standards/portable-stimulus">PSS LRM</a></li>
  <li>[2] <a href="https://bitsbytesgates.com/code_html/2023/03/wb_dma_2.html">DMA PSS Code (Viewing)</a></li>
  <li>[3] <a href="https://bitsbytesgates.com/code/2023/03/wb_dma_2.pss">DMA PSS Code (Raw Text)</a></li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[Storage (memory) is right in the middle of all the work with do with computer architecture. We have different kinds of memory that each have different trade-offs around performance (latency / throughput), cost per unit, and power consumption. We arrange memories into hierarchies with the goal of keeping frequently-used data in the upper (faster, but limited) layers, while pushing infrequently-accessed data to the lower (slower, but more expansive) layers. Given the large amount of time time designers spend thinking about memory needs, it’s no surprise that creating good and capable tests to exercise those designs depends on being able to acquire the right type of memory at the right time in order to fully-exercise the capabilities and characteristics of the system.]]></summary></entry></feed>