<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://bitsbytesgates.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bitsbytesgates.com/" rel="alternate" type="text/html" /><updated>2025-11-03T15:48:18+00:00</updated><id>https://bitsbytesgates.com/feed.xml</id><title type="html">Bits, Bytes, and Gates</title><subtitle>There&apos;s oh so much fun to be had. At the leading edge,  at the bleeding edge, at the confluence of bits, bytes, and gates.</subtitle><entry><title type="html">The Mechanics of UVM/Python Cross-Calling</title><link href="https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics.html" rel="alternate" type="text/html" title="The Mechanics of UVM/Python Cross-Calling" /><published>2025-11-01T00:00:00+00:00</published><updated>2025-11-01T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/11/01/UvmWithPython__CrossCallingMechanics.html"><![CDATA[<p>It’s not necessary to understand very much about how PyHDL-IF implements
the bridge between Python and UVM, but useful to understand a bit. Doing 
so helps to understand what this library is and is not intended to do,
and how you can best use it in your verification environment.</p>

<!--more-->

<h1 id="an-interface-not-a-uvm-library">An Interface, not a UVM Library</h1>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/11/pyhdl_if_uvm_wrapper.png" />
</p>

<p>One important thing to understand is that PyHDL-IF is an interface library,
and not a full testbench library. PyHDL-IF is intended to make it easy to 
Python to SystemVerilog and UVM, and vice versa. Consequently, it is only
useful if a SystemVerilog/UVM testbench is a part of your verification environment.
If you want to create a UVM testbench in Python, the <a href="https://github.com/pyuvm/pyuvm">pyuvm</a>
library is more likely to be what you’re looking for. You can even use 
<code class="language-plaintext highlighter-rouge">pyuvm</code> with PyHDL-IF to provide structure to the Python portion of the testbench
that leverages your existing UVM-SV testbench.</p>

<p>Limiting the scope in this way has its advantages, though. While the UVM library
is quite large, the APIs that test writers and scoreboard developers use is 
a much smaller subset. Prioritizing this much-smaller subset very quickly 
provides an interface library that covers a large percentage of usecases.</p>

<h1 id="initiating-behavior-from-uvm">Initiating Behavior from UVM</h1>

<p>One implication of PyHDL-IF being an interface library is that all 
PyHDL-IF UVM objects are wrappers to access SystemVerilog UVM objects. 
While it is possible (and common!) to create instances of UVM objects
from Python, what happens under the hood as the following:</p>
<ul>
  <li>Python (via the PyHDL-IF library) calls a UVM method, creating a new UVM object</li>
  <li>The PyHDL-IF library creates a SystemVerilog and Python object pair with a handle to the UVM object</li>
  <li>This ‘wrapper’ Python object is returned to the caller.</li>
</ul>

<p>So, how do we initiate Python behavior from a UVM testbench? There are 
two special PyHDL-IF “proxy” classes that provide a Python implementation
for <code class="language-plaintext highlighter-rouge">uvm_component</code> and <code class="language-plaintext highlighter-rouge">uvm_sequence</code>: <code class="language-plaintext highlighter-rouge">pyhdl_uvm_component_proxy</code> and <code class="language-plaintext highlighter-rouge">pyhdl_uvm_sequence_proxy</code>.</p>

<h1 id="interface-structure">Interface Structure</h1>

<p>The PyHDL-IF library provides infrastructure that connects a Python object and 
a SystemVerilog object via method calls. Specially-decorated classes define
the shared API. For example, the code snippet below defines the API of the 
UvmSequenceProxy:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@api</span>
<span class="k">class</span> <span class="nc">UvmSequenceProxy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@exp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">get_userdata</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">create_req</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">def</span> <span class="nf">create_rsp</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UvmObject</span><span class="p">:</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">start_item</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span> <span class="p">:</span> <span class="nb">object</span><span class="p">):</span> <span class="p">...</span>

    <span class="nd">@imp</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">finish_item</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span> <span class="p">:</span> <span class="nb">object</span><span class="p">):</span> <span class="p">...</span></code></pre></figure>

<p><strong>exp</strong> methods are ones that will be implemented in Python and will
be called from SystemVerilog. Likewise, <strong>imp</strong> methods will be implemented
in SystemVerilog and called from Python.</p>

<p>The PyHDL-IF code generator creates a SystemVerilog class that implements
this protocol – calling the Python method when an <strong>exp</strong> method is
called in SystemVerilog and calling a SystemVerilog when an <strong>imp</strong> method
is called in Python.</p>

<p>When a new instance of the generated SystemVerilog is created, it results 
in a pair of objects: one in SystemVerilog and a connected peer Python object.</p>

<h1 id="initiating-behavior">Initiating Behavior</h1>

<p>Starting Python behavior from a UVM-SV environment is as simple as selecting
the right <code class="language-plaintext highlighter-rouge">proxy</code> class, creating an instance, and using the <code class="language-plaintext highlighter-rouge">proxy</code> class
object within the UVM-SV environment as if it were a regular UVM object.</p>

<p>Let’s look at an example that implements a UVM sequence in Python.
Let’s look at the Python class before seeing how it is used. The
code below is from the <code class="language-plaintext highlighter-rouge">uvm/sequence_rand_item</code> example:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">hdl_if.uvm</span> <span class="kn">import</span> <span class="n">uvm_sequence_impl</span>

<span class="k">class</span> <span class="nc">PyRandSeq</span><span class="p">(</span><span class="n">uvm_sequence_impl</span><span class="p">):</span> 

    <span class="k">async</span> <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># Send a small burst of randomized items
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="n">req</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">create_req</span><span class="p">()</span>
            <span class="c1"># Randomize sequence item
</span>            <span class="n">req</span><span class="p">.</span><span class="nf">randomize</span><span class="p">()</span>

            <span class="c1"># Optional visibility
</span>            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">sprint</span><span class="p">()</span>
            <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">"&lt;no sprint available&gt;"</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"PyRandSeq: sending item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="nf">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">)</span></code></pre></figure>

<p>On a side note, I’ve been finding that AI assistants like Copilot and 
Cline are extremely helpful in creating tests and examples. I created
the code above, along with the rest of the example, using 
<a href="https://cline.bot/">Cline</a>. While the current set of models 
(GPT-5 in this case) does well with many types of code, the only 
mistakes I had to hand-correct were in the SystemVerilog code.</p>

<p>If you look closely, there are two APIs used here that aren’t 
technically UVM APIs: <code class="language-plaintext highlighter-rouge">randomize</code> and <code class="language-plaintext highlighter-rouge">create_req</code>. All the other APIs 
are standard UVM.</p>

<p>Now let’s see how we launch this code from UVM.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="kt">class</span> <span class="n">base_test</span> <span class="k">extends</span> <span class="n">uvm_test</span><span class="p">;</span>
        <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">base_test</span><span class="p">)</span>
        <span class="c1">// ...</span>

        <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="c1">// Python-driven sequence proxy</span>
            <span class="k">typedef</span> <span class="n">pyhdl_uvm_sequence_proxy</span> <span class="p">#(</span>
                <span class="p">.</span><span class="n">REQ</span><span class="p">(</span><span class="n">seq_item</span><span class="p">))</span> <span class="n">py_seq_t</span><span class="p">;</span>
            <span class="n">py_seq_t</span> <span class="n">seq</span><span class="p">;</span>

            <span class="n">phase</span><span class="p">.</span><span class="n">raise_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">py_seq_t</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"seq"</span><span class="p">);</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">pyclass</span> <span class="o">=</span> <span class="s">"pyseq::PyRandSeq"</span><span class="p">;</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_env</span><span class="p">.</span><span class="n">m_seqr</span><span class="p">);</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">drop_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="k">endtask</span>
    <span class="k">endclass</span></code></pre></figure>

<p>In the abbreviated snippet above, the test <code class="language-plaintext highlighter-rouge">run_phase</code> task creates an
instance of <code class="language-plaintext highlighter-rouge">pyhdl_uvm_sequence_proxy</code> that is properly specialized
for the request sequence item type and the Python class, then starts 
the sequence on the sequencer. UVM’s object-oriented nature lets us 
create and use a sequence without caring whether it’s implemented in
Python or SystemVerilog.</p>

<h1 id="pyhdl-if-uvm-api-specifics">PYHDL-IF UVM API Specifics</h1>

<p>Let’s use this example to look more closely at the API exposed by
PYHDL-IF. There are three core categories:</p>
<ul>
  <li>UVM methods that are exposed to Python as-is</li>
  <li>UVM methods whose signature is slightly altered</li>
  <li>Utility methods that are not part of UVM</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">get_name</code> method is an example of a UVM method that is exposed
to Python as-is.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="kt">string</span> <span class="n">get_name</span><span class="p">();</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="p">...</span></code></pre></figure>

<p>While there are a few cosmetic differences, these functions are
practically identical: same user-specified parameters and same 
return type.</p>

<p>The <code class="language-plaintext highlighter-rouge">get_config_object</code> method is an example of a UVM method that
is exposed to Python with slight alterations due to the language.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="kt">bit</span> <span class="n">get_config_object</span><span class="p">(</span><span class="kt">string</span> <span class="n">field_name</span><span class="p">,</span>
                               <span class="kt">inout</span> <span class="n">uvm_object</span> <span class="n">value</span><span class="p">,</span>
                               <span class="kt">input</span> <span class="kt">bit</span> <span class="n">clone</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_config_object</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> 
    <span class="n">field_name</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">clone</span> <span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">UvmObject</span><span class="p">]:</span></code></pre></figure>

<p>The key differences are in the return type and whether in-out
parameters are used. Python discourages returning values via
reference parameters, while this is a common pattern in SystemVerilog.
We follow the Python pattern to better-align with common practice there.</p>

<p>The final category are utility methods that aren’t present in UVM 
at all. Two examples are the <code class="language-plaintext highlighter-rouge">randomize</code> method and the <code class="language-plaintext highlighter-rouge">create_req</code>
method in the UVM sequence Python class. While <code class="language-plaintext highlighter-rouge">randomize</code> isn’t 
part of the UVM API, Python test content benefits from having it.
<code class="language-plaintext highlighter-rouge">create_req</code> exists for similar reasons. In SystemVerilog, we could
refer to the <code class="language-plaintext highlighter-rouge">REQ</code> type parameter of the sequence class to create 
a new request sequence item. In Python, it makes sense to expose
this functionality via a method.</p>

<h1 id="beyond-uvm-methods">Beyond UVM Methods</h1>

<p>The combination of exposing UVM-defined methods to Python, along with and 
two <code class="language-plaintext highlighter-rouge">proxy</code> classes to initiate behavior, makes it simple to run Python 
behavior and interact with the UVM testbench.</p>

<p>One thing you’ve probably noticed about the examples is that user-defined
data isn’t accessed from Python. While we call the <code class="language-plaintext highlighter-rouge">randomize</code> method from 
Python, we aren’t directly controlling the sequence-item fields. In the next 
post, we’ll take a look at how we can get and set the value of SystemVerilog
class fields from Python.</p>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[It’s not necessary to understand very much about how PyHDL-IF implements the bridge between Python and UVM, but useful to understand a bit. Doing so helps to understand what this library is and is not intended to do, and how you can best use it in your verification environment.]]></summary></entry><entry><title type="html">Unlocking the Combined Strength of UVM and Python</title><link href="https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength.html" rel="alternate" type="text/html" title="Unlocking the Combined Strength of UVM and Python" /><published>2025-10-04T00:00:00+00:00</published><updated>2025-10-04T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength</id><content type="html" xml:base="https://bitsbytesgates.com/pythonuvm/2025/10/04/UvmWithPython__UnlockCombinedStrength.html"><![CDATA[<p>UVM and Python are often positioned as rivals when it comes to their role in 
functional verification, with teams picking one or the other as the basis 
for a verification environments. Each have strengths, though, and using them 
together produces much stronger results. In fact, building on the popularity
of UVM and the availability of UVM verification components provides a 
significant boost to the process of introducing Python to an existing UVM 
environment.</p>

<!--more-->

<h1 id="assessing-languages-for-functional-verification">Assessing Languages for Functional Verification</h1>
<p>Using object-oriented languages to develop hardware verification environments
for simulation and hardware emulation is a longstanding practice. This is 
enabled by the fact that dynamic verification of hardware has a lot in common
with testing software. Aside from constrained randomization, tests for hardware look
very similar to tests for software. Likewise, scoreboards and other analytics
components organize, filter, and categorize data in very software-centric ways.</p>

<p>SystemVerilog is a commonly-used object-oriented language that is 
often used alongside UVM. But, C/C++, Java, and Python have all been used for 
verification for many years with and without UVM.</p>

<p>There are many factors to consider when selecting the languages to use for 
verification. It’s important to consider the features provided by the language, 
the size of its library ecosystem, and the size of the community. All of these 
contribute to the perceived ease with which new content can be developed using 
the language. Given the popularity of AI assistants, it’s also important to consider 
how ‘AI friendly’ the language is.</p>

<p>The Python language ranks highly on these criteria. It is the most popular software
language by several measures, and has been for some time. Development in Python 
is supported by a sizable collection of development tools and libraries. And,
it offers superior results with AI assistants due to the availability of large
volumes of training data for large language models (LLMs).</p>

<h1 id="ease-of-integration-and-reuse">Ease of Integration and Reuse</h1>

<p>But, for hardware verification, two of the most important factors to consider 
are ease of integration into a simulation environment and how readily existing
collateral can be reused. Both of these are critical in assessing how easily
a new language can be incrementally added to existing environments.</p>

<p>When it comes to ease of integration with simulation environments, Python also 
ranks very highly. The <a href="https://www.cocotb.org">cocotb</a> library is a well-known 
and well-maintained library that implements a dynamic integration with simulation 
environments at the signal level using the VPI API. This allows Python-driven tests 
to easily interact with a design at the signal level.</p>

<p>When it comes to reuse of existing infrastructure, the picture with Python is a bit 
more mixed. <code class="language-plaintext highlighter-rouge">cocotb</code> only supports integration at the signal level, which prevents 
reuse of existing SystemVerilog object-oriented collateral.</p>

<p>Having a strong reuse strategy is critical to the success of bringing a new 
verification language into an existing environment. It’s likely that many thousands
of person hours have been applied to building up the verification collateral in
a verification environment. Not only is it prohibitively expensive to re-develop
this in a new language, doing so risks the introduction of instability through
new bugs.</p>

<p>The <code class="language-plaintext highlighter-rouge">pyhdl-if</code> library enables the use of Python with existing SystemVerilog 
classes through the use of generated wrappers. This opens up significant new 
possibilities for reuse, but does come with a cost. In the worst case, each
and every VIP in a verification environment will require a task-based interface
to be designed and developed. This forces teams to be selective in which 
components are exposed to Python which, in turn, limits adoption of Python.</p>

<p>Ideally, we want the best of both when it comes to integration and reuse. 
We want a low-effort integration that also supports seamless reuse of existing
SystemVerilog object-oriented verification collateral.</p>

<h1 id="focusing-on-uvm">Focusing on UVM</h1>

<p>Fortunately, UVM helps to suggest a solution. Because of the popularity of UVM, 
focusing on enabling easy integration with UVM environments is a good 80+% solution.
Recent enhancements to the <code class="language-plaintext highlighter-rouge">pyhdl-if</code> library provide a ready-made integration with
UVM classes, enabling Python behavior to be initiated from UVM and UVM components 
to be used from Python. All without any custom wrapper code.</p>

<p>UVM provides several key areas of functionality, all of which are supported by APIs:</p>
<ul>
  <li>Component structure</li>
  <li>Sequences and sequencers</li>
  <li>Register model</li>
  <li>Configuration database</li>
  <li>Factory</li>
</ul>

<p>In addition to having access to these APIs, we also need to address two challenges:</p>
<ul>
  <li>How to work with user-defined types and data</li>
  <li>How to initiate Python behavior</li>
</ul>

<h1 id="example">Example</h1>

<p>Over the next few posts, we’ll dig into all the details of how this works from a
technical perspective. For now, let’s take a look at a simple example that highlights
just how easy it is to add Python behavior to a UVM environment by leveraging the
UVM API.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/10/pyhdl_uvm_component_proxy.png" />
</p>

<p>This example shows how we can use a <em>component proxy</em> class in SystemVerilog 
to initiate Python behavior from our UVM testbench. As the diagram suggests, 
we will add a new component instance in SystemVerilog that will act as a 
proxy for a UVM component implementation in Python.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">package</span> <span class="n">top_pkg</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">uvm_pkg</span><span class="o">::*</span><span class="p">;</span>
    <span class="k">import</span> <span class="n">pyhdl_uvm</span><span class="o">::*</span><span class="p">;</span>

    <span class="c1">// Test</span>
    <span class="kt">class</span> <span class="n">base_test</span> <span class="k">extends</span> <span class="n">uvm_test</span><span class="p">;</span>

        <span class="n">pyhdl_uvm_component_proxy</span>   <span class="n">m_pycomp</span><span class="p">;</span>

        <span class="cp">`uvm_component_utils</span><span class="p">(</span><span class="n">base_test</span><span class="p">)</span>

        <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"base_test"</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span><span class="p">);</span>
            <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">endfunction</span>

        <span class="k">function</span> <span class="kt">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
            <span class="n">m_pycomp</span> <span class="o">=</span> <span class="n">pyhdl_uvm_component_proxy</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"m_pycomp"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
            <span class="n">m_pycomp</span><span class="p">.</span><span class="n">pyclass</span> <span class="o">=</span> <span class="s">"pycomp::PyComp"</span><span class="p">;</span>
        <span class="k">endfunction</span>

        <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"--&gt; test run_phase"</span><span class="p">);</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">raise_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="c1">// Test stimulus would go here</span>
            <span class="p">#</span><span class="mi">100</span><span class="p">;</span>
            <span class="n">phase</span><span class="p">.</span><span class="n">drop_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"&lt;-- test run_phase"</span><span class="p">);</span>
        <span class="k">endtask</span>
    <span class="k">endclass</span>

<span class="k">endpackage</span></code></pre></figure>

<p>The additions to the SystemVerilog portion of the testbench are minimal. Specifically:</p>
<ul>
  <li>New field for the component proxy</li>
  <li>Construction of the component proxy in the <em>build_phase</em>.</li>
  <li>Specification of the Python class that implements the component</li>
</ul>

<p>Now let’s look at the Python class:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">hdl_if.uvm</span> <span class="kn">import</span> <span class="n">UvmComponentProxy</span>

<span class="k">class</span> <span class="nc">PyComp</span><span class="p">(</span><span class="n">UvmComponentProxy</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">build_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"-- build_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"-- connect_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">run_phase</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Hello from PyComp run_phase"</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p>The implementation must inherit from the <em>UvmComponentProxy</em> base class. The
<em>build_phase</em>, <em>connect_phase</em>, and <em>run_phase</em> methods will be invoked by 
the SystemVerilog UVM environment.</p>

<p>And, that’s it. No need to generate API interface classes, and just a few
lines a code needed to get something running.</p>

<p>If you’re interested, you can look at the full code <a href="https://github.com/fvutils/pyhdl-if/tree/main/examples/uvm">here</a>.</p>

<h1 id="conclusions-and-next-steps">Conclusions and Next Steps</h1>

<p>Of course, the example above only shows how to get started. 
Over the next few posts, we’ll dive into more detail on the capabilities of the
<code class="language-plaintext highlighter-rouge">pyhdl-if</code> library UVM integration. We’ll also look at usecases for Python in 
a verification environment.</p>]]></content><author><name></name></author><category term="PythonUVM" /><summary type="html"><![CDATA[UVM and Python are often positioned as rivals when it comes to their role in functional verification, with teams picking one or the other as the basis for a verification environments. Each have strengths, though, and using them together produces much stronger results. In fact, building on the popularity of UVM and the availability of UVM verification components provides a significant boost to the process of introducing Python to an existing UVM environment.]]></summary></entry><entry><title type="html">Zuspec: Pythonic Model-Driven Hardware Development</title><link href="https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment.html" rel="alternate" type="text/html" title="Zuspec: Pythonic Model-Driven Hardware Development" /><published>2025-09-22T00:00:00+00:00</published><updated>2025-09-22T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/09/22/Zuspec_PythonicModelDrivenHardwareDevelopment.html"><![CDATA[<p>Designing and implementing hardware is challenging, and is getting more 
difficult each year as systems become more complex. Design and verification 
teams are looking to boost productivity as a way to keep pace, 
while also looking for ways to provide models of the design behavior to 
software teams earlier. The fragmented and esoteric nature of the languages 
and methodologies used for design and verification only make this more difficult. 
Zuspec aspires to provide a unified, extensible Pythonic framework for multi-abstraction 
hardware modeling that simplifies the design and verification process and 
enables traditional and AI-driven automation.</p>

<!-- more -->

<p>The abstraction gap and model fragmentation are two key drivers of hardware
design-flow complexity. The abstraction difference between a 
natural-language design specification and the register-transfer-level (RTL) 
model that implements it is enormous, and only increasing as designs 
become larger and more complex. It’s natural to prioritize the 
RTL model, since that is required to get to implementation. However, 
because RTL models are detailed and execute slowly, they don’t do a good job of
meeting the needs of adjacent disciplines, such as firmware. 
This delays how early software teams obtain access to a representation of the design,
and limits the platforms on which they can work to fast hardware emulation
or prototyping environments.</p>

<p>Over time, new requirements have resulted in the development of new 
domain-specific languages and language-like class libraries. SystemVerilog, 
PSS, UPF, IP-XACT, SystemC, and others all provide features that address pain 
points of hardware development.  Unfortunately, this has also led to a very 
fragmented ecosystem with loosely-integrated languages and methodologies and 
complex build flows.</p>

<h1 id="considering-the-ecosystem">Considering the Ecosystem</h1>

<p>All of these innovations have primarily come from a hardware-design 
perspective, and focus on enabling hardware-design flows. That,
in itself, is a challenge given the relative sizes of the 
hardware- and software-engineering ecosystems. While it’s 
difficult to find accurate detailed data, US Bureau of Labor 
Statistics reports a labor-market size of 76,800 for hardware 
engineers vs a labor-market size of 1,534,790 for software 
engineers (inclusive of all sub-disciplines in both cases).</p>

<p>Given that the collective challenge is a combined hardware and 
software system, getting buy-in from both disciplines is critical.
It seems quite unlikely that a language created to serve the unique
requirements of the ecosystem’s minority can serve the combined
needs and gain the acceptance of the majority.</p>

<h1 id="zuspec">Zuspec</h1>

<p>Zuspec<a href="https://zuspec.github.io/">1</a> adopts Python as its starting 
point, and embeds hardware semantics into that ecosystem. The result 
is a platform that is familiar to software engineers, offers 
high productivity for hardware engineering, and has the goal of 
increasing the ability to share artifacts across the disciplines.</p>

<h2 id="why-python">Why Python?</h2>

<p>Many factors are involved in selecting a language for any purpose: 
key language features, tool ecosystem, relevant libraries, as well
as the community around the language. Applying an existing language to the 
semantics of another  domains raises another factor to consider: 
flexibility of the language.</p>

<h3 id="popularity-can-be-self-reinforcing">Popularity can be Self-Reinforcing</h3>

<p>Python is a popular language overall, holding the top spot in many
rankings for several consecutive years, and being ranked highly 
for many years before that. Language popularity may not seem relevant
compared to the technical features of a language. Not only it is 
relevant, popularity has a direct bearing on language technical
features. TIOBE [2])(https://www.tiobe.com/tiobe-index/), for example, 
measures language rank in terms of searches via a range of internet 
search engines <a href="https://en.wikipedia.org/wiki/TIOBE_index">3</a>. This is, 
of course, a rough measure a the size of a language’s community. Larger
communities produce more ideas for using a language and, thus,
a a larger library ecosystem. Larger communities more-rapidly
produce and refine adjacent technologies, such as code 
development and package management tools, and new language features.</p>

<p>Popularity often builds upon itself, and there is evidence that 
AI is acting as a driver of Python’s popularity.
Specifically, AI assistants are often reported to be more 
effective with Python than with other languages <a href="https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA">4</a>.
This has the effect of drawing more developers to Python, which
increases the available code in Python, which more-rapidly
increases the quality of results with Python.</p>

<p>But, language popularity is only relevant for the set of languages
that can be used to capture relevant domain semantics. Fortunately,
Python measures up very well here again.</p>

<h3 id="technical-arguments-for-python">Technical Arguments for Python</h3>

<p>There are strong technical arguments for the Python language as well.
As a dynamic language, Python provides excellent facilities for 
introspecting and manipulating a Python description.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">SendPacket</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Struct</span><span class="p">):</span>
  <span class="n">sz</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span>

  <span class="nd">@zdc.constraint</span>
  <span class="k">def</span> <span class="nf">valid_sz</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">sz</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
</code></pre></div></div>

<p>Python <code class="language-plaintext highlighter-rouge">decorators</code> can be used to annotate elements of the description,
identifying specific semantics to be applied to an element or attaching
special processing instructions. For example, the <code class="language-plaintext highlighter-rouge">constraint</code> decorator
above marks the body of the <code class="language-plaintext highlighter-rouge">valid_sz</code> method as having constraint 
semantics.</p>

<p>Python also allows inheritance relationships to be inspected at any
point in time. The base type controls capabilities and restrictions
of the derived type.</p>

<p>While Python can be used as a purely dynamically-typed language, it 
also provides the ability to associate type “hints” with variables. 
The <code class="language-plaintext highlighter-rouge">sz</code> field in the example above specifies that it is an unsigned
8-bit field. This enables the modeler to control how data in the
model will be represented in the implementation.</p>

<p>Finally, Python supports AST introspection and transformation. This 
capability allows tools to access the raw AST for code, such as 
the constraint method above, without needing to use tricks like 
operator overloading.</p>

<p>Statically-typed languages often provide some introspection facilities
that are available during the compilation phase. In contrast, Python 
allows these facilities to be applied to a Python description at any 
point in time, providing much more flexibility in processing flows. 
Effectively, Python allows libraries like Zuspec to act as a compiler
within the Python interpreter.</p>

<p>Python also offers a strong set of system-programming features.
Combined with Python’s dynamic language features, these dramatically
simplify the process of integrating external tools and systems.</p>

<p>Python also specifies a package specification and provides tools
for producing, discovering, and consuming packages.</p>

<p>Together, these capabilities make Python a very compelling platform 
for developing, verifying, and publishing hardware models.</p>

<h1 id="what-does-this-look-like">What does this look like?</h1>

<p>All languages are a combination of syntax and semantics. Syntax 
governs the lexical aspects of a language: the keywords, operators,
and legal ways of arranging them. Semantics governs the meanings of
those statements – for example, whether <code class="language-plaintext highlighter-rouge">a = b</code> changes the value
of the <code class="language-plaintext highlighter-rouge">a</code> variable, changes the <code class="language-plaintext highlighter-rouge">a</code> variable to reference
the <code class="language-plaintext highlighter-rouge">b</code> variable, or something entirely different. Zuspec proposes
a way to adopt full Python syntax, while identifying key regions
in which different semantics apply to this syntax. These new semantics
are always more restrictive than native Python semantics, allowing
existing code checkers (eg mypy) to work unmodified.</p>

<p>Zuspec divides a Python description into two core region kinds:</p>

<ul>
  <li>Pure Python regions</li>
  <li>Python regions with domain-specific semantics</li>
</ul>

<p>Even a simple binary counter highlights several unique semantics that 
a hardware description must capture:</p>

<ul>
  <li>Bit width of the <code class="language-plaintext highlighter-rouge">count</code> field</li>
  <li>When the count should be incremented</li>
  <li>Hardware-specific notions like reset</li>
</ul>

<p>Zuspec identifies regions with these semantics using a combination of
Python <code class="language-plaintext highlighter-rouge">decorators</code> and base classes. The example below shows a 
32-bit counter modeled using the Zuspec library.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Component</span><span class="p">):</span>
  <span class="n">clock</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">input</span><span class="p">()</span>
  <span class="n">reset</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">input</span><span class="p">()</span>
  <span class="n">count</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">Bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">output</span><span class="p">()</span>

  <span class="nd">@zdc.sync</span><span class="p">(</span><span class="n">clock</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">reset</span><span class="p">)</span> 
  <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">reset</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> example above illustrates these two regions. By default,
pure Python semantics are used. Consequently, the <code class="language-plaintext highlighter-rouge">import</code> statement
at the top uses pure Python semantics.</p>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> class inherits from the Zuspec <code class="language-plaintext highlighter-rouge">Component</code> class, which
designates it as a class with specific capabilities.  The <code class="language-plaintext highlighter-rouge">inc</code> method
is decorated with the <code class="language-plaintext highlighter-rouge">sync</code> decorator. This marks it as a method that
is automatically evaluated on the active edge of the specified 
clock or reset signals, and a method where deferred assignment is used.
It also marks it as a method that may not be invoked directly.</p>

<p>A class domain with special semantics is a model of implementation, 
and cannot be used directly. Instead, a <code class="language-plaintext highlighter-rouge">Transformer</code> class 
must first be used to create an implementation. In this case, the 
implementation could be pure-Python, Verilog, or something entirely 
different like documentation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">from</span> <span class="n">zuspec.be.py</span> <span class="kn">import</span> <span class="n">ComponentFactory</span>
<span class="kn">import</span> <span class="n">zuspec.dataclasses</span> <span class="k">as</span> <span class="n">zdc</span>

<span class="nd">@zdc.dataclass</span>
<span class="k">class</span> <span class="nc">CountTB</span><span class="p">(</span><span class="n">zdc</span><span class="p">.</span><span class="n">Component</span><span class="p">):</span>
  <span class="n">clkrst</span> <span class="p">:</span> <span class="n">zdc</span><span class="p">.</span><span class="n">ClockReset</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="p">{</span><span class="n">period</span><span class="o">=</span><span class="mi">10</span><span class="p">})</span>
  <span class="n">counter</span> <span class="p">:</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">zdc</span><span class="p">.</span><span class="nf">field</span><span class="p">(</span>
      <span class="n">bind</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:{</span>
          <span class="n">s</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">clock</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span>
          <span class="n">s</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">reset</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="n">reset</span>
      <span class="p">})</span>

<span class="k">def</span> <span class="nf">test_smoke</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
  <span class="n">tb</span> <span class="o">=</span> <span class="nc">ComponentFactory</span><span class="p">(</span><span class="n">CountTB</span><span class="p">)</span>
  <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="nf">do_reset</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">tb</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">clkrst</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">tb</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">10</span>
</code></pre></div></div>

<p>The example above shows a small testbench around the <code class="language-plaintext highlighter-rouge">Counter</code> 
component with a simple <code class="language-plaintext highlighter-rouge">Pytest</code> unit test. The type transformer 
creates a Python object that is used to dynamically evaluate
the model. While the interface is Python, the implementation
may or may not be Python. For example, the transformer might, 
instead, transform the model to Verilog and create a Verilator 
<a href="https://www.veripool.org/verilator/">5</a>
simulator executable that evaluates the model much faster than
a pure-Python implementation, while still exposing a Python 
interface to the signals.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">Counter</span><span class="p">(</span>
    <span class="kt">input</span>            <span class="n">clock</span><span class="p">,</span>
    <span class="kt">input</span>            <span class="n">reset</span><span class="p">,</span>
    <span class="kt">output</span> <span class="kt">reg</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">count</span><span class="p">);</span>

    <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span> <span class="kt">or</span> <span class="kt">posedge</span> <span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="mi">32</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></div></div>

<p>Another transformer might convert the model to the synthesizable
Verilog shown above to be used as input to existing 
synthesis or simulation flows.</p>

<h1 id="the-user-extensible-language">The User-Extensible Language</h1>

<p>The <code class="language-plaintext highlighter-rouge">Counter</code> example is quite simple, and at the register-transfer level (RTL).
Zuspec is designed to be able to capture a broad range of 
hardware-centric semantics that cover:</p>

<ul>
  <li>Verification
    <ul>
      <li>Constrained randomization and functional coverage</li>
      <li>Portable test and stimulus (PSS)</li>
      <li>Assertions (SVA)</li>
    </ul>
  </li>
  <li>Hardware design
    <ul>
      <li>RTL</li>
      <li>Medium-level synthesis</li>
      <li>Transaction-level modeling (TLM)</li>
      <li>Register modeling</li>
      <li>Clock and power domains</li>
      <li>Physical design</li>
    </ul>
  </li>
  <li>Firmware
    <ul>
      <li>Register interface</li>
      <li>Specialized memory management</li>
    </ul>
  </li>
</ul>

<p>Zuspec brings a new approach to domain-specific languages that leverages the 
popularity and ecosystem of Python, and embeds domain-specific semantics from
hardware design, verification, and firmware. The big “bet” is that educating
humans and LLMs on the delta between a Python and a set of domain-specific
semantics is far easier than doing the same with a completely new language.</p>

<p>While Zuspec models are captured in Python, processing tools may transform Zuspec 
models into appropriate non-Python implementations such as embedded C or 
synthesizable Verilog.  Zuspec encourages a Pythonic development process for 
hardware that is code-centric, AI-friendly, and nimble. And, most importantly, 
Zuspec provides togetherness: a common environment in which new language 
innovations can be explored along with integrated existing technologies.</p>

<h3 id="references">References</h3>
<ol>
  <li>https://zuspec.github.io</li>
  <li>https://www.tiobe.com/tiobe-index/</li>
  <li>https://en.wikipedia.org/wiki/TIOBE_index</li>
  <li>https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA</li>
  <li>https://www.veripool.org/verilator/</li>
</ol>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[Designing and implementing hardware is challenging, and is getting more difficult each year as systems become more complex. Design and verification teams are looking to boost productivity as a way to keep pace, while also looking for ways to provide models of the design behavior to software teams earlier. The fragmented and esoteric nature of the languages and methodologies used for design and verification only make this more difficult. Zuspec aspires to provide a unified, extensible Pythonic framework for multi-abstraction hardware modeling that simplifies the design and verification process and enables traditional and AI-driven automation. The abstraction gap and model fragmentation are two key drivers of hardware design-flow complexity. The abstraction difference between a natural-language design specification and the register-transfer-level (RTL) model that implements it is enormous, and only increasing as designs become larger and more complex. It’s natural to prioritize the RTL model, since that is required to get to implementation. However, because RTL models are detailed and execute slowly, they don’t do a good job of meeting the needs of adjacent disciplines, such as firmware. This delays how early software teams obtain access to a representation of the design, and limits the platforms on which they can work to fast hardware emulation or prototyping environments. Over time, new requirements have resulted in the development of new domain-specific languages and language-like class libraries. SystemVerilog, PSS, UPF, IP-XACT, SystemC, and others all provide features that address pain points of hardware development. Unfortunately, this has also led to a very fragmented ecosystem with loosely-integrated languages and methodologies and complex build flows. Considering the Ecosystem All of these innovations have primarily come from a hardware-design perspective, and focus on enabling hardware-design flows. That, in itself, is a challenge given the relative sizes of the hardware- and software-engineering ecosystems. While it’s difficult to find accurate detailed data, US Bureau of Labor Statistics reports a labor-market size of 76,800 for hardware engineers vs a labor-market size of 1,534,790 for software engineers (inclusive of all sub-disciplines in both cases). Given that the collective challenge is a combined hardware and software system, getting buy-in from both disciplines is critical. It seems quite unlikely that a language created to serve the unique requirements of the ecosystem’s minority can serve the combined needs and gain the acceptance of the majority. Zuspec Zuspec1 adopts Python as its starting point, and embeds hardware semantics into that ecosystem. The result is a platform that is familiar to software engineers, offers high productivity for hardware engineering, and has the goal of increasing the ability to share artifacts across the disciplines. Why Python? Many factors are involved in selecting a language for any purpose: key language features, tool ecosystem, relevant libraries, as well as the community around the language. Applying an existing language to the semantics of another domains raises another factor to consider: flexibility of the language. Popularity can be Self-Reinforcing Python is a popular language overall, holding the top spot in many rankings for several consecutive years, and being ranked highly for many years before that. Language popularity may not seem relevant compared to the technical features of a language. Not only it is relevant, popularity has a direct bearing on language technical features. TIOBE [2])(https://www.tiobe.com/tiobe-index/), for example, measures language rank in terms of searches via a range of internet search engines 3. This is, of course, a rough measure a the size of a language’s community. Larger communities produce more ideas for using a language and, thus, a a larger library ecosystem. Larger communities more-rapidly produce and refine adjacent technologies, such as code development and package management tools, and new language features. Popularity often builds upon itself, and there is evidence that AI is acting as a driver of Python’s popularity. Specifically, AI assistants are often reported to be more effective with Python than with other languages 4. This has the effect of drawing more developers to Python, which increases the available code in Python, which more-rapidly increases the quality of results with Python. But, language popularity is only relevant for the set of languages that can be used to capture relevant domain semantics. Fortunately, Python measures up very well here again. Technical Arguments for Python There are strong technical arguments for the Python language as well. As a dynamic language, Python provides excellent facilities for introspecting and manipulating a Python description. import zuspec.dataclasses as zdc @zdc.dataclass class SendPacket(zdc.Struct): sz : zdc.Bit[8] = zdc.rand() @zdc.constraint def valid_sz(self): self.sz in [1, 2, 4, 8, 16] Python decorators can be used to annotate elements of the description, identifying specific semantics to be applied to an element or attaching special processing instructions. For example, the constraint decorator above marks the body of the valid_sz method as having constraint semantics. Python also allows inheritance relationships to be inspected at any point in time. The base type controls capabilities and restrictions of the derived type. While Python can be used as a purely dynamically-typed language, it also provides the ability to associate type “hints” with variables. The sz field in the example above specifies that it is an unsigned 8-bit field. This enables the modeler to control how data in the model will be represented in the implementation. Finally, Python supports AST introspection and transformation. This capability allows tools to access the raw AST for code, such as the constraint method above, without needing to use tricks like operator overloading. Statically-typed languages often provide some introspection facilities that are available during the compilation phase. In contrast, Python allows these facilities to be applied to a Python description at any point in time, providing much more flexibility in processing flows. Effectively, Python allows libraries like Zuspec to act as a compiler within the Python interpreter. Python also offers a strong set of system-programming features. Combined with Python’s dynamic language features, these dramatically simplify the process of integrating external tools and systems. Python also specifies a package specification and provides tools for producing, discovering, and consuming packages. Together, these capabilities make Python a very compelling platform for developing, verifying, and publishing hardware models. What does this look like? All languages are a combination of syntax and semantics. Syntax governs the lexical aspects of a language: the keywords, operators, and legal ways of arranging them. Semantics governs the meanings of those statements – for example, whether a = b changes the value of the a variable, changes the a variable to reference the b variable, or something entirely different. Zuspec proposes a way to adopt full Python syntax, while identifying key regions in which different semantics apply to this syntax. These new semantics are always more restrictive than native Python semantics, allowing existing code checkers (eg mypy) to work unmodified. Zuspec divides a Python description into two core region kinds: Pure Python regions Python regions with domain-specific semantics Even a simple binary counter highlights several unique semantics that a hardware description must capture: Bit width of the count field When the count should be incremented Hardware-specific notions like reset Zuspec identifies regions with these semantics using a combination of Python decorators and base classes. The example below shows a 32-bit counter modeled using the Zuspec library. import zuspec.dataclasses as zdc @zdc.dataclass class Counter(zdc.Component): clock : zdc.Bit = zdc.input() reset : zdc.Bit = zdc.input() count : zdc.Bit[32] = zdc.output() @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset) def inc(self): if self.reset: self.count = 0 else: self.count += 1 The Counter example above illustrates these two regions. By default, pure Python semantics are used. Consequently, the import statement at the top uses pure Python semantics. The Counter class inherits from the Zuspec Component class, which designates it as a class with specific capabilities. The inc method is decorated with the sync decorator. This marks it as a method that is automatically evaluated on the active edge of the specified clock or reset signals, and a method where deferred assignment is used. It also marks it as a method that may not be invoked directly. A class domain with special semantics is a model of implementation, and cannot be used directly. Instead, a Transformer class must first be used to create an implementation. In this case, the implementation could be pure-Python, Verilog, or something entirely different like documentation. import asyncio from zuspec.be.py import ComponentFactory import zuspec.dataclasses as zdc @zdc.dataclass class CountTB(zdc.Component): clkrst : zdc.ClockReset = zdc.field(init={period=10}) counter : Counter = zdc.field( bind=lambda s:{ s.counter.clock : s.clkrst.clock, s.counter.reset : s.clkrst.reset }) def test_smoke(self): tb = ComponentFactory(CountTB) asyncio.run(tb.clkrst.do_reset(count=10)) assert tb.counter.count == 0 asyncio.run(tb.clkrst.wait(count=10)) assert tb.counter.count == 10 The example above shows a small testbench around the Counter component with a simple Pytest unit test. The type transformer creates a Python object that is used to dynamically evaluate the model. While the interface is Python, the implementation may or may not be Python. For example, the transformer might, instead, transform the model to Verilog and create a Verilator 5 simulator executable that evaluates the model much faster than a pure-Python implementation, while still exposing a Python interface to the signals. module Counter( input clock, input reset, output reg[31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= {32{1'b0}}; end else begin count &lt;= count + 1; end end endmodule Another transformer might convert the model to the synthesizable Verilog shown above to be used as input to existing synthesis or simulation flows. The User-Extensible Language The Counter example is quite simple, and at the register-transfer level (RTL). Zuspec is designed to be able to capture a broad range of hardware-centric semantics that cover: Verification Constrained randomization and functional coverage Portable test and stimulus (PSS) Assertions (SVA) Hardware design RTL Medium-level synthesis Transaction-level modeling (TLM) Register modeling Clock and power domains Physical design Firmware Register interface Specialized memory management Zuspec brings a new approach to domain-specific languages that leverages the popularity and ecosystem of Python, and embeds domain-specific semantics from hardware design, verification, and firmware. The big “bet” is that educating humans and LLMs on the delta between a Python and a set of domain-specific semantics is far easier than doing the same with a completely new language. While Zuspec models are captured in Python, processing tools may transform Zuspec models into appropriate non-Python implementations such as embedded C or synthesizable Verilog. Zuspec encourages a Pythonic development process for hardware that is code-centric, AI-friendly, and nimble. And, most importantly, Zuspec provides togetherness: a common environment in which new language innovations can be explored along with integrated existing technologies. References https://zuspec.github.io https://www.tiobe.com/tiobe-index/ https://en.wikipedia.org/wiki/TIOBE_index https://www.perplexity.ai/page/ai-generates-up-to-30-of-micro-Iy6zscIfSy6miYtIqvrsMA https://www.veripool.org/verilator/]]></summary></entry><entry><title type="html">AI: Instigating a Developer Docs Renaissance?</title><link href="https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance.html" rel="alternate" type="text/html" title="AI: Instigating a Developer Docs Renaissance?" /><published>2025-08-30T00:00:00+00:00</published><updated>2025-08-30T00:00:00+00:00</updated><id>https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance</id><content type="html" xml:base="https://bitsbytesgates.com/ai/2025/08/30/AI_Instigating_a_DevDocRenaissance.html"><![CDATA[<p>There’s been lots of discussion about the future of writing in the AI age.
LLMs have shown their potential as a tool by helping authors of many genres 
brainstorm ideas, rough out content, and more. But, this automation comes
with questions attached. If writing can be automated, 
what is the writer’s role? If LLMs only deliver the illusion of
producing useful content, are we about to experience a deluge of 
unintelligible <a href="https://simonwillison.net/2024/May/8/slop/">slop</a> 
masquerading as useful documentation? I’ve done my share of 
hand wringing while reviewing AI-created code commands and documentation 
that had the form of useful information, but little insightful content. 
A recent coding experience has me seeing an opportunity for a 
developer-docs renaissance driven by the needs of LLMs.</p>

<!-- more -->

<h1 id="developer-docs-and-why-we-dont-create-them">Developer Docs and why we don’t create them</h1>

<p>I define developer docs as the set of documentation that helps a
developer navigate a technical project and understand things like:</p>
<ul>
  <li>How to build the project from source</li>
  <li>How to run tests on the project</li>
  <li>Basic structure and architecture of the project</li>
  <li>Examples of how to interact with the API</li>
  <li>Any special structures used by the project</li>
</ul>

<p>Notes like this have several possible audiences</p>
<ul>
  <li>Colleagues</li>
  <li>Open source project: potential contributors</li>
  <li>Future you</li>
</ul>

<p>I suspect most of us agree that this information is useful,
and don’t truly feel that our code is self-documenting. 
But, it always seems difficult to devote time to writing good 
developer documentation. Why? I think it’s because, 
no matter the audience, developer docs are for the future – 
a future colleague, future collaborator, or future you. And
it’s always tempting to prioritize the ‘now’ when it comes
to choosing between ‘now’ and ‘future’.</p>

<p>LLMs shift that equation by making developer docs immediately 
actionable, and I’m optimistic that this may actually shift 
our behavior.</p>

<h1 id="working-with-complex-projects">Working with Complex Projects</h1>

<p>I was recently working on one of my open source projects. The structure
is a bit complicated due to some of the requirements. Specifically,
I have library projects that consist of:</p>
<ul>
  <li>C++ API consisting of pure-virtual interface classes</li>
  <li>Core implementation in C++</li>
  <li>A Cython wrapper API implemented in terms of the pure-virtual interface classes</li>
</ul>

<p>This structure enables the libraries to be used effiently from C++ and Python,
and allows the library native code to interact directly whether called from
C++ or Python. The downside, of course, is that adding a new class or method
involves changes across several source locations: C++ interface, C++ implementation,
and several locations across the Python interface.</p>

<p>I’ve been using AI assistants (Cline, Copilot) to make modifications to 
this codebase with varying success. On one hand, the results were quite
good given that the only data it had was the code. On the other hand,
there were many cases where the model (gpt-4.1 in this case) would only 
perform a subset of the required changes. In one case, it decided to 
create a new Cython extension file entirely.</p>

<h1 id="developer-docs-as-llm-instructions">Developer Docs as LLM Instructions</h1>

<p>I had independently started to write down some notes about the structure 
of this code. You can find the notes <a href="https://github.com/zuspec/zuspec-dev-docs/blob/main/docs/python_ext_structure.md">here</a>
if you’re interested. Not too complicated, and much more needed of course.</p>

<p>But, when I included this as context for the LLM, the results from the AI assistant
improved dramatically. Still not perfect, but sufficiently better that
I feel more motivated to start a task by writing out some notes. Because,
after all, these notes will be immediately useful as I start working on
the implementation.</p>

<h1 id="looking-forward">Looking Forward</h1>

<p>Writing developer docs and writing code is too-often seen as a zero-sum game:
I can write code <em>or</em> I can write developer documentation. LLMs change this 
by blurring the line between writing docs and code. Writing docs, in fact,
may provide greater leverage by allowing you to drive automation of the 
more-tedious aspects of writing code directly from developer docs.</p>

<p>Looking forward, I’m very interested in what standardization emerges around
capturing and curating context documentation intended for LLMs. Specifically,
I’m watching <a href="https://agents.md/">Agents.md</a> and <a href="https://llmstxt.org/">llms.txt</a>.</p>

<p>Even more immediately, I’m revisiting how I build out the Zuspec Python-embedded
language. I’m planning to take a documentation-first approach, and am interested
to evaluate the impact this has on the development process itself and my ability
to leverage AI assistants along the way.</p>

<p>.</p>]]></content><author><name></name></author><category term="AI" /><summary type="html"><![CDATA[There’s been lots of discussion about the future of writing in the AI age. LLMs have shown their potential as a tool by helping authors of many genres brainstorm ideas, rough out content, and more. But, this automation comes with questions attached. If writing can be automated, what is the writer’s role? If LLMs only deliver the illusion of producing useful content, are we about to experience a deluge of unintelligible slop masquerading as useful documentation? I’ve done my share of hand wringing while reviewing AI-created code commands and documentation that had the form of useful information, but little insightful content. A recent coding experience has me seeing an opportunity for a developer-docs renaissance driven by the needs of LLMs. Developer Docs and why we don’t create them I define developer docs as the set of documentation that helps a developer navigate a technical project and understand things like: How to build the project from source How to run tests on the project Basic structure and architecture of the project Examples of how to interact with the API Any special structures used by the project Notes like this have several possible audiences Colleagues Open source project: potential contributors Future you I suspect most of us agree that this information is useful, and don’t truly feel that our code is self-documenting. But, it always seems difficult to devote time to writing good developer documentation. Why? I think it’s because, no matter the audience, developer docs are for the future – a future colleague, future collaborator, or future you. And it’s always tempting to prioritize the ‘now’ when it comes to choosing between ‘now’ and ‘future’. LLMs shift that equation by making developer docs immediately actionable, and I’m optimistic that this may actually shift our behavior. Working with Complex Projects I was recently working on one of my open source projects. The structure is a bit complicated due to some of the requirements. Specifically, I have library projects that consist of: C++ API consisting of pure-virtual interface classes Core implementation in C++ A Cython wrapper API implemented in terms of the pure-virtual interface classes This structure enables the libraries to be used effiently from C++ and Python, and allows the library native code to interact directly whether called from C++ or Python. The downside, of course, is that adding a new class or method involves changes across several source locations: C++ interface, C++ implementation, and several locations across the Python interface. I’ve been using AI assistants (Cline, Copilot) to make modifications to this codebase with varying success. On one hand, the results were quite good given that the only data it had was the code. On the other hand, there were many cases where the model (gpt-4.1 in this case) would only perform a subset of the required changes. In one case, it decided to create a new Cython extension file entirely. Developer Docs as LLM Instructions I had independently started to write down some notes about the structure of this code. You can find the notes here if you’re interested. Not too complicated, and much more needed of course. But, when I included this as context for the LLM, the results from the AI assistant improved dramatically. Still not perfect, but sufficiently better that I feel more motivated to start a task by writing out some notes. Because, after all, these notes will be immediately useful as I start working on the implementation. Looking Forward Writing developer docs and writing code is too-often seen as a zero-sum game: I can write code or I can write developer documentation. LLMs change this by blurring the line between writing docs and code. Writing docs, in fact, may provide greater leverage by allowing you to drive automation of the more-tedious aspects of writing code directly from developer docs. Looking forward, I’m very interested in what standardization emerges around capturing and curating context documentation intended for LLMs. Specifically, I’m watching Agents.md and llms.txt. Even more immediately, I’m revisiting how I build out the Zuspec Python-embedded language. I’m planning to take a documentation-first approach, and am interested to evaluate the impact this has on the development process itself and my ability to leverage AI assistants along the way. .]]></summary></entry><entry><title type="html">Re-Evaluating EDA DSLs: Becoming the Compiler</title><link href="https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler.html" rel="alternate" type="text/html" title="Re-Evaluating EDA DSLs: Becoming the Compiler" /><published>2025-08-23T00:00:00+00:00</published><updated>2025-08-23T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/08/23/ReEvaluating_EDA_DSLs_BecomingTheCompiler.html"><![CDATA[<p>A key benefit of full languages is having full control over processing
the language: being the compiler.  Having full control over language
processing is exactly what enables us target simulation and FPGA bitstream
with the same SystemVerilog source simply by specifying the same source
to different toolchains. Fortunately, Python’s dynamic nature gives us 
all the tools we need to “become the compiler” for portions of the 
Python description that we care about.</p>

<!-- more -->

<h1 id="a-simple-counter">A Simple Counter</h1>

<p>Let’s start with an example. The code below represents the behavior of 
a very simple counter in Verilog:</p>

<figure class="highlight"><pre><code class="language-systenverilog" data-lang="systenverilog">module counter(
  input             clock,
  input             reset,
  output reg[31:0]  count);

  always @(posedge clock or posedge reset) begin
    if (reset) begin
      count &lt;= {32{1'b0}};
    end else begin
      count &lt;= count + 1;
    end
  end

endmodule</code></pre></figure>

<p>When we process this description to create an implementation, there
are a few things that we need to know:</p>

<ul>
  <li>The region of interest – what is a class, module, interface, etc?</li>
  <li>Data member types and kinds – local data vs port with directionality</li>
  <li>Logic/behavior inside the region and when it’s activated</li>
</ul>

<p>A Verilog-based tool establishes these key attributes by lexically processing
the input text.</p>

<p>Let’s create an equivalent representation in Python using our Zuspec 
library.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.reset, reset=lambda s:s.clock):
    def inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1</code></pre></figure>

<p>From one perspective, this is just a Python class that conforms to
the Python’s syntactic and semantic rules. But, we’ve also encoded
some special domain-specific information:</p>

<ul>
  <li>The base class is <code class="language-plaintext highlighter-rouge">Component</code>. A processing tool can identify the “kind” 
of region based on the base type.</li>
  <li>We have typed fields that have direction information attached to them.</li>
  <li>We have tagged a method with a <code class="language-plaintext highlighter-rouge">decorator</code> named “sync”. This identifies
the method as being evaluated with synchronous semantics.</li>
</ul>

<p>You might be asking how this is any different from a class library,
such as SystemC or pyuvm. This is exactly the right question to ask, since
it’s at the crux of how this approach is different.</p>

<h1 id="becoming-the-compiler">Becoming the Compiler</h1>

<p>If we were implementing the Zuspec library as a class library, we would have
each of the key elements above (Component, @sync, input, output) construct
a portion of a description that we could execute. For example, we might 
create an implementation to generate Verilog source. But, committing to 
an implementation is limiting. What if we, instead, wanted to test the 
Python model by simulating it in Python? We would probably need a 
different class library implementation. We’ll definitely want to use 
different implementations for different modules in the system across the
design cycle. Managing which class library implementation each module 
uses gets complicated very quickly.</p>

<p>How else can we approach this problem? Like a compiler, of course. And, Python’s
dynamic programming aspects make this much more straightforward than any other
language that I’m currently aware of.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/08/model_transform.png" /> 
</p>

<p>So, what does this look like?</p>
<ul>
  <li>Treat user input (Counter class above) as having no implementation</li>
  <li>Doing something with the input requires a transformation – a “compiler”</li>
  <li>Transformers take the user-specified class as input and return
    <ul>
      <li>Another Python class type</li>
      <li>A Python data structure with information about a non-Python implementation</li>
    </ul>
  </li>
</ul>

<p>Using this approach allows different transformations to be used for 
different modules in the design.</p>

<h1 id="anatomy-of-a-type-transformer">Anatomy of a Type Transformer</h1>

<p>Type transformers typically use the visitor pattern, using a visitor that
is aware of key elements of the domain-specific specification.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    class MyTransform(api.Visitor):
        _result : str = ""

        def transform(self, t) -&gt; str:
            self._result = ""
            self.visit(t)
            return self._result

        def visitComponentType(self, t):
            self.print("MyV.visitComponentType")
            return super().visitComponentType(t)
        
        def visitInput(self, f):
            self.print("visitInput: %s" % f.name)

        def visitOutput(self, f):
            self.print("visitOutput: %s" % f.name)

        def visitExec(self, name, e):
            self.print("visitExec: %s" % name)

        def print(self, m):
            self._result += m + "\n"</code></pre></figure>

<p>In this case, we’re simply transforming a type model into a string 
that displays the content of the model. But, we could use the same
approach to transform the type to Verilog. And, because the model 
is a specification without a class-library implementation, both
of these implementations (and more) can easily co-exist.</p>

<h1 id="next-steps">Next Steps</h1>

<p>In this post, we’ve looked at an approach to capturing hardware domain
semantics in Python such that we keep the description independent 
of the implementation in the same way a full-custom domain-specific
language does. Moving forward, we’ll focus on getting an implementation
path in place that will let us create Verilog and start to explore
some of the ways that capturing RTL in Python boosts our productivity.</p>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[A key benefit of full languages is having full control over processing the language: being the compiler. Having full control over language processing is exactly what enables us target simulation and FPGA bitstream with the same SystemVerilog source simply by specifying the same source to different toolchains. Fortunately, Python’s dynamic nature gives us all the tools we need to “become the compiler” for portions of the Python description that we care about. A Simple Counter Let’s start with an example. The code below represents the behavior of a very simple counter in Verilog: module counter( input clock, input reset, output reg[31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= {32{1'b0}}; end else begin count &lt;= count + 1; end end endmodule When we process this description to create an implementation, there are a few things that we need to know: The region of interest – what is a class, module, interface, etc? Data member types and kinds – local data vs port with directionality Logic/behavior inside the region and when it’s activated A Verilog-based tool establishes these key attributes by lexically processing the input text. Let’s create an equivalent representation in Python using our Zuspec library. import zuspec.dataclasses as zdc @zdc.dataclass class Counter(zdc.Component): clock : zdc.Bit = zdc.input() reset : zdc.Bit = zdc.input() count : zdc.Bit[32] = zdc.output() @zdc.sync(clock=lambda s:s.reset, reset=lambda s:s.clock): def inc(self): if self.reset: self.count = 0 else: self.count += 1 From one perspective, this is just a Python class that conforms to the Python’s syntactic and semantic rules. But, we’ve also encoded some special domain-specific information: The base class is Component. A processing tool can identify the “kind” of region based on the base type. We have typed fields that have direction information attached to them. We have tagged a method with a decorator named “sync”. This identifies the method as being evaluated with synchronous semantics. You might be asking how this is any different from a class library, such as SystemC or pyuvm. This is exactly the right question to ask, since it’s at the crux of how this approach is different. Becoming the Compiler If we were implementing the Zuspec library as a class library, we would have each of the key elements above (Component, @sync, input, output) construct a portion of a description that we could execute. For example, we might create an implementation to generate Verilog source. But, committing to an implementation is limiting. What if we, instead, wanted to test the Python model by simulating it in Python? We would probably need a different class library implementation. We’ll definitely want to use different implementations for different modules in the system across the design cycle. Managing which class library implementation each module uses gets complicated very quickly. How else can we approach this problem? Like a compiler, of course. And, Python’s dynamic programming aspects make this much more straightforward than any other language that I’m currently aware of. So, what does this look like? Treat user input (Counter class above) as having no implementation Doing something with the input requires a transformation – a “compiler” Transformers take the user-specified class as input and return Another Python class type A Python data structure with information about a non-Python implementation Using this approach allows different transformations to be used for different modules in the design. Anatomy of a Type Transformer Type transformers typically use the visitor pattern, using a visitor that is aware of key elements of the domain-specific specification. class MyTransform(api.Visitor): _result : str = "" def transform(self, t) -&gt; str: self._result = "" self.visit(t) return self._result def visitComponentType(self, t): self.print("MyV.visitComponentType") return super().visitComponentType(t) def visitInput(self, f): self.print("visitInput: %s" % f.name) def visitOutput(self, f): self.print("visitOutput: %s" % f.name) def visitExec(self, name, e): self.print("visitExec: %s" % name) def print(self, m): self._result += m + "\n" In this case, we’re simply transforming a type model into a string that displays the content of the model. But, we could use the same approach to transform the type to Verilog. And, because the model is a specification without a class-library implementation, both of these implementations (and more) can easily co-exist. Next Steps In this post, we’ve looked at an approach to capturing hardware domain semantics in Python such that we keep the description independent of the implementation in the same way a full-custom domain-specific language does. Moving forward, we’ll focus on getting an implementation path in place that will let us create Verilog and start to explore some of the ways that capturing RTL in Python boosts our productivity.]]></summary></entry><entry><title type="html">Re-Evaluating EDA DSLs in the AI Era</title><link href="https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era.html" rel="alternate" type="text/html" title="Re-Evaluating EDA DSLs in the AI Era" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era</id><content type="html" xml:base="https://bitsbytesgates.com/zuspec/2025/08/18/ReEvaluating_EDA_DomainSpecificLanguages_in_AI_Era.html"><![CDATA[<p>I’ve been looking for a new hardware-centric design language for the last couple of years. 
Or, more precisely, I’ve been looking for a hardware-centric design language that would
allow me to realize my ideal silicon design flow.</p>
<ul>
  <li>Must support using the same language to refine a design through a series of abstraction levels – from architecture down to RTL</li>
  <li>Must support fast iteration by supporting both dynamic/executable and static/formal/symbolic evaluation of the same description</li>
  <li>Must support capturing the test, verification, and firmware aspects of a design in addition to the hardware.</li>
  <li>Must be interoperable with existing design flows and environments</li>
</ul>

<p>Until recently, I’ve assumed that a dedicated domain-specific language would be required
to meet these requirements. However, some new observations about languages and 
large language models, coupled with some technical learning has me seeing a different 
path forward for my little project – as well as for future EDA domain-specific languages.</p>

<!-- more -->

<h1 id="why-eda-domain-specific-languages">Why EDA Domain-Specific Languages?</h1>
<p>If you work in silicon design, you’re very familiar with a set of domain-specific languages (DSLs),
such as SystemVerilog and VHDL,  that are used to specify a model of your design intent, 
verify its logical correctness, and synthesize it to a gate-level representation that can
be programmed onto an FPGA or fabricated as an ASIC. These languages exist precisely because 
of the domain (hardware)-specific semantics that we need to capture, and how distinct 
those semantics are from those captured by software languages.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">module counter(
    input clock, reset, enable,
    output reg [31:0] count);

  always @(posedge clock or posedge reset) begin
    if (reset) begin
      count &lt;= 0;
    end else if (enable) begin
      count &lt;= count + 1;
    end
  end
endmodule</code></pre></figure>

<p>Even a simple counter, like the code above, highlights some of the key semantics
unique to hardware.</p>
<ul>
  <li>implicit entrypoint – nothing “calls” the always block</li>
  <li>parallel evaluation – always blocks run concurrently</li>
  <li>synchronized assignment – the new value of ‘count’ doesn’t take effect immediately</li>
</ul>

<p>Typical implementation, such as an event-driven simulator, is very different from 
how this code would be evaluated if it was written in a software language. Having a
language that directly captures the semantics of synchronous digital logic makes us
much more productive.</p>

<p>There certainly are advantages to this approach of creating specific languages for
capturing hardware semantics. We can use whatever syntax we find to most-accurately
convey the semantics that we’re capturing – for example, using ‘&lt;=’ above to denote
an assignment that doesn’t take effect immediately. Having a full, bespoke, language 
also often encourages new applications for the language. For example, Verilog started
off as a simulation language. It was only later that tools started to synthesize
gates from a Verilog description.</p>

<h1 id="the-cost-of-eda-domain-specific-languages">The Cost of EDA Domain-specific Languages</h1>
<p>For all the benefits of having full EDA domain-specific languages, there are 
significant drawbacks.</p>

<p>For one, the cost of designing such a language is high 
precisely because we often want to have standard software features and semantics
alongside our hardware-specific semantics. Creating a whole language necessitates
designing all the details – not just the ones that we’re most interested in 
as hardware designers.</p>

<p>When it comes to languages, community and popularity matter. Community and popularity
lead to tools and libraries built around the language, and people talking about 
how to accomplish things with a language. As hardware designers, 
we represent a very small group compared to the much larger community of software 
engineers. A keynote speaker at DAC this year cited a statistic that the number of 
hardware engineers (inclusive of all disciplines) was less than 10% the number of 
software engineers. Even a language that is wildly popular among hardware engineers
would still be considered a niche language in the broader industry.</p>

<p>Generative AI and LLMs are driving what appears to be a consolidation around 
popular languages recently. In their <a href="https://www.tiobe.com/tiobe-index/">August report</a>, TIOBE (software security analysts, that also track langauge popularity) note a strong
increase in the popularity of Python driven by the proficiency of AI assistants with
Python. Given the cost of training a large language model (LLM), language popularity is likely to become a self-reinforcing pattern: increasing popularity leads to better 
results from LLMs, which further increases the popularity of a language.</p>

<h1 id="alterative-approaches">Alterative Approaches</h1>

<p>Over the years, at least two alternatives to a full domain-specific language have been
used: class libraries and embedded domain-specific languages.</p>

<h2 id="class-libraries">Class Libraries</h2>

<p>A class library is the lightest-weight approach to capturing domain-specific semantics.
In this approach, the host language is used as-is and domain-specific semantics are
captured by creating instances of classes and calling methods from the class library.
Both UVM and SystemC Follow the class-library approach to domain-specific semantics.</p>

<p>This approach encounters challenges when the semantics to be captured run counter to
the host language, or the host language doesn’t support capturing them. For example,
introspecting the value of class fields is of high interest in both SystemC and UVM. 
UVM uses a special set of macros to register user-defined class fields with the 
library.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">class ABC extends uvm_object;
	rand bit [15:0] 	m_addr;
	rand bit [15:0] 	m_data;

	`uvm_object_utils_begin(ABC)
		`uvm_field_int(m_addr, UVM_DEFAULT)
		`uvm_field_int(m_data, UVM_DEFAULT)
	`uvm_object_utils_end
endclass</code></pre></figure>

<p>Exposing access to fields in this way is both a bit cumbersome for the user,
and quite possibly computationally inefficiency because the implementation
must cover so many cases in a generic fashion.</p>

<p>Class libraries also tend to be tightly locked to the their host language
for evaluation. Because a processing tool isn’t able to look at the
structure of user-defined functions, there isn’t an opportunity to represent
them in a different language. If a class library-based description needs to 
target a different language, it typically will build an internal data 
model based on running the model and generate code from that data model.</p>

<h2 id="embedded-domain-specific-languages">Embedded Domain-Specific Languages</h2>

<p>If a class library is insufficient to capture the semantics we require, another
approach is to create an embedded domain-specific language (eDSL) using a language
feature called operator overloading. Not all languages support operator overloading
– for example, SystemVerilog does not. For those that do, operator overloading 
allows us to redefine the implementation of standard operators in specific cases.
This can allow us to create the illusion of writing a different language inside
the confines of our host language.</p>

<p><a href="https://systemc.org/overview/systemc-verification/">SystemC Verification (SCV) library</a> 
provides one example of using operator 
overloading to capture random constraints. The PyVSC library offers another.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    @vsc.constraint
    def ab_c(self):
       self.a &gt; self.b</code></pre></figure>

<p>Python is feature-rich when it comes to operator overloading. The constraint
above looks exactly how you would intuitively expect a ‘greater-than’ constraint
to look. But there are limits.</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">    @vsc.constraint
    def ab_c(self):
        self.a == 5

        with vsc.if_then(self.a == 1):
            self.b == 1
        with vsc.else_if(self.a == 2):
            self.b == 2</code></pre></figure>

<p>Python doesn’t allow us to override statements, so we need to invent a new
way of capturing constraint statements like if/elsif/else.</p>

<p>Furthermore, Python doesn’t allow us to override some operators. So, we need
to invent another way of capturing logical <code class="language-plaintext highlighter-rouge">and</code>, logical <code class="language-plaintext highlighter-rouge">or</code>, and the <code class="language-plaintext highlighter-rouge">in</code>
operator.</p>

<p>Finally, the code above doesn’t really <em>look</em> like good Python code. Tools
like linters are likely to complain. LLMs will also not know how to create
this content unless specially prompted.</p>

<h1 id="back-to-python">Back to Python</h1>

<p>So, where does that leave us? Well, until recently, right back to needing a full language to
satisfy the requirements. But, as it turns out, Python has a few more features to offer.</p>

<p>Unlike many languages, Python supports introspecting and rewriting code at the <a href="https://docs.python.org/3/library/ast.html">abstract 
syntax tree (AST) level</a>. This feature is mostly
used by linting tools, but is also used by the <a href="https://docs.pytest.org/en/stable/">Pytest</a> 
tool to provide more detail about assertions that fail.</p>

<p>This suggests a new way to look at a Python description:</p>

<figure class="highlight"><pre><code class="language-python3" data-lang="python3">class MyClass(vsc.RandClass):
    a : vsc.rand[vsc.bit[32]]
    b : vsc.rand[vsc.bit[32]]

    @vsc.constraint
    def ab_c(self):
        self.a == 5

        if self.a == 1:
            self.b == 1
        elif self.a == 2:
            self.b == 2</code></pre></figure>

<p>Specifically, all syntax is plain Python syntax – no operator overloading that might
confuse linters or LLMs. We still can use markers, such as base classes and 
decorators, to identify special regions where the semantics differ from plain 
Python execution. For example, the @vsc.constraint decorator marks a method that
contains constraints. Instead of executing these regions to build up a data structure,
we simply use Python’s AST introspection to build the data structure directly.
This allows us to leverage Python syntax, and all the tools that understand it, while
layering our own special semantics on top.</p>

<h1 id="next-steps">Next Steps</h1>

<p>As I mentioned at the beginning of this post, my key interest is in having a modeling
language that supports capturing very abstraction descriptions of hardware behavior
all the way to RTL. While I could start with any of the abstraction levels, I’ve 
decided to start with RTL because that’s where all abstraction levels eventually end 
up. We’ll start looking at a Python-encapsulated description of RTL in the next post.</p>]]></content><author><name></name></author><category term="Zuspec" /><summary type="html"><![CDATA[I’ve been looking for a new hardware-centric design language for the last couple of years. Or, more precisely, I’ve been looking for a hardware-centric design language that would allow me to realize my ideal silicon design flow. Must support using the same language to refine a design through a series of abstraction levels – from architecture down to RTL Must support fast iteration by supporting both dynamic/executable and static/formal/symbolic evaluation of the same description Must support capturing the test, verification, and firmware aspects of a design in addition to the hardware. Must be interoperable with existing design flows and environments Until recently, I’ve assumed that a dedicated domain-specific language would be required to meet these requirements. However, some new observations about languages and large language models, coupled with some technical learning has me seeing a different path forward for my little project – as well as for future EDA domain-specific languages. Why EDA Domain-Specific Languages? If you work in silicon design, you’re very familiar with a set of domain-specific languages (DSLs), such as SystemVerilog and VHDL, that are used to specify a model of your design intent, verify its logical correctness, and synthesize it to a gate-level representation that can be programmed onto an FPGA or fabricated as an ASIC. These languages exist precisely because of the domain (hardware)-specific semantics that we need to capture, and how distinct those semantics are from those captured by software languages. module counter( input clock, reset, enable, output reg [31:0] count); always @(posedge clock or posedge reset) begin if (reset) begin count &lt;= 0; end else if (enable) begin count &lt;= count + 1; end end endmodule Even a simple counter, like the code above, highlights some of the key semantics unique to hardware. implicit entrypoint – nothing “calls” the always block parallel evaluation – always blocks run concurrently synchronized assignment – the new value of ‘count’ doesn’t take effect immediately Typical implementation, such as an event-driven simulator, is very different from how this code would be evaluated if it was written in a software language. Having a language that directly captures the semantics of synchronous digital logic makes us much more productive. There certainly are advantages to this approach of creating specific languages for capturing hardware semantics. We can use whatever syntax we find to most-accurately convey the semantics that we’re capturing – for example, using ‘&lt;=’ above to denote an assignment that doesn’t take effect immediately. Having a full, bespoke, language also often encourages new applications for the language. For example, Verilog started off as a simulation language. It was only later that tools started to synthesize gates from a Verilog description. The Cost of EDA Domain-specific Languages For all the benefits of having full EDA domain-specific languages, there are significant drawbacks. For one, the cost of designing such a language is high precisely because we often want to have standard software features and semantics alongside our hardware-specific semantics. Creating a whole language necessitates designing all the details – not just the ones that we’re most interested in as hardware designers. When it comes to languages, community and popularity matter. Community and popularity lead to tools and libraries built around the language, and people talking about how to accomplish things with a language. As hardware designers, we represent a very small group compared to the much larger community of software engineers. A keynote speaker at DAC this year cited a statistic that the number of hardware engineers (inclusive of all disciplines) was less than 10% the number of software engineers. Even a language that is wildly popular among hardware engineers would still be considered a niche language in the broader industry. Generative AI and LLMs are driving what appears to be a consolidation around popular languages recently. In their August report, TIOBE (software security analysts, that also track langauge popularity) note a strong increase in the popularity of Python driven by the proficiency of AI assistants with Python. Given the cost of training a large language model (LLM), language popularity is likely to become a self-reinforcing pattern: increasing popularity leads to better results from LLMs, which further increases the popularity of a language. Alterative Approaches Over the years, at least two alternatives to a full domain-specific language have been used: class libraries and embedded domain-specific languages. Class Libraries A class library is the lightest-weight approach to capturing domain-specific semantics. In this approach, the host language is used as-is and domain-specific semantics are captured by creating instances of classes and calling methods from the class library. Both UVM and SystemC Follow the class-library approach to domain-specific semantics. This approach encounters challenges when the semantics to be captured run counter to the host language, or the host language doesn’t support capturing them. For example, introspecting the value of class fields is of high interest in both SystemC and UVM. UVM uses a special set of macros to register user-defined class fields with the library. class ABC extends uvm_object; rand bit [15:0] m_addr; rand bit [15:0] m_data; `uvm_object_utils_begin(ABC) `uvm_field_int(m_addr, UVM_DEFAULT) `uvm_field_int(m_data, UVM_DEFAULT) `uvm_object_utils_end endclass Exposing access to fields in this way is both a bit cumbersome for the user, and quite possibly computationally inefficiency because the implementation must cover so many cases in a generic fashion. Class libraries also tend to be tightly locked to the their host language for evaluation. Because a processing tool isn’t able to look at the structure of user-defined functions, there isn’t an opportunity to represent them in a different language. If a class library-based description needs to target a different language, it typically will build an internal data model based on running the model and generate code from that data model. Embedded Domain-Specific Languages If a class library is insufficient to capture the semantics we require, another approach is to create an embedded domain-specific language (eDSL) using a language feature called operator overloading. Not all languages support operator overloading – for example, SystemVerilog does not. For those that do, operator overloading allows us to redefine the implementation of standard operators in specific cases. This can allow us to create the illusion of writing a different language inside the confines of our host language. SystemC Verification (SCV) library provides one example of using operator overloading to capture random constraints. The PyVSC library offers another. @vsc.constraint def ab_c(self): self.a &gt; self.b Python is feature-rich when it comes to operator overloading. The constraint above looks exactly how you would intuitively expect a ‘greater-than’ constraint to look. But there are limits. @vsc.constraint def ab_c(self): self.a == 5 with vsc.if_then(self.a == 1): self.b == 1 with vsc.else_if(self.a == 2): self.b == 2 Python doesn’t allow us to override statements, so we need to invent a new way of capturing constraint statements like if/elsif/else. Furthermore, Python doesn’t allow us to override some operators. So, we need to invent another way of capturing logical and, logical or, and the in operator. Finally, the code above doesn’t really look like good Python code. Tools like linters are likely to complain. LLMs will also not know how to create this content unless specially prompted. Back to Python So, where does that leave us? Well, until recently, right back to needing a full language to satisfy the requirements. But, as it turns out, Python has a few more features to offer. Unlike many languages, Python supports introspecting and rewriting code at the abstract syntax tree (AST) level. This feature is mostly used by linting tools, but is also used by the Pytest tool to provide more detail about assertions that fail. This suggests a new way to look at a Python description: class MyClass(vsc.RandClass): a : vsc.rand[vsc.bit[32]] b : vsc.rand[vsc.bit[32]] @vsc.constraint def ab_c(self): self.a == 5 if self.a == 1: self.b == 1 elif self.a == 2: self.b == 2 Specifically, all syntax is plain Python syntax – no operator overloading that might confuse linters or LLMs. We still can use markers, such as base classes and decorators, to identify special regions where the semantics differ from plain Python execution. For example, the @vsc.constraint decorator marks a method that contains constraints. Instead of executing these regions to build up a data structure, we simply use Python’s AST introspection to build the data structure directly. This allows us to leverage Python syntax, and all the tools that understand it, while layering our own special semantics on top. Next Steps As I mentioned at the beginning of this post, my key interest is in having a modeling language that supports capturing very abstraction descriptions of hardware behavior all the way to RTL. While I could start with any of the abstraction levels, I’ve decided to start with RTL because that’s where all abstraction levels eventually end up. We’ll start looking at a Python-encapsulated description of RTL in the next post.]]></summary></entry><entry><title type="html">PSS: Getting Outside the Box</title><link href="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html" rel="alternate" type="text/html" title="PSS: Getting Outside the Box" /><published>2025-02-11T00:00:00+00:00</published><updated>2025-02-11T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/11/PSS_GettingOutsideTheBox.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSGettingOutsideTheBox_splash.png" /> 
</p>

<p>In the <a href="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html">last post</a>, 
we showed a SystemVerilog implementation of a PSS model
that printed “Hello World!”. Interesting, perhaps, but quite a ways from 
being useful. In order to be useful, our PSS model needs to interact with
the environment surrounding it.</p>

<p>This post will cover more details about how a PSS model interacts with 
the environment around it, and look at an object-oriented interface between
PSS and a SystemVerilog environment.</p>

<!--more-->

<p>Both PSS and SystemVerilog are object-oriented languages. With language
interoperability, our goal is to keep each language’s view of inteacting
with the “other” consistent with its own norms and conventions. Because
both languages are object-oriented, we want SystemVerilog to see its
interactions with PSS in object-oriented terms, and vice versa.</p>

<p>While we’re looking at an API in the context of our Zuspec PSS to SystemVerilog
transpiler, the goal is to define a language interoperability approach that
will work with many PSS tools.</p>

<p>Essentially, what we want is this:</p>
<div class="mermaid" align="center">
flowchart TD
    subgraph Model1 ["PSS Model1"]
      BFM1_1["BFM1"]
      BFM1_2["BFM2"]
    end
    subgraph Model2 ["PSS Model2"]
      BFM2_1["BFM1"]
      BFM2_2["BFM2"]
    end

    subgraph Sim ["Simulation"]
      BFM1
      BFM2
      BFM3
      BFM4
    end
    Model1 --&gt; Sim
    Model2 --&gt; Sim

</div>

<p>In other words, we want an integration mechanism that supports:</p>
<ul>
  <li>Multiple, independent, instances of PSS model implementations that run concurrently.</li>
  <li>Multiple “logical streams” within each PSS model instance that
interact with the SystemVerilog testbench</li>
</ul>

<p>The biggest obstacle to achieving this is that both PSS and SystemVerilog
use global functions to implement interactions with the outside world. 
Global functions do not allow us to leverage object-oriented language constructs, so 
we will need to add some infrastructure on top.</p>

<h1 id="the-basics">The Basics</h1>
<p>PSS provides <code class="language-plaintext highlighter-rouge">import</code> functions to allow the PSS model to interact 
with the outside world.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">bfm_c</span> <span class="p">{</span>
  <span class="kd">action</span> <span class="nc">write</span> <span class="p">{</span>
    <span class="c1">// </span>
    <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
      <span class="n">bfm_write</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above, two functions are declared – one to perform
a read via a BFM, and one to perform a write. These are global
functions, accessible from all PSS contexts.</p>

<p>The PSS LRM specifies how function parameter and return types are 
mapped to SystemVerilog and C. Theoretically, we could map
the functions themselves to <code class="language-plaintext highlighter-rouge">export</code> tasks and functions
in SystemVerilog.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">interface bfm;
  automatic task bfm_write(int unsigned addr, int unsigned data);
  endtask
  export "DPI-C" task bfm_write;

  automatic task bfm_read(output int unsigned data, input int unsigned addr);
  endtask
  export "DPI-C" task bfm_read;

endinterface</code></pre></figure>

<p>The example above shows SystemVerilog <code class="language-plaintext highlighter-rouge">export</code> tasks that mirror the
PSS <code class="language-plaintext highlighter-rouge">import</code> functions. Conceptually, calling <code class="language-plaintext highlighter-rouge">bfm_write</code> in PSS
would translate into a call to the <code class="language-plaintext highlighter-rouge">bfm_write</code> task in SystemVerilog. 
If we do that, though, we have no awareness of multiple PSS model
instances, and little implementation flexibility.  Fortunately, a 
little methodology and a little code generation can help us
get the object-oriented interfaces that we want!</p>

<h2 id="introducing-the-api-class">Introducing the API Class</h2>
<p>Zuspec-SV (our PSS to SV transpiler) defines an Import API class that
contains a virtual method definition for each and every Import function
in the PSS model.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">class pss_import_api extends backend_api;
   
  virtual task bfm_write(int unsigned addr, int unsigned data);
  endtask

  virtual task bfm_read(output int unsigned data, input int unsigned addr);
  endtask

endclass</code></pre></figure>

<p>The code above shows what would be produced for the <code class="language-plaintext highlighter-rouge">bfm_write</code> and
<code class="language-plaintext highlighter-rouge">bfm_read</code> functions shown earlier. The <code class="language-plaintext highlighter-rouge">import</code> API class inherits
from another API class that defines built-in functions that the PSS
model needs to access. Implementing the API can be done simply by
creating a class that inherits from <code class="language-plaintext highlighter-rouge">pss_import_api</code> and providing
implementations of the tasks and functions.</p>

<h2 id="connecting-our-api-implementation">Connecting our API Implementation</h2>
<p>Once we have a SystemVerilog class with properly-implemented methods, 
we need to connect the PSS model implementation to it. This is where
things get a bit tool-specific.</p>

<p>PSS defines a scenario model as the combination of a tree of 
<em>components</em> and a hierarchy of <em>actions</em> that execute in the
context of the components. <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> refers to this 
component/action combination as an <em>Actor</em>. An <em>Actor</em> is 
implemented as a class that accepts the import API class 
as an argument to its constructor.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_top__Entry_actor extends actor_c;
        pss_top comp_tree;
        pss_import_api api;
        executor_base_c default_executor;

        function new(pss_import_api api=null);
           ...
        endfunction
      ...
    endclass</code></pre></figure>

<p>As we saw in the <em>Hello World</em> example, we run a PSS model
by creating an instance of the <em>Actor</em> and calling the
<em>run</em> task.</p>

<h2 id="full-example">Full Example</h2>
<p>Let’s take a step-by-step look at the simple API implementation example
in <code class="language-plaintext highlighter-rouge">zuspec-examples</code>. You can find the full example 
<a href="https://github.com/zuspec/zuspec-examples/tree/main/sv/simple_read_write">here</a>.</p>

<p>If you want to try this example yourself, be sure to update your <code class="language-plaintext highlighter-rouge">Zuspec-SV</code>
version. You can do so in the <code class="language-plaintext highlighter-rouge">zuspec-examples</code> project by running the
following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% ./packages/python/bin/pip install -U zuspec-sv
</code></pre></div></div>

<p>You will need at least version 0.0.9 to run this example.</p>

<p>Let’s start with the PSS code:</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">void</span> <span class="n">bfm_write</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">);</span>
<span class="k">import</span> <span class="k">target</span> <span class="k">function</span> <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">bfm_read</span><span class="p">(</span><span class="k">input</span> <span class="kt">bit</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">addr</span><span class="p">);</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>

    <span class="kd">action</span> <span class="nc">Entry</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="kt">bit</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">bfm_write</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">);</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">bfm_read</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"PSS read data %d"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We declare two import functions – one that writes data via a bus functional 
model (BFM), and one that reads data via a bus functional model.</p>

<p>We then declare a (very) simple PSS Action that calls the <code class="language-plaintext highlighter-rouge">write</code> function
twice, calls the <code class="language-plaintext highlighter-rouge">read</code> function once, and displays the return value.</p>

<h3 id="implementing-the-api">Implementing the API</h3>

<p><code class="language-plaintext highlighter-rouge">Zuspec-SV</code> creates the following API class based on the import functions
declared within the PSS model:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">    class pss_import_api #(type BaseT=zsp_sv::empty_t) extends backend_api #(BaseT);
        virtual task bfm_write(
                input int unsigned addr,
                input int unsigned data);
            `ZSP_FATAL(("Import function bfm_write is not implemented"));
        endtask
        virtual task bfm_read(
                output int unsigned __retval,
                input int unsigned addr);
            `ZSP_FATAL(("Import function bfm_read is not implemented"));
        endtask
    endclass</code></pre></figure>

<p>Note that the signature of the <code class="language-plaintext highlighter-rouge">bfm_read</code> task is a bit different. This 
is because SystemVerilog tasks do not support a return value, so the
result must be returned via an output parameter. Fortunately, this is
all well-defined by the rules in the PSS LRM.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">package simple_read_write_pkg;
    import pss_types::*;

    class api_impl extends pss_import_api;
        virtual task bfm_write(
            input int unsigned addr,
            input int unsigned data);
            $display("bfm_write: 'h%08h 'h%08h", addr, data);
        endtask

        virtual task bfm_read(
            output int unsigned __retval,
            input int unsigned addr);
            $display("bfm_read: 'h%08h", addr);
            __retval = 42;
        endtask
    endclass

endpackage</code></pre></figure>

<p>Our testbench environment is responsible for providing code, like 
that shown above, to provide an implementation for the import functions.
Our implementation, here, is quite simple: We print a message when either 
task is called, and return the value <code class="language-plaintext highlighter-rouge">42</code> from the <code class="language-plaintext highlighter-rouge">read</code> function.</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module simple_read_write;
    import simple_read_write_pkg::*;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic api_impl api = new();
        pss_top__Entry actor = new(api);

        actor.run();
    end
endmodule</code></pre></figure>

<p>Finally, we can put everything together and run our PSS model. The 
code above creates an instance of our implementation of the API 
class, and passes it to the constructor of our PSS <code class="language-plaintext highlighter-rouge">Actor</code> class.
When we run the simulation, we should see something like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bfm_write: 'h00000000 'h12345678
bfm_write: 'h00000004 'h12345678
bfm_read: 'h00000004
PSS read data 42
</code></pre></div></div>

<h1 id="summary-and-whats-next">Summary and What’s Next</h1>
<p>We’ve looked at the funadamentals of a strategy to integrate two 
object-oriented languages, via global functions, 
in an object-oriented way. This approach
gives us flexibility in changing how APIs are implemented using 
the standard object-oriented approaches that we’re used to.</p>

<p>But, we’re not done just yet. You can likely imagine how this 
approach supports multiple indepdent PSS model instances. But,
how does it support API implementations coming from different
sources, and multiple independent streams of activity within
one PSS model? In the next post, we’ll start to dig into how
to interface PSS to verifcation IP (VIP) and bus functional models (BFMs).</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[In the last post, we showed a SystemVerilog implementation of a PSS model that printed “Hello World!”. Interesting, perhaps, but quite a ways from being useful. In order to be useful, our PSS model needs to interact with the environment surrounding it. This post will cover more details about how a PSS model interacts with the environment around it, and look at an object-oriented interface between PSS and a SystemVerilog environment.]]></summary></entry><entry><title type="html">Transpilation and PSS</title><link href="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html" rel="alternate" type="text/html" title="Transpilation and PSS" /><published>2025-02-04T00:00:00+00:00</published><updated>2025-02-04T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2025/02/04/Transpilation_and_PSS.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2025/02/PSSTranspilation_splash.png" /> 
</p>

<p>You’re probably familiar with compilers. They take a high-level input description – 
typically a programming language – and distill it down to an efficient 
low-level implementation. Typically the implementation is machine code or 
bytecode. In other words, as close as possible to what will actually execute 
given the language ecosystem.</p>

<p>You might be less familiar with transpilers (or 
source-to-source compilers, as they are <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">also known</a>). Transpilers convert
an input in one programming language to output in another programming language
with a similar level of abstraction. Transpilers have been in use for a very 
long time. For example, the C++ language was originally implemented with 
<a href="https://en.wikipedia.org/wiki/Cfront">Cfront</a>, a transpiler that converted
C++ input to C code that any C compiler could process. More recently, the 
<a href="https://www.typescriptlang.org/">Typescript</a> and 
<a href="https://en.wikipedia.org/wiki/ECMAScript">Javascript/ECMAScript</a> ecosystems
have used transpilation extensively to allow the languages to evolve while
maintaining an impressive level of backward compatibility with older 
implementations of the language.</p>

<p>The next few posts will start to explore what we can do by transpiling
test scenarios in PSS into implementations in existing programming languages.</p>

<!--more-->

<h1 id="is-pss-a-programming-language">Is PSS a Programming Language?</h1>
<p>Both compilers and transpilers are software concepts, so it’s worth asking
whether PSS language is a programming language. Portions of the language 
do provide the features of a standard programming language – if/else,
loops, functions, and data structures. In this portion of the language,
these constructs retain the same <em>imperative</em> semantics as the 
equivalent constructs in software programming languages.</p>

<p>The other major portion of the language has <em>declarative</em> semantics.
This means that we focus on capturing the <em>rules</em> of our test scenarios
instead of capturing how we will <em>implement</em> our test scenarios.</p>

<h2 id="why-be-declarative">Why be declarative?</h2>

<p>Take, for example, test scenarios that exercise a multi-channel DMA
controller. When our test exercises multiple channels at the same
time, it needs to use unique channels. With PSS, we can simply 
state that this is a rule: DMA channels are <em>resources</em> that 
can only be used by a single behavior at a time.</p>

<p>In contrast, if we are writing our tests in a regular programming 
language, we would need to design a channel-allocation algorithm 
to manage DMA channels for our tests. Actually, we would
probably need several algorithms to handle all the corner cases
that our tests need to cover.</p>

<p>The declarative nature of the PSS language increases our testing
productivity by allowing us to capture the rules of our scenarios
and automate the work of implementing tests.</p>

<h1 id="creating-model-implementations">Creating Model Implementations</h1>
<p>Capturing tests in this way has huge productivity benefits. It also
has a (subjective) downside: we need to use a <em>constraint solver</em> 
to evaluate the model and select the data and operation schedule 
that will be used to exercise the design. Constraints solvers are 
marvelous tools for ripping through reams of constraints, but 
they’re not considered <em>fast</em> when compared to the execution speed 
of regular procedural programming languages. In addition, 
constraint solvers typically require substantial resources to run.</p>

<p>This need to <em>solve</em> the PSS model to generate specific tests, 
along with different verification-platform characteristics,
has resulted in two common ways to produce tests from a PSS model:</p>

<ul>
  <li><strong>On-the-Fly Solving</strong> - This model is typically used in simulation.
A special PSS interpreter and constraint solver run in parallel with
the simulation and make choices as they are needed.</li>
  <li><strong>Pre-Run Test Generation</strong> - This model is typically used when 
the test will run on a processor core within the design. In this model,
the entire test is produced as source code prior to the start of 
test execution.  We want to keep the code that runs on the processor 
core simple for many reasons, and pre-solving the PSS model allows 
us to do this.</li>
</ul>

<p>Both of these models are useful and important, but the on-the-fly
model is very interesting because it suggests that we might be able
to leverage the constraint solver within our SystemVerilog simulators
to provide the solving needed to evaluate our PSS models.</p>

<h1 id="transpiling-pss-to-systemverilog">Transpiling PSS to SystemVerilog</h1>
<p>I’ve been working PSS infrastructure, in general, for a while. More
recently, I’ve focused on using that infrastructure to implement the
beginnings of a PSS to SystemVerilog transpiler.</p>

<p>The general flow is shown below.</p>

<div class="mermaid" align="center">
block-beta
%% columns 5
  block:Source
    columns 1
    PssFiles["PSS Files"]
    Files1
    Files2
    Files3
    Files["PSS Source"]
    style Files1 fill:transparent,stroke:transparent,color:transparent
    style Files2 fill:transparent,stroke:transparent,color:transparent
    style Files3 fill:transparent,stroke:transparent,color:transparent
    style Files fill:transparent,stroke:transparent
  end
  block:Pkgs
    columns 1
    ScenarioPkg["Scenario-Specific Types"]
    ModelPkg["Model-Specific Shared Types"]
    Spacer1
    Spacer2
    Spacer3["Generated SV"]
    style Spacer1 fill:transparent,stroke:transparent,color:transparent
    style Spacer2 fill:transparent,stroke:transparent,color:transparent
    style Spacer3 fill:transparent,stroke:transparent
  end
  block:Runtime
    columns 1
    ScenarioPkg2["Scenario-Specific Types"]
    ModelPkg2["Model-Specific Shared Types"]
    ClassLib["Shared Class Library"]
    SVSolver["SystemVerilog Runtime"]
    Runtime1["Runtime"]
    style Runtime1 fill:transparent,stroke:transparent
  end
  Source--&gt;Pkgs
  Pkgs--&gt;Runtime
</div>

<p>Specifically:</p>
<ul>
  <li>The <a href="https://github.com/zuspec/zuspec-sv/">Zuspec-SV</a> tool processes the PSS model 
source to produce an implementation 
for an Action</li>
  <li>It produces two SystemVerilog packages. The first contains types specific to the action 
being implemented. The second contains types shared across all actions captured in the model</li>
  <li>These packages are compiled along with a supporting class library and the user’s testbench,
and executed by a SystemVerilog simulator.</li>
</ul>

<h1 id="a-simple-example">A simple example</h1>

<p>Let’s take a look at a tiny example from the 
<a href="https://github.com/zuspec/zuspec-examples">Zuspec Examples</a> project.</p>

<figure class="highlight"><pre><code class="language-pss" data-lang="pss"><span class="k">import</span> <span class="nn">std_pkg</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="kd">component</span> <span class="nc">pss_top</span> <span class="p">{</span>
    <span class="kd">action</span> <span class="nc">Hello</span> <span class="p">{</span>
        <span class="k">exec</span> <span class="k">body</span> <span class="p">{</span>
            <span class="n">message</span><span class="p">(</span><span class="n">LOW</span><span class="p">,</span> <span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>You can find the soure <a href="https://github.com/zuspec/zuspec-examples/blob/main/sv/hello_world/hello_world.pss">here</a>.</p>

<p>This extremely-simple PSS model prints ‘Hello World!’ to the simulation log.</p>

<p>Have a look at the root SystemVerilog module to see how the SystemVerilog
model implementation is invoked:</p>

<figure class="highlight"><pre><code class="language-systemverilog" data-lang="systemverilog">module top;
    import pss_top__Entry_pkg::*;

    initial begin
        automatic pss_top__Entry actor = new();
        actor.run();
        $finish;
    end

endmodule</code></pre></figure>

<h1 id="where-do-we-go-from-here">Where do we go from here?</h1>

<p>Transpiling PSS to SystemVerilog provides a useful interesting implementation 
option for PSS, both because of the solver within the simulator and because
PSS is frequently used with UVM testbenches.</p>

<p>If you’re interested in trying out the PSS ‘Hello World’ example, have a look
at the instructions in the 
<a href="https://github.com/zuspec/zuspec-examples/blob/main/README.md">README</a> file.</p>

<p>The <code class="language-plaintext highlighter-rouge">Zuspec-SV</code> transpiler is under active development, but the approach 
looks very promising.  Over the next few posts, we’ll have  look at 
additional PSS constructs that we can implement in SystemVerilog and,
more importantly, see how PSS interacts the testbench and design.</p>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[You’re probably familiar with compilers. They take a high-level input description – typically a programming language – and distill it down to an efficient low-level implementation. Typically the implementation is machine code or bytecode. In other words, as close as possible to what will actually execute given the language ecosystem. You might be less familiar with transpilers (or source-to-source compilers, as they are also known). Transpilers convert an input in one programming language to output in another programming language with a similar level of abstraction. Transpilers have been in use for a very long time. For example, the C++ language was originally implemented with Cfront, a transpiler that converted C++ input to C code that any C compiler could process. More recently, the Typescript and Javascript/ECMAScript ecosystems have used transpilation extensively to allow the languages to evolve while maintaining an impressive level of backward compatibility with older implementations of the language. The next few posts will start to explore what we can do by transpiling test scenarios in PSS into implementations in existing programming languages.]]></summary></entry><entry><title type="html">What’s Next for PSS?</title><link href="https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext.html" rel="alternate" type="text/html" title="What’s Next for PSS?" /><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext</id><content type="html" xml:base="https://bitsbytesgates.com/pss/2024/12/15/PSS_WhatsNext.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/PSSFuture_splash.png" /> 
</p>

<p>As the year winds down, it’s a good time to think about the coming year and the
areas where I’d like to have an impact. One area of particular
interest this year is the Portable Test and Stimulus (PSS) standard. The Accellera 
PSS working group released the 3.0 version of the PSS LRM in August, and I’ve felt
fortunate to have been involved with PSS Working Group (PSWG) from its inception,
and to see how the growing body of features in PSS have allowed the language to 
enable test-content portability across simulation, emulation, and post-silicon
targets.</p>

<p>The release of PSS 3.0 also provides an opportunity to step back and consider 
the future of PSS – not just incremental additions to its current field of use,
but also how its use could expand to other portions of the design and verification process.</p>

<!--more-->

<p>Today, the PSS language provides powerful features for capturing test 
scenarios. It’s particularly adept at capturing IP programming sequences
that are reusable from IP to system level.</p>

<div class="mermaid" align="center">
block-beta
columns 1
  block:Areas
    A["Arch"]
    B["Sw Models"]
    C["Impl (RTL)"]
    D["DV (Sim)"]
    E["DV (Emu)"]
    F["Prototying"]
    G["Si Bring-Up"]
    H["Si Validation"]
  end
</div>

<p>Currently, the use of PSS centers around DV, prototyping, and silicon
bring-up. PSS has plenty of room in which to expand adoption in 
these areas, but there are also many others areas where PSS 
could play and add value.</p>

<p>Looking forward, there are three key areas where I’m looking to see growth
in the PSS language and ecosystem:</p>

<h2 id="develop-pss-core-language">Develop PSS Core Language</h2>

<p>An evolving language is critical to maintaining interest and users. 
Needs, styles, and approaches change over time, and a programming
language must react to these changes in requirement in order to remain
relevant. My informal observation is that, since the mid-2010s, more 
programming languages are shortening the interval between updates
to the language. I’m happy to see the PSS language continuing to
grow and evolve in the context of the Accelera PSWG.</p>

<h2 id="grow-pss-ecosystem">Grow PSS Ecosystem</h2>

<p>Ecosystems are key to the success of any programming language. Having a 
vibrant ecosystem means that users of a language will have access to 
code snippets, expertise, and reusable libraries created by other users
of the language. Vibrant ecosystems also act as a pipeline, getting 
students interested in and familiar with the language.</p>

<p>I’d also like to see more publicly-available examples and libraries. 
Having real live code out there to play with is a critical part of
learning a new technology.</p>

<h2 id="exploration-of-new-applications">Exploration of New Applications</h2>

<p>New applications and integrations is the area in which I most like to play.
Each phase of the design process shown above has its own unique 
requirements that it places – most often on <em>how</em> the language is 
processed, but sometimes on the features provided by the language itself
as well.</p>

<p>There are key differences in test requirements across the different platforms
shown in the diagram above, and worth exploring how that impacts how 
tests are implemented. But, in addition, there might be some other interesting
roles for PSS across the process. Could we use PSS, for example, to implement
an architectural model of the design?</p>

<h1 id="thinking-forward">Thinking Forward</h1>
<p>Given these three areas, it’s reasonable to ask how we can “move the needle” 
in each of them. To a certain extent, continued evolution of the core
language might have the simplest answer since there’s a well-established 
group (the Accellera PSWG) with members from across the industry that meet 
weekly to discuss that topic.</p>

<p>Advancing the other two areas poses a technology-access challenge. It’s 
fine to speculate on how PSS might contribute to the design process, 
for example. However, I’d argue that what most people really want to see
are implementations (proof-of-concept or production) that deliver 
concrete results.</p>

<p>The same holds for building knowledge of PSS. It’s fine to read descriptions
about how PSS works and how to use it to create test scenarios. Real learning
takes places when people are able to work with the language themselves and
internalize the key concepts of the language.</p>

<h2 id="pss-and-open-source">PSS and Open Source</h2>
<p>Open source software has been a powerful enabler of exploration in other ecosystems. 
Having open source resources encourages people to learn about a technology. 
It also provides a basis for experimentation that doesn’t require an interested
party to start at zero.</p>

<h2 id="zuspec">Zuspec</h2>
<p>Starting in 2025, I’ll be starting to write more about components within the 
<em>Zuspec</em> umbrella project. Consequently, it’s worth providing a brief 
introduction to what <em>Zuspec</em> is, what it’s not, and what to expect.</p>

<p>Zuspec is a collection of functionality for working with the style of
action-centric dataflow descriptions used by the PSS language. The
philosophy of the component libraries is to keep things as modular as
possible to maximize the reuse opportunities even as we discover different
ways in which to productively use and apply these descriptions.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/Zuspec_crop.png" style="width: 200px" />
</p>

<p>The <em>Zuspec</em> name is a portmanteau of zusammen (German for together) and ‘spec’,
and reflects my ambition for PSS to be a specification that brings together
disciplines such as design and verification that are quite separate today.</p>

<p>From a technical perspective, the vast majority of Zuspec components are 
implemented as C++ libraries (for speed) that also have Python bindings, 
making it easy to use a small amount of Python to mix them together 
into an application.</p>

<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/12/ZuspecProjectMap.png" style="width: 800px" />
</p>

<p>Zuspec is much more of a technology framework than a tool today. You won’t find
any fancy GUIs. And, it’s in an early state of development and testing: 
you should expect to find bugs. That said, my hope is that if these 
components can help me to explore new areas of PSS application they can
enable others to do the same. Starting in the new year, I’ll be writing
more about the components and what they allow us to do with a 
PSS-based description</p>

<h1 id="pss-looking-forward">PSS Looking Forward</h1>

<p>I continue to see PSS as having a bright future. It’s providing strong value
in the areas of test-content reuse, with a focus on simulation, emulation, 
and silicon bring-up. And, as more people learn about PSS and get 
hands-on experience with the language and its capabilities, I’m confident 
that adoption will continue to grow. I also see great possibilities for the 
language to expand its application space into domains adjacent to where it 
is applied today.</p>

<p>In the coming year, I’m looking forward to writing more about what PSS 
enables today, and what it could enable in the future. And, of course,
expect to hear more about other tools and technologies related to design
and verification. There is always something new to learn and explore!</p>

<h1 id="references">References</h1>
<ul>
  <li>Accellera - https://accellera.org</li>
  <li>PSS Tutorial Video - https://www.accellera.org/resources/videos/portable-stimulus-tutorial-2024</li>
  <li>PSS LRM - https://www.accellera.org/downloads/standards/portable-stimulus</li>
</ul>]]></content><author><name></name></author><category term="PSS" /><summary type="html"><![CDATA[As the year winds down, it’s a good time to think about the coming year and the areas where I’d like to have an impact. One area of particular interest this year is the Portable Test and Stimulus (PSS) standard. The Accellera PSS working group released the 3.0 version of the PSS LRM in August, and I’ve felt fortunate to have been involved with PSS Working Group (PSWG) from its inception, and to see how the growing body of features in PSS have allowed the language to enable test-content portability across simulation, emulation, and post-silicon targets. The release of PSS 3.0 also provides an opportunity to step back and consider the future of PSS – not just incremental additions to its current field of use, but also how its use could expand to other portions of the design and verification process.]]></summary></entry><entry><title type="html">Easy Access to Python Libraries with a SystemVerilog Convenience API</title><link href="https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API.html" rel="alternate" type="text/html" title="Easy Access to Python Libraries with a SystemVerilog Convenience API" /><published>2024-11-17T00:00:00+00:00</published><updated>2024-11-17T00:00:00+00:00</updated><id>https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API</id><content type="html" xml:base="https://bitsbytesgates.com/python/2024/11/17/PyHDL_Convenience_API.html"><![CDATA[<p align="center">
<img src="https://bitsbytesgates.com/imgs/2024/11/PyHDL_IF_Convenience_API.png" /> 
</p>

<p>In the last post 
(<a href="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html">DPI Isn’t Enough: Making Python Part of Your SV Testbench</a>), 
we looked at how to use the <a href="https://fvutils.github.io/pyhdl-if">PyHDL-IF</a> library 
to call SystemVerilog from Python. 
This is, in some sense, the most challenging Python and SV interaction to implement. 
And, as the title suggests, it’s something that definitely requires
more than just the raw features of the SystemVerilog DPI.</p>

<p>That said, there are many cases where we simply want to access some functionality
that is readily-available in Python and not readily-available in SystemVerilog. 
In these cases, we don’t need to call back into SystemVerilog from Python. 
Arguably, we <strong>could</strong> simply use SystemVerilog DPI To call the relevant 
<a href="https://docs.python.org/3/c-api/">Python C API</a>. The PyHDL-IF library uses the
Python C API internally to implement cross-calling between SystemVerilog and
Python, and it’s always good to have it as an option. The downside is that code that
uses the C API tends to be rather verbose, so let’s see if we can improve the
situation with a SystemVerilog convenience API.</p>

<!--more-->

<h1 id="pyhdl-if-architecture">PyHDL-IF Architecture</h1>

<p>The PyHDL-IF implements the interface between Python and HDLs with a layered architecture.</p>

<div class="mermaid" align="center">
block-beta
columns 1
  block:UIApp
  columns 1
    TitleApp["App-Specific Interfaces"]
    style TitleApp fill:transparent,stroke:transparent
    block:UICodeAPIs
      UICall["Method Call"]
      UITlm["TLM"]
    end
  end
  block:UIMid
  columns 1
    TitleMid["Convenience API"]
  end
  block:UIDirect
  columns 1
    TitleDirect["CPython API"]
  end
</div>

<p>In the <a href="https://bitsbytesgates.com/python/2024/11/04/DPI_Isnt_Enough_MakingPythonPartOfYourSVTB.html">last post</a>,
we looked at an example built on top of the ‘Call’ API. This is the API that manages blocking cross-calling
between Python and a HDL. Using this API requires us to mark up our Python API with decorators and generate
SystemVerilog source to implement the API in the SystemVerilog environment.</p>

<p>We could use this same approach to “wrap up” the API of a Python library and expose it to SystemVerilog. But,
it often makes sense to use one of the lower-level interface APIs. Let’s look at an example.</p>

<h1 id="loading-json-data">Loading JSON Data</h1>

<p>UVM testbench environments can be highly-configurable when used for complex, configurable IPs. Capturing 
the configuration data in a JSON or YAML file is helpful in keeping all the settings in one place. 
The challenge arises when we want to acccess that data from our UVM environment. Current options include:</p>

<ul>
  <li><strong>Integrate a parser implemented in C via SV DPI</strong></li>
  <li><strong>Implement a parser in SystemVerilog</strong></li>
</ul>

<p>Both of these involve a fair amount of (likely project-specific) work and debugging. In contrast, reading 
a JSON file in Python and iterating through the top-level entries is trivial:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">json</span>

<span class="n">datafile</span> <span class="o">=</span> <span class="s">"data1.json"</span>

<span class="n">fp</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span>
<span class="n">data_s</span> <span class="o">=</span> <span class="n">fp</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
<span class="n">fp</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">data_s</span><span class="p">)</span>
<span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Key: %d %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Key: %s"</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></code></pre></figure>

<h1 id="svpython-convenience-api">SV/Python Convenience API</h1>
<p>Using the PyHDL-IF library, we actually have several options for leveraging Python to access JSON data. 
Let’s look at using <a href="https://fvutils.github.io/pyhdl-if/sv_api.html#systemverilog-api">SystemVerilog convenience API</a>. 
This API is object-oriented and higher level than the raw CPython API (which we also can use).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="k">import</span> <span class="n">pyhdl_if</span><span class="o">::*</span><span class="p">;</span>

    <span class="k">initial</span> <span class="k">begin</span>
        <span class="k">automatic</span> <span class="kt">string</span> <span class="n">datafile</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">json</span><span class="p">,</span> <span class="n">data_fp</span><span class="p">,</span> <span class="n">data_s</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_dict</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">automatic</span> <span class="n">py_list</span> <span class="n">keys</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="n">value</span><span class="p">$</span><span class="n">plusargs</span><span class="p">(</span><span class="s">"data=%s"</span><span class="p">,</span> <span class="n">datafile</span><span class="p">))</span> <span class="k">begin</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Error: no datafile specified"</span><span class="p">);</span>
            <span class="p">$</span><span class="nb">finish</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">py_gil_enter</span><span class="p">();</span>

        <span class="c1">// Import Python's 'json' package </span>
        <span class="n">json</span> <span class="o">=</span> <span class="n">py_import</span><span class="p">(</span><span class="s">"json"</span><span class="p">);</span>

        <span class="c1">// Open and read the specified data file</span>
        <span class="n">data_fp</span> <span class="o">=</span> <span class="n">py_call_builtin</span><span class="p">(</span><span class="s">"open"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="n">datafile</span><span class="p">),</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span><span class="o">}</span><span class="p">));</span>
        <span class="n">data_s</span> <span class="o">=</span> <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"read"</span><span class="p">);</span> 
        <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"close"</span><span class="p">);</span>

        <span class="c1">// Parse the data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">py_dict</span><span class="o">::</span><span class="n">mk</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"loads"</span><span class="p">,</span> 
            <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span><span class="n">data_s</span><span class="o">}</span><span class="p">)));</span>

        <span class="c1">// Get the list of keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">keys</span><span class="p">();</span>

        <span class="c1">// Iterate based on the list size</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">keys</span><span class="p">.</span><span class="nb">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0d %0s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">to_str</span><span class="p">());</span>
        <span class="k">end</span>

        <span class="c1">// Use an iterator</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">py_iter</span> <span class="n">i</span><span class="o">=</span><span class="n">keys</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span> <span class="p">)</span> <span class="k">begin</span>
            <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">it</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
            <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0s"</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">to_str</span><span class="p">());</span>
        <span class="k">end</span>

        <span class="n">py_gil_leave</span><span class="p">();</span>
    <span class="k">end</span></code></pre></figure>

<p>The code above accomplishes the same thing as the pure-Python code that reads a JSON file. 
While the SystemVerilog code involves roughly twice as many lines as the pure-Python code,
it <em>is</em> pure SystemVerilog. And, it didn’t require us to do any code generation or any
special “tagging” of Python code. Let’s look in more detail at what’s happening in this
code, and how the PyHDL-IF convenience API helps us out.</p>

<h2 id="calling-built-in-functions">Calling Built-in Functions</h2>
<p>One of the first things we need to do is to read the contents of the JSON data file. 
The Python <code class="language-plaintext highlighter-rouge">open</code> function is a built-in. This means that it’s not contained in 
another package or module that needs to be imported.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="n">data_fp</span> <span class="o">=</span> <span class="n">py_call_builtin</span><span class="p">(</span><span class="s">"open"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="n">datafile</span><span class="p">),</span>
            <span class="n">py_from_str</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span><span class="o">}</span><span class="p">));</span></code></pre></figure>

<p>PyHDL-IF provides the <code class="language-plaintext highlighter-rouge">py_call_builtin</code> function to call built-ins. The PYthon C API
requires function arguments to be Python objects, and to be packed in a Tuple. The
<code class="language-plaintext highlighter-rouge">py_tuple::mk_init</code> function handles creating the properly-sized tuple. The helper
function <code class="language-plaintext highlighter-rouge">py_from_str</code> creates a Python string object from a SystemVerilog string value.</p>

<h2 id="calling-methods">Calling Methods</h2>
<p>The <code class="language-plaintext highlighter-rouge">open</code> function returns a Python stream object. We want to read all the data from
the file and then close the file.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="n">data_s</span> <span class="o">=</span> <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"read"</span><span class="p">);</span> 
        <span class="n">data_fp</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"close"</span><span class="p">);</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">call_attr</code> function implemented by the <code class="language-plaintext highlighter-rouge">py_object</code> SV class handles looking up the
requested attribute within the Python object and calling it. In this case, 
both <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">close</code> methods take no arguments.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="c1">// Parse the data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">py_dict</span><span class="o">::</span><span class="n">mk</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">call_attr</span><span class="p">(</span><span class="s">"loads"</span><span class="p">,</span> <span class="n">py_tuple</span><span class="o">::</span><span class="n">mk_init</span><span class="p">(</span><span class="err">'</span><span class="o">{</span><span class="n">data_s</span><span class="o">}</span><span class="p">)));</span></code></pre></figure>

<p>Python views everything as an object. Consequently, the <code class="language-plaintext highlighter-rouge">loads</code> method within
the <code class="language-plaintext highlighter-rouge">json</code> package is just an attribute with the json package object. This means
that we can call it in the same way we would invoke a method on a class-type object.
We happen to know that the return of the <code class="language-plaintext highlighter-rouge">loads</code> method is a Python dictionary (<code class="language-plaintext highlighter-rouge">dict).
Therefore, we can directly convert the return value to a </code>py_dict` object. This allows
us to use convenience methods to access the data.</p>

<h2 id="iterating">Iterating</h2>
<p>Now that we have a Python dictionary containing the JSON data, we likely will 
want to iterate over it. The PyHDL-IF objects also provide some convenience 
APIs to help simplify this process as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="c1">// Get the list of keys</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">keys</span><span class="p">();</span>

    <span class="c1">// Iterate based on the list size</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">keys</span><span class="p">.</span><span class="nb">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0d %0s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keys</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">to_str</span><span class="p">());</span>
    <span class="k">end</span></code></pre></figure>

<p>A Python dictionary returns it key set as a list. Perhaps the simplest way
to iterate over the items of list is to get each element via its index,
as shown above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="c1">// Use an iterator</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">py_iter</span> <span class="n">i</span><span class="o">=</span><span class="n">keys</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span> <span class="n">i</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span> <span class="p">)</span> <span class="k">begin</span>
        <span class="k">automatic</span> <span class="n">py_object</span> <span class="n">it</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"Key: %0s"</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">to_str</span><span class="p">());</span>
    <span class="k">end</span></code></pre></figure>

<p>The list object also implements Python’s <em>iteration</em> interface. PyHDL-IF
also provides helper types and functions around this interface. We can
still use a SystemVerilog <em>for</em> loop. The difference is that the iteration
variable is actually a Python iterator object. Here, again, the convenience
API simplifies the user code compared to using the raw CPython API.</p>

<h1 id="conclusion">Conclusion</h1>
<p>The PyHDL-IF Python convenience API enables you to call Python code from
SystemVerilog without the need to generate any application-specific 
code, and with less work that directly using the CPython API would require.
This reduction of effort makes is incredibly simple to augment the capabilities
of your existing testbench with those of a library from the vast Python ecosystem.</p>

<h1 id="resources">Resources</h1>
<ul>
  <li><a href="https://fvutils.github.io/pyhdl-if/">PyHDL-IF Documentation</a></li>
  <li><a href="https://fvutils.github.io/pyhdl-if/sv_api.html">PyHDL-IF SV Convenience API</a></li>
  <li><a href="https://docs.python.org/3/c-api/index.html">CPython API</a></li>
</ul>]]></content><author><name></name></author><category term="Python" /><summary type="html"><![CDATA[In the last post (DPI Isn’t Enough: Making Python Part of Your SV Testbench), we looked at how to use the PyHDL-IF library to call SystemVerilog from Python. This is, in some sense, the most challenging Python and SV interaction to implement. And, as the title suggests, it’s something that definitely requires more than just the raw features of the SystemVerilog DPI. That said, there are many cases where we simply want to access some functionality that is readily-available in Python and not readily-available in SystemVerilog. In these cases, we don’t need to call back into SystemVerilog from Python. Arguably, we could simply use SystemVerilog DPI To call the relevant Python C API. The PyHDL-IF library uses the Python C API internally to implement cross-calling between SystemVerilog and Python, and it’s always good to have it as an option. The downside is that code that uses the C API tends to be rather verbose, so let’s see if we can improve the situation with a SystemVerilog convenience API.]]></summary></entry></feed>