---
layout: legacy_post
title: 'FWRISC: Sizing up the RISC-V Architecture'
date: '2018-12-08T20:17:00.001-08:00'
author: Matthew Ballance
tags:
- Verilator
- RTL
- FPGA
- Googletest
- Verilog
- RISCVcontest
- RISC-V
- HDL
modified_time: '2018-12-16T09:45:33.642-08:00'
thumbnail: https://3.bp.blogspot.com/-vl_M8KSBei8/XAx_fj8Fi9I/AAAAAAAACak/oEnB_fcrCFogqQNpOW0CdSAKnZ-_uJWJQCLcBGAs/s72-c/post2_intro.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-1699277764769430972
blogger_orig_url: https://bitsbytesgates.blogspot.com/2018/12/fwrisc-sizing-up-risc-v-architecture.html
---

<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-vl_M8KSBei8/XAx_fj8Fi9I/AAAAAAAACak/oEnB_fcrCFogqQNpOW0CdSAKnZ-_uJWJQCLcBGAs/s1600/post2_intro.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://3.bp.blogspot.com/-vl_M8KSBei8/XAx_fj8Fi9I/AAAAAAAACak/oEnB_fcrCFogqQNpOW0CdSAKnZ-_uJWJQCLcBGAs/s1600/post2_intro.png" /></a></div><br /><br />After deciding on October 22nd to create a RISC-V implementation to enter in the <a href="https://riscv.org/2018contest/">2018 RISC-V soft-core contest</a> (with entries due November 26th), I needed to gather more information of the RISC-V ISA in general, and the RV32I subset of the ISA specifically. I had previously done some work in RISC-V assembly -- mostly writing boot code, interrupt handlers, and thread-management code. But I certainly hadn't explored the full ISA, and certainly not from the perspective of implementing it. Bottom line, I needed a better understanding of the ISA I needed to implement.<br /><br /><b>Fundamentals of the RISC-V ISA</b><br />The first thing to understand about the RISC-V architecture is that it came from academia. If you took a computer architecture course and read the <a href="https://www.amazon.com/Computer-Architecture-Quantitative-John-Hennessy/dp/012383872X">Patterson and Hennesy book</a>, you read about some aspects of one of the RISC-X family of instruction sets (RISC-V is, quite literally, the 5th iteration of the RISC architecture developed at UC Berkeley).<br /><br />Due in part to its academic background, the ISA has both been extended and refined (restricted) over time -- sometimes in significant and sometimes in insignificant ways. This ability to both extend and change the ISA is somewhat unique when it comes to instruction sets. I'm sure many of you reading this are well-aware of some of the baggage still hanging around in the x86 instruction set (string-manipulation instructions, for example). While many internal protocols, such as the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ihi0011a/index.html">AMBA bus protocol</a>, often take a path of complex early specification versions followed by simpler follow-on versions, instruction set architectures often remain more fixed. In my opinion, the fact that the RISC-V ISA had a longer time to incubate in a context that did not penalize backwards-incompatible changes has resulted in an architecture that is cleaner and easier to implement.<br /><br />The RISC-V ISA is actually a base instruction-set architecture, and a family of extensions. The RV32I (32-bit integer) instruction set forms the core of the instruction-set architecture. Extensions add on capabilities such as multiply and divide, floating-point instructions, compressed instructions, and atomic instructions. Having this modular structure defined is very helpful in enabling a variety of implementations, while maintaining a single compiler toolchain that understands how to create code for a variety of implementations.<br />The RISC-V soft-core contest called for an RV32I implementation, though implementations could choose to include other extensions. The RV32I instruction set is actually very simple -- much simpler than other ISAs I've looked at in the past:<br /><ul><li>32 32-bit general-purpose registers</li><li>Integer add, subtract, and logical-manipulation instructions</li><li>Control-flow instructions</li><li>Load/store instructions&nbsp;</li><li>Exceptions, caused by a system-call instruction and address misalignment</li><li>Control and status registers (CSRs)</li><li>Cycle and instruction-counting registers</li><li>Interestingly enough, interrupts are <b>not</b>&nbsp;required</li></ul><div>In total, the instruction-set specification states that there are 47 instructions. I consider the RV32I subset to actually contain 48 instructions, since ERET (return from exception) is effectively required by most RV32I software, despite the fact that it isn't formally included in the RV32I subset.&nbsp;</div><div><br /></div><div>On inspection, the instruction-set encoding seemed fairly straightforward. So, where were the implementation challenges?</div><div><ul><li>CSR manipulation seemed a bit tricky in terms of atomic operations to read the current CSR value, while clearing/setting bits.</li><li>Exceptions always pose interesting challenges</li><li>The performance counters pose a size challenge, since they don't nicely fit in FPGA-friendly memory blocks</li></ul><div>Despite the challenges, the RV32I architectural subset is quite small and simple. This simplicity, in my opinion, is the primary reason it was possible for me to create an implementation in a month of my spare time.&nbsp;</div></div><div><br /></div><b>Implementation Game Plan</b><br />For a couple or reasons, I elected to use a simple approach to implementation of the RISC-V ISA. First, the deadline for the contest was very close and I wanted to be sure to actually have an entry. Secondly, my thinking was that a simple implementation would result in a smaller implementation.<br />Since I was interested in evolving <a href="https://github.com/mballance/fwrisc">Featherweight RISC</a> after the contest, a second-level goal with the initial implementation was to build and prove-out a test suite that could be used to validate later enhancements.<br /><br />The implementation approach I settled on was state-machine based -- not the standard RISC pipelined architecture. Given that I was targeting an FPGA, I also planned to move as many registers as possible to memory blocks.<br /><br /><b>Next Steps</b><br />With those decisions made, I was off create an implementation of the RISC-V RV32I instruction set! In my next post, I'll discuss the test-driven development approach I took to implementing the <a href="https://github.com/mballance/fwrisc">Featherweight-RISC</a> core.<br /><br /><div class="separator" style="clear: both;"><b><i>Disclaimer</i></b></div><br /><div></div><br /><div class="separator" style="-webkit-text-stroke-width: 0px; clear: both; color: black; font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: 400; letter-spacing: normal; margin: 0px; orphans: 2; text-align: start; text-decoration-color: initial; text-decoration-style: initial; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px;"><i>The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</i></div>