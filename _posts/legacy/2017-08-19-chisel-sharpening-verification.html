---
layout: legacy_post
title: 'Chisel Sharpening: If it''s not tested, it''s broken'
date: '2017-08-19T19:36:00.001-07:00'
author: Matthew Ballance
tags:
- Chisel
- Chisel3
- UVM
- HDL
modified_time: '2017-08-20T11:44:39.441-07:00'
thumbnail: https://4.bp.blogspot.com/-RvjgxA5Gsk8/WZhaNqjw6aI/AAAAAAAACAw/PCEPL1rG9Wceib6PIZiNmXKqAlxGEY62gCLcBGAs/s72-c/Wishbone_2x4.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-7218057771447605912
blogger_orig_url: https://bitsbytesgates.blogspot.com/2017/08/chisel-sharpening-verification.html
---

<h1 class="quote clearfix" style="background-color: white; box-sizing: border-box; color: #666666; font-family: &quot;libre baskerville&quot;, serif; font-weight: normal; line-height: 1.4; margin: 0.2rem 0px 0.5rem; padding: 0px;"><span style="font-size: x-large;">"If it's not tested, it's broken."</span></h1><span style="font-size: x-small;"><span style="background-color: white; color: #999999; font-family: &quot;varela round&quot; , sans-serif;">--&nbsp;</span><a href="http://www.inspiringquotes.us/author/9711-bruce-eckel" style="background-color: white; box-sizing: border-box; color: black; font-family: &quot;varela round&quot;, sans-serif; font-weight: bold; line-height: inherit;">Bruce Eckel</a></span><br /><br />I'm a big believer in the quote above, and cite it somewhat frequently -- perhaps to the tedium of my colleagues. In my last post, I showed a Chisel3-based description of a Wishbone interconnect. While it might have looked cool, without tests I had no idea whether it worked correctly or not. After adding a simple UVM testbench around my interconnect I can, yet again, confirm the truth of the quote above. But, enough pontificating, let's dig into the specifics.<br /><br /><h3>Error Types</h3><div>Especially when implementing something while learning a new language or technique, I find that I make four types of errors:</div><div><ul><li><b>Implementation errors and oversights - </b>There are your run of the mill bugs. For example, I neglected to implement an intended feature, or I implemented the logic incorrectly. Good planning helps to minimize these errors, but they are why we place such value on good verification.</li><li>&nbsp;<b>Errors in description - </b>These are learning mistakes related to the new language or technique. I structured a description around my understanding of the language/technique, only to find that it resulted in unexpected behavior. The ease or difficulty in avoiding and/or diagnosing errors in description is a key determinant for me in deciding how easy a new technique is to adopt.&nbsp;</li><li><b>Errors in reuse - </b>This type of error occurs when reusing existing IP, only to find that it functions differently from my understanding.&nbsp;</li><li><b>Tool or library issues - </b>These are errors that you hope not to encounter, but do crop up from time to time.&nbsp;</li></ul><div>Not surprisingly, I encountered the first three categories of errors while verifying my Wishbone interconnect. &nbsp;I did encounter one tool/library issue, but I'll get to that later...</div></div><div><br /></div><h3>UVM Testbench</h3><div>I decided to verify a 2x4 configuration of the Wishbone interconnect, and created a very (very) basic UVM testbench around the interconnect and instantiated two Wishbone master agents and four memory target devices - mapped at 0x00000000, 0x00001000, 0x00002000, and 0x00003000, respectively.</div><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-RvjgxA5Gsk8/WZhaNqjw6aI/AAAAAAAACAw/PCEPL1rG9Wceib6PIZiNmXKqAlxGEY62gCLcBGAs/s1600/Wishbone_2x4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="737" data-original-width="962" height="245" src="https://4.bp.blogspot.com/-RvjgxA5Gsk8/WZhaNqjw6aI/AAAAAAAACAw/PCEPL1rG9Wceib6PIZiNmXKqAlxGEY62gCLcBGAs/s320/Wishbone_2x4.png" width="320" /></a></div><div><br /></div><div><br /></div><div>And, a very basic write/read test:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-FRsghUP_ww0/WZheiR1mguI/AAAAAAAACA8/IHVfNYovfjsiarkojlMQ8GBlx9IicLDcgCLcBGAs/s1600/BasicTest.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="572" data-original-width="527" height="400" src="https://1.bp.blogspot.com/-FRsghUP_ww0/WZheiR1mguI/AAAAAAAACA8/IHVfNYovfjsiarkojlMQ8GBlx9IicLDcgCLcBGAs/s400/BasicTest.png" width="366" /></a></div><br /></div><div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />I ran this in Questa (the Altera Modelsim Starter Edition, to be precise). On the first test run, nothing worked and quite a few signals were driven to X. In order to accelerate progress, I turned on register randomization (something supported by the Verilog code generated by Chisel).<br /><br /><h3>Reuse Error: Chisel Arbiter</h3><div>My simple write/read test causes both masters to perform a write to the same target device as the first operation. I had assumed that the Chisel-provided arbiter would grant the output to the selected master until that master dropped its request. However, this turned out to not be the case. It took browsing the source code (for me at least) to understand the mechanism the library developer had provided for controlling the arbiter locking behavior. Once I understood that mechanism, it was very simple to customize the locking behavior.</div><div>The arbiter is such a useful and reusable construct that I'll devote a future post to it, rather than delve into the details here.</div><div><br /></div><h3>Description Error: Multiple Assignments</h3><div>My original interconnect description used a nested loop structure across the masters and slaves, with a conditional assignment to propagate back the slave response.&nbsp;</div><div><br /></div><div><pre style="white-space: pre-wrap; word-wrap: break-word;">  for (i &lt;- 0 until p.N_SLAVES) {<br />    for (j &lt;- 0 until p.N_MASTERS) {<br />      // ...<br />      <br />      // Propagate slave response back to active master<br />      when (out_arb(i).io.in(j).ready) {<br />          in_rsp(j) := out_rsp(i);<br />      } .otherwise {<br />          in_rsp(j).park_rsp();<br />      }<br />    }<br />    out_arb(i).io.out.bits.assign_req2p(io.s(i));<br />  }<br /></pre></div><div>&nbsp;&nbsp;</div>As it turns out, this code trips over one of the corner cases of Chisel: when procedural code (eg for loops) make multiple assignments, the last assignment is taken. In this case, that means that both masters were being fed the response from the last slave device.<br />Investigating description errors like these unfortunately involve digging into the generated Verilog code. This is both tedious and not quite as bad as it sounds. Chisel picks sensible names for module I/O signals, so these are easy to track. However, Chisel also generates lots of anonymously-named internal signals (eg _T_51) that are used to implement the logic within the module.<br />I don't have a concrete proposal for the Chisel authors on how to improve this situation, but I would like to think a graphical view, such as a schematic, might be helpful in relating the input Scala code to the resulting Verilog.<br /><br /><h3>Reuse Error: Mux Arguments</h3><div>After better-understanding Chisel's behavior with respect to multiple assignments, I decided that using Chisel's 1-hot Mux primitive would be the best way to handle the response data. Here I bumped into a limitation of the Mux that the Arbiter primitive allowed me to ignore: multiplexing bundles with signals of different I/O directions is not supported (and, sadly, only uncovered very late in the transformation process from Chisel to Verilog). It all makes a lot of sense once you think it through.</div><div>Understanding this limitation drove me to redefine the I/O bundles I used to describe the Wishbone interface. It was a fairly straight-forward process, and one that I'll describe in more depth in a future post on structuring I/Os for standard interfaces with Chisel.</div><div><br /></div><h3>Understanding Data Manipulation Techniques</h3><div>&nbsp;Chisel encourages descriptions that involve collections of data. In some ways, this isn't so different from other hardware-description languages. What's different is the set of operators Chisel provides for manipulating these data collections. One early example I ran across was implementing address decode for the masters. I had arrays of target base/limit addresses, and wanted to determine which target device each master was selecting. This was very easy (and compactly) described with the following code:</div><div><br /></div><div><div>&nbsp; &nbsp; val slave_req = io.addr_base.zip(io.addr_limit).map(e =&gt; (</div><div>&nbsp; &nbsp; &nbsp; &nbsp; io.m(i).ADR &gt;= e._1 &amp;&amp; io.m(i).ADR &lt;= e._2) &amp;&amp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; io.m(i).CYC &amp;&amp; io.m(i).STB)</div></div><div><br /></div><div>This code describes the following:</div><div><ul><li>Combine the addr_base and addr_limit arrays into an array of (addr_base,addr_limit) tuples using the 'zip' operation</li><li>Convert this array of tuples into an array of Bool where the entry is 'true' if the target is selected</li></ul><div>These techniques also apply nicely to selecting fields from composite data structures, as shown below. In the case below, we want to determine whether a given target device is actively selected by any master.</div></div><div><br /></div><div><div>&nbsp; &nbsp; &nbsp; when (out_arb(j).io.in.map((f) =&gt; f.valid).reduceLeft(_|_)) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; out_arb(j).io.out.bits.assign_b2(io.s(j));</div><div>&nbsp; &nbsp; &nbsp; } .otherwise {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // If no master is requesting, deactivate the slave requests</div><div>&nbsp; &nbsp; &nbsp; &nbsp; io.s(j).park_req()</div><div>&nbsp; &nbsp; &nbsp; }</div></div><div><br /></div><div>In this case, the code does the following:</div><div><ul><li>out_arb(j).io.in is an array of composite data going into the per-target arbiters. The map() operation selects just the 'valid' field from each array element</li><li>Then, the reduceLeft() operation performs a reduction across the array</li></ul><div>Now, both of these operations can be described in other hardware description languages. But both likely would involve several layers of temporary data fields. It's actually really nice to be able to describe the high-level view of the manipulation to be performed, and be confident that a sensible implementation of this implementation will be inferred (and, after having to dig into the implementation for other reasons, I can state that the implementation <b>is</b>&nbsp;sensible).</div></div><div><br /></div><h3>Tool Issue: Register without Reset</h3><div>I mentioned earlier that I had turned on register initial-value randomization when I first started simulations. After getting my test running correctly, I had hoped this would not be needed. However, it turns out that Chisel's Arbiter primitive contains a register without a reset value. Perhaps this hasn't created an issue for many Chisel users because the Verilator 2-state simulator is often used. However, with a 4-state simulator like Questa/Modelsim, an uninitialized register is a fatal issue that results in X propagation and a non-functioning design.</div><div><br /></div><div>I strongly recommend using registers that are reset, and will provide this feedback to the Chisel team.&nbsp;</div><h3>Conclusions</h3><div>I'd class many of the issues I faced as all part of the learning curve for a new tool or technique. Challenging (and sometimes time-consuming) to surmount, perhaps, but issues I'd likely not face in the future. I've also gained an new-found appreciation for the descriptive power that Chisel's support for Scala's collection-manipulation operators bring to the description of hardware.&nbsp;</div><div><br /></div><div>For now, I have a working Wishbone interconnect described with Chisel. And, despite a few hiccups along the way, I'm still feeling pretty good about the expressive power that Chisel brings to hardware description.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-4go5IsrHVb0/WZjxzcfPcqI/AAAAAAAACBM/gTOlpqXTsXUtAsgX4xkljg09Bmbrc_yPQCLcBGAs/s1600/Waves.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="615" data-original-width="1131" height="174" src="https://4.bp.blogspot.com/-4go5IsrHVb0/WZjxzcfPcqI/AAAAAAAACBM/gTOlpqXTsXUtAsgX4xkljg09Bmbrc_yPQCLcBGAs/s320/Waves.png" width="320" /></a></div><div><br /></div><div>Next, I'm curious to see how synthesis results compare for a hand-coded Wishbone interconnect and the Chisel-generated one.&nbsp;</div><div>As always, you can find the source for my experiments here:</div><div><a href="https://github.com/mballance/wb_sys_ip.git">https://github.com/mballance/wb_sys_ip.git</a></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><br /></div>