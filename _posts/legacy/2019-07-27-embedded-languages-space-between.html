---
layout: legacy_post
title: 'Embedded Languages: The Space Between Language and API'
date: '2019-07-27T16:19:00.004-07:00'
author: Matthew Ballance
tags:
- CRAVE
- domain-specific language
- Python
- Chisel3
- higher-level design
- SystemVerilog
- UVM
- Functional Verification
- SystemC
modified_time: '2019-07-27T16:19:53.351-07:00'
thumbnail: https://1.bp.blogspot.com/-NYPCqfsDHYw/XTy9gSEk_7I/AAAAAAAACpU/UligMiB6B3UXRWriR2GzxDE6sce6J4dtQCLcBGAs/s72-c/splash.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-728335647313527081
blogger_orig_url: https://bitsbytesgates.blogspot.com/2019/07/embedded-languages-space-between.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-NYPCqfsDHYw/XTy9gSEk_7I/AAAAAAAACpU/UligMiB6B3UXRWriR2GzxDE6sce6J4dtQCLcBGAs/s1600/splash.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://1.bp.blogspot.com/-NYPCqfsDHYw/XTy9gSEk_7I/AAAAAAAACpU/UligMiB6B3UXRWriR2GzxDE6sce6J4dtQCLcBGAs/s1600/splash.png" /></a></div><div style="text-align: center;"><br /></div>We're all familiar with general-purpose programming language for capturing general algorithms, but there are also a sizeable group of domain-specific languages that exist to efficiently capture reasoning in a specific domain -- whether that's hardware design (Verilog, VHDL), database manipulations (SQL), or models at a high level of abstraction (UML/xtUML). These languages exist because the overhead is enormous for a domain expert to capture a problem in their given domain using a general-purpose programming language and APIs.<br /><br />One of my favorite examples showing the motivation for domains-specific languages is spreadsheets. A spreadsheet is a language based around a namespace (table) where elements (cells) in the namespace are addressable by their coordinates, and whose values are represented by equations that may include references to other elements in the namespace. Just think how easy it is to setup a simple spreadsheet to do some what-if analysis, and how difficult it would be if you had to write a program to perform those calculations instead!<br /><br />Simplistic though it may be, the spreadsheet perfectly captures the motivation behind domain-specific languages: focus on capturing the <i>what</i>&nbsp;of a given domain -- the key attributes, key relationships, and key operations -- and not on the <i>how</i>&nbsp;of the mechanics of how these elements would be represented in a general-purpose programming language. In short, a domain-specific language provides a user interface to complex algorithms phrased in familiar terms -- at least to someone knowledgeable in a that specific domain.<br /><br />Taking the step of capturing domain knowledge in a new domain-specific language is a big step, though. There are a variety of reasons to defer taking that step or, perhaps, to not take that step at all.&nbsp; Sometimes an entire language isn't required to implement the desired user interface. Sometimes it's desirable to have some benefits of a general-purpose language without the overhead of designing an entirely new all-in-one domain-specific and general-purpose language. The embedded domain-specific language is one approach that has been used to bring some benefits of a domain-specific language into an existing general-purpose programming language. The general approach is to use existing general-purpose language constructs, such as pre-processor macros and operator overloading, to build constructs with a domain-specific language feel within an existing language.<br /><br />Within the set of embedded domain-specific languages that I'm aware of, I'm actually aware of three key styles of embedded a domain-specific language inside an existing general-purpose programming language.<br /><br /><b>Decorations and Annotations</b><br />One of the simplest domain-specific language integration techniques that I'm aware of is the decorator/annotation pattern. This style of domain-specific language is used to statically register classes or functions with a library framework.<br /><blockquote class="tr_bq">class slave_address_map_info extends uvm_object;<br />&nbsp; protected int min_addr;<br />&nbsp; protected int max_addr;<br />&nbsp; function new(string name = "slave_address_map_info");<br />&nbsp; &nbsp; super.new(name);<br />&nbsp; endfunction<br /><span style="color: blue;">&nbsp; `uvm_object_utils_begin(slave_address_map_info)<br />&nbsp; &nbsp; `uvm_field_int(min_addr, UVM_DEFAULT)<br />&nbsp; &nbsp; `uvm_field_int(max_addr, UVM_DEFAULT)<br />&nbsp; `uvm_object_utils_end</span><br />&nbsp; // ...<br />endclass</blockquote><div><br /></div><div>While there are many examples of a decorator/annotation eDSLs, the example that came to mind first for me was the Universal Verification Methodology (UVM). UVM is a class library for functional verification built on top of the SystemVerilog domain-specific language. Two common operations that users of the UVM need to perform is registration of key user-defined types with the class library, and writing functions to clone, compare, and print class instances. Performing these operations in plain old code is time-consuming and error-prone. UVM provides a set of macros that allow the user to declare the existence of their user-defined class type and the fields within it (shown above highlighted in blue).&nbsp;</div><div>The macros (SystemVerilog's key feature supporting embedded domain-specific languages) above cause the class type to be registered with the UVM class library, and implement functions for comparing, displaying, and cloning an object of this type. All from a high-level specification.</div><div><br /></div><br /><b>Enmeshed eDSL</b><br />Our next level of eDSL integration starts to look a bit more like a language. An Enmeshed eDSL provides the user statements that look a bit like a programming language, but are really driving algorithms behind the scenes. I call this style of integration Enmeshed because the user's general-purpose programming language code interacts closely with the algorithms driven by the eDSL as program runs.<br /><blockquote class="tr_bq">class item : public rand_obj {<br />public:<br /><span style="white-space: pre;"> </span>item(rand_obj* parent = 0) : rand_obj(parent), src_addr(this), dest_addr(this) {<br /><span style="color: blue;"><span style="white-space: pre;">  </span>src_addr.addRange(0, 9);<br /><span style="white-space: pre;">  </span>src_addr.addRange(90, 99);<br /><span style="white-space: pre;">  </span>constraint(dest_addr() % 4 == 0);<br /><span style="white-space: pre;">  </span>constraint(dest_addr() &lt;= reference(src_addr) + 3);&nbsp;</span><br /><span style="white-space: pre;"> </span>}<br />&nbsp; &nbsp; <br /><span style="white-space: pre;"> </span>randv&lt;uint&gt; src_addr;<br /><span style="white-space: pre;"> </span>randv&lt;uint&gt; dest_addr;<br />};</blockquote>Our example of an Enmeshed eDSL comes courtesy of <a href="https://github.com/agra-uni-bremen/crave-bundle">CRAVE</a>, a constrained-random data generation package for the C++-based&nbsp;<a href="https://www.accellera.org/downloads/standards/systemc">SystemC</a>&nbsp;library. As you can see, the highlighted sections above look a bit more like a language. In this case, these are constraint expressions that control a constraint solver such that the values of <i>src_addr</i>&nbsp;and <i>dst_addr</i>&nbsp;obey the relationships established by the expressions.<br />When the user's program runs, it creates instances of classes like the one shown above, calls an API to create new random values for the random fields, and uses the values from those fields directly. In short, I consider the eDSL enmeshed with the host language because execution of the host language is interleaved with (effective) execution of the eDSL. The host language takes a primary role, and calls the eDSL code to provide specific services to the primary application.<br /><br /><b>Encapsulated eDSL</b><br />Our final level of eDSL integration is an embedded DSL that defines a new domain within the host language. There are several hardware-description languages embedded in general-purpose programming languages that fit this definition.<br /><br /><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.15); color: #333333; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 12.025px; line-height: 15.0313px; overflow-wrap: break-word; padding: 8.5px; white-space: pre-wrap; word-break: break-all;"><span style="color: green; font-weight: bold;">import</span> <span style="color: blue; font-weight: bold;">chisel3._</span><br /><br /><span style="color: green; font-weight: bold;">class</span> <span style="color: blue; font-weight: bold;">GCD</span> <span style="color: green; font-weight: bold;">extends</span> <span style="color: blue; font-weight: bold;">Module</span> <span style="color: #666666;">{</span><br />  <span style="color: green; font-weight: bold;">val</span> io <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">IO</span><span style="color: #666666;">(</span><span style="color: green; font-weight: bold;">new</span> <span style="color: blue; font-weight: bold;">Bundle</span> <span style="color: #666666;">{</span><br />    <span style="color: green; font-weight: bold;">val</span> a  <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Input</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">UInt</span><span style="color: #666666;">(32.W))</span><br />    <span style="color: green; font-weight: bold;">val</span> b  <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Input</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">UInt</span><span style="color: #666666;">(32.W))</span><br />    <span style="color: green; font-weight: bold;">val</span> e  <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Input</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">Bool</span><span style="color: #666666;">())</span><br />    <span style="color: green; font-weight: bold;">val</span> z  <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Output</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">UInt</span><span style="color: #666666;">(32.W))</span><br />    <span style="color: green; font-weight: bold;">val</span> v  <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Output</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">Bool</span><span style="color: #666666;">())</span><br />  <span style="color: #666666;">})</span><br />  <span style="color: green; font-weight: bold;">val</span> x <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Reg</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">UInt</span><span style="color: #666666;">(32.W))</span><br />  <span style="color: green; font-weight: bold;">val</span> y <span style="color: green; font-weight: bold;">=</span> <span style="color: blue; font-weight: bold;">Reg</span><span style="color: #666666;">(</span><span style="color: blue; font-weight: bold;">UInt</span><span style="color: #666666;">(32.W))</span><br />  when <span style="color: #666666;">(</span>x <span style="color: #666666;">&gt;</span> y<span style="color: #666666;">)</span>   <span style="color: #666666;">{</span> x <span style="color: #666666;">:=</span> x <span style="color: #666666;">-%</span> y <span style="color: #666666;">}</span><br />  <span style="color: #666666;">.</span>otherwise     <span style="color: #666666;">{</span> y <span style="color: #666666;">:=</span> y <span style="color: #666666;">-%</span> x <span style="color: #666666;">}</span><br />  when <span style="color: #666666;">(</span>io<span style="color: #666666;">.</span>e<span style="color: #666666;">)</span> <span style="color: #666666;">{</span> x <span style="color: #666666;">:=</span> io<span style="color: #666666;">.</span>a<span style="color: #666666;">;</span> y <span style="color: #666666;">:=</span> io<span style="color: #666666;">.</span>b <span style="color: #666666;">}</span><br />  io<span style="color: #666666;">.</span>z <span style="color: #666666;">:=</span> x<br />  io<span style="color: #666666;">.</span>v <span style="color: #666666;">:=</span> y <span style="color: #666666;">===</span> <span style="color: #666666;">0.</span>U<br /><span style="color: #666666;">}</span></pre><br />I've selected <a href="https://chisel.eecs.berkeley.edu/">CHISEL</a> (Constructing Hardware in a Scala-Embedded Language) as the example. What makes an encapsulated eDSL different is that the description made using the eDSL is monolithic and executed to create a single model -- in this case, Verilog. The GCD design show above might be used within a larger CHISEL-based design, but would never be used within a user's program to provide a useful service to the program. In a sense, an encapsulated eDSL description takes on a primary role within the host application.&nbsp;<br /><br /><br /><b>Embedding a DSL in Python</b><br />As we've seen, an embedded domain-specific language can provide a domain-specific interface to complex algorithms inside the confines of an existing general-purpose programming language. We've looked at several styles in which an embedded domain-specific language can be integrated into its host language -- all with different tradeoffs in terms of benefits and usability.<br />I've personally worked with embedded domain-specific languages in nearly every programming language I've used -- from C/C++ to TCL to Java. Most recently, though, I've been learning Python and (naturally) exploring the capabilities that Python offers for supporting an eDSL. Over the next few posts I'll look at Python's features that enable eDSL integration using a small&nbsp;eDSL I've been working on as an example.<br />In the meantime, what has your experience been with embedded domain-specific languages? Helpful or frustrating? Any notable examples -- either good or bad?<br /><br /><br /><div class="separator" style="clear: both;"><b><i>Disclaimer</i></b></div><div class="separator" style="clear: both;"><i>The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</i></div><div class="separator" style="clear: both;"><i><br /></i></div>