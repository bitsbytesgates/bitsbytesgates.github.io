---
layout: legacy_post
title: 'Chisel Sharpening: Initial impressions'
date: '2017-08-02T19:39:00.000-07:00'
author: Matthew Ballance
tags:
- Chisel
- Chisel3
- RiscV
- HDL
modified_time: '2017-08-02T19:39:02.820-07:00'
thumbnail: https://1.bp.blogspot.com/-wciyTu7Ffj4/WYJ0GBrRTcI/AAAAAAAAB-Y/G2fdnF-X8tUgfaxB9s5gTxAqAgwE5pQ2wCLcBGAs/s72-c/ChiselProductivity.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-5090067165930278711
blogger_orig_url: https://bitsbytesgates.blogspot.com/2017/08/chisel-sharpening-initial-impressions.html
---

Recently, RiscV (<a href="https://riscv.org/">https://riscv.org/</a>) has been all the rage. The free (as in speech and beer) instruction-set architecture has experienced an explosion of interest in the last couple of years, after being more-or-less an academic curiosity since 2010 or so.<br /><br />This post isn't about RiscV, though. It's about Chisel (<a href="https://github.com/freechipsproject/chisel3/wiki">https://github.com/freechipsproject/chisel3/wiki</a>) , the design language that the UC Berkeley team working on RiscV uses to implement Rocket Chip, their proof-of-concept RiscV implementation. Claims of the productivity benefits of using Chisel for hardware design are substantial. For example, one data point two implementations of a RiscV architecture -- one using Chisel and one in Verilog (<a href="https://riscv.org/wp-content/uploads/2015/01/riscv-chisel-tutorial-bootcamp-jan2015.pdf">https://riscv.org/wp-content/uploads/2015/01/riscv-chisel-tutorial-bootcamp-jan2015.pdf</a>).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-wciyTu7Ffj4/WYJ0GBrRTcI/AAAAAAAAB-Y/G2fdnF-X8tUgfaxB9s5gTxAqAgwE5pQ2wCLcBGAs/s1600/ChiselProductivity.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="546" data-original-width="729" height="298" src="https://1.bp.blogspot.com/-wciyTu7Ffj4/WYJ0GBrRTcI/AAAAAAAAB-Y/G2fdnF-X8tUgfaxB9s5gTxAqAgwE5pQ2wCLcBGAs/s400/ChiselProductivity.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">3x fewer lines of code -- even (but maybe especially) if the savings was in wiring -- sounds pretty good to me! So, I decided a while ago that I should dig in and learn more about Chisel.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h3 style="clear: both; text-align: left;">So, what's Chisel?</h3><div>Chisel certainly isn't a one-for-one replacement for a hardware description language (HDL) like Verilog or VHDL. Chisel is a class library, written in Scala (<a href="https://www.scala-lang.org/">https://www.scala-lang.org/</a>). Descriptions written using that class library are compiled, executed, and converted to Verilog. Now, your first thought when a high-level language like Scala is mentioned might be "High-Level Synthesis", but that's not what Chisel is all about. Chisel is very much focused on RTL (register-tranfer level) design.</div><div><br /></div><h3>A learning project</h3><div>I learn almost everything by doing, so I decided to assign myself a learning project to see if I could make Chisel go. A few years back, I coded a parameterized Wishbone interconnect in SystemVerilog. I was curious to see how a similar project coded in Chisel would compare.</div><div><br /></div><h3>All about the interfaces</h3><div>The first thing to do is to capture a Wishbone interface. As with many hardware interfaces, Wishbone is parameterized with address, data, and tag widths. Quite sensibly, Chisel provides a class for specifying reusable collections of signals called Bundle. Below, you can see the code used to declare the parameters for a Wishbone interface, and the Bundle (WishboneMaster) that specifies the signals for a Master interface.&nbsp;</div><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">class WishboneParameters (</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val ADDR_WIDTH &nbsp;: &nbsp;Int=32,</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val DATA_WIDTH &nbsp;: &nbsp;Int=32,</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val TGA_WIDTH &nbsp; : &nbsp;Int=1,</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val TGD_WIDTH &nbsp; : &nbsp;Int=1,</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val TGC_WIDTH &nbsp; : &nbsp;Int=1) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; def cloneType() = (new WishboneParameters(ADDR_WIDTH, DATA_WIDTH,</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; TGA_WIDTH, TGD_WIDTH, TGC_WIDTH)).asInstanceOf[this.type]</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">class WishboneMaster(val p : WishboneParameters) extends Bundle {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val ADR = Output(UInt(p.ADDR_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val TGA = Output(UInt(p.TGA_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val CTI = Output(UInt(3.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val BTE = Output(UInt(2.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val DAT_W = Output(UInt(p.DATA_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val TGD_W = Output(UInt(p.TGD_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val DAT_R = Input(UInt(p.DATA_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val TGD_R = Input(UInt(p.TGD_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val CYC = Output(Bool());</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val TGC = Output(UInt(p.TGC_WIDTH.W));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val ERR = Input(Bool());</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val SEL = Output(UInt(p.DATA_WIDTH/8));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val STB = Output(Bool());</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val ACK = Input(Bool());</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span style="white-space: pre;"> </span>val<span style="white-space: pre;"> </span>WE = Output(Bool());</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // ...</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><h3>Coding up the interconnect</h3><div>As with many learning projects, the Wishbone interconnect involved a series of iterations. Eventually, I arrived at the code below, broken up a bit to support comments:</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">class WishboneInterconnectParameters(</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val N_MASTERS &nbsp;: Int=1,</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val N_SLAVES &nbsp; : Int=1,</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val wb_p &nbsp; &nbsp; &nbsp; : WishboneParameters) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">class WishboneInterconnect(</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val p : WishboneInterconnectParameters,</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val typename : String = "WishboneInterconnect") extends Module {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; val io = IO(new Bundle {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val addr_base &nbsp;= Input(Vec(p.N_SLAVES, UInt(p.wb_p.ADDR_WIDTH.W)))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val addr_limit = Input(Vec(p.N_SLAVES, UInt(p.wb_p.ADDR_WIDTH.W)))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val m = Vec(p.N_MASTERS, Flipped(new WishboneMaster(p.wb_p)))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val s = Vec(p.N_SLAVES, new WishboneMaster(p.wb_p))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; });</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; override def desiredName() : String = typename;</span></div></div><div><br /></div><div>Here's the interface declaration. Note that we have vectors of address base and limit for address decode, then vectors of master and slave interfaces. Note the 'Flipped' method that reverses the Input/Output direction of elements within a bundle.</div><div><br /></div><div>Now, what we're building is effectively shown below. Each slave interface has an associated arbiter that is connected to all masters. Fortunately, Chisel provides an Arbiter as a built-in element of the class library.</div><div><br /></div><div><a href="http://4.bp.blogspot.com/-9iv6eBLKTEo/WYKLSe9KCmI/AAAAAAAAB_s/h3b5JCTevOYRSywom0hB6x1x4hY-EJBuwCK4BGAYYCw/s1600/Untitled%2Bdrawing%2B%25281%2529.jpg" imageanchor="1"><img border="0" height="206" src="https://4.bp.blogspot.com/-9iv6eBLKTEo/WYKLSe9KCmI/AAAAAAAAB_s/h3b5JCTevOYRSywom0hB6x1x4hY-EJBuwCK4BGAYYCw/s400/Untitled%2Bdrawing%2B%25281%2529.jpg" width="400" /></a></div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; val in_rsp = Seq.fill(p.N_MASTERS) ( Wire(new WishboneMaster(p.wb_p) ))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; val out_rsp = Seq.fill(p.N_SLAVES) ( Wire(new WishboneMaster(p.wb_p) ))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; for (i &lt;- 0 until p.N_MASTERS) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // Drive back to master</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; in_rsp(i).assign_rsp2p(io.m(i));</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; val out_arb = Seq.fill(p.N_SLAVES) ( Module(new RRArbiter(</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; new WishboneMaster(p.wb_p), p.N_MASTERS)) )</span></div></div><div><br /></div><div>This code creates a couple of temp arrays for routing the response back from the slave to the master, as well as an array of per-slave interface arbiters.</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; // For each slave, hook up all masters</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; for (i &lt;- 0 until p.N_SLAVES) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; for (j &lt;- 0 until p.N_MASTERS) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val m_sel = io.addr_base.indexWhere((p:UInt) =&gt; (io.m(j).ADR &gt;= p))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; val m_ex = (io.addr_base.exists((p:UInt) =&gt; (io.m(j).ADR &gt;= p)) &amp;&amp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io.addr_limit.exists((p:UInt) =&gt; (io.m(j).ADR &lt;= p)));</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; out_arb(i).io.in(j).bits.assign_p2req(io.m(j))</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; when (m_ex &amp;&amp; m_sel === i.asUInt()) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; out_arb(i).io.in(j).valid := Bool(true);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; } .otherwise {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; out_arb(i).io.in(j).valid := Bool(false);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; // Propagate slave response back to active master</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; when (out_arb(i).io.in(j).ready /* out_arb(i).io.in(j).valid &amp;&amp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out_arb(i).io.chosen === j.asUInt() */) {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_rsp(j) := out_rsp(i);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; } .otherwise {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_rsp(j).park_rsp();</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; out_arb(i).io.out.bits.assign_req2p(io.s(i));</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div></div><div><br /></div><div>Finally, we do the address decode to determine which slave a master's request address selects, and connect everything up to the arbiters. Note how simple it is to query the base/limit address arrays! The 'm_ex' field is true if the master is selecting a valid slave, while the 'm_sel' field holds the target index.</div><h3>Generating RTL</h3><div>One of the things I spent far too much time on was finding out how to generate Verilog from my Chisel description. Turns out the incantation is quite simple once you know what it is:</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">object WishboneInterconnectDriver extends App {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var N_MASTERS = 2;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var N_SLAVES = 4;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var ADDR_WIDTH = 32;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var DATA_WIDTH = 32;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; var typename = "wishbone_ic_%d_%d_%dx%d".format(</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; ADDR_WIDTH, DATA_WIDTH, N_MASTERS, N_SLAVES);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; chisel3.Driver.execute(args, () =&gt; new WishboneInterconnect(</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; new WishboneInterconnectParameters(N_MASTERS, N_SLAVES,</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wb_p=new WishboneParameters(ADDR_WIDTH, DATA_WIDTH)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; ), typename)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; )</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div></div><br />The code above calls the Chisel 'Driver', passing in an instance of the WishboneInterconnect class. The result of running this code is a set of files, one of which is the Verilog RTL. The output RTL is somewhat low-level -- and 1656 lines long (!). When it comes to debugging this, I'll be interested to how much this gets in the way. But, it's all sensible RTL at the end of the day...<br /><h3>Results</h3><div>Okay, so the hand-coded SystemVerilog interconnect took a total of 326 lines of SystemVerilog code. But, a little over 100 of those were the per-slave arbiter. If we ignore those lines, we have 206 lines of SystemVerilog. The Chisel description is 56 lines of code. So, 3-6x less code, depending on whether you count or ignore the arbiter implementation. Not bad, and I'm definitely feeling more comfortable with Chisel after working through an example like this.</div><div><br /></div><div>If you're interested, you can find the complete code on GitHub:</div><div><a href="https://github.com/mballance/wb_sys_ip">https://github.com/mballance/wb_sys_ip</a></div><div><br /></div><div>This repository contains both the hand-coded SystemVerilog and the Chisel representation.&nbsp;</div><h3>So, what did we learn?</h3><div>Well, initial experiments certainly seem to bear out the productivity benefits of Chisel. Library elements, such as the arbiter module are a great productivity boost! Array operations raise the abstraction level.</div><div><br /></div><div>Figuring out the basics can be a bit challenging. Even figuring out how to run the conversion to Verilog process took some digging. Because Chisel is embedded in another language, semantic errors tend to show up as Java exception errors, rather than nice high-level error messages.</div><div><br /></div><div>So, thus far, some good and some bad. Over the next couple of posts, I plan to dig into a couple of other areas of comparison -- including verification of the RTL, and how efficiently hand-coded and Chisel-generated implementations synthesize. So, stay tuned for more.</div><div><br /></div><div>Have you experimented at all with Chisel? Or, with other HDL alternatives for that matter. What has your experience been?&nbsp;</div><div><div><br /></div></div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span>