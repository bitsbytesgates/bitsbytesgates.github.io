---
layout: post
title: 'Py-HPI: A Procedural HDL/Python Integration'
date: '2019-06-08T17:25:00.000-07:00'
author: Matthew Ballance
tags:
- Electronic Design Automation
- EDA
- Verification
- Python
- Verilator
- Modelsim
- SystemVerilog
- Functional Verification
- Design Verification
- HDL
modified_time: '2019-06-08T17:25:55.719-07:00'
thumbnail: https://1.bp.blogspot.com/-hEeOagYDfLk/XPxNuGhOaUI/AAAAAAAAClM/sbguSr-QWLUfNyxFFR8RnViMLjxwhln9wCLcBGAs/s72-c/splash.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-5183933610926076860
blogger_orig_url: https://bitsbytesgates.blogspot.com/2019/06/py-hpi-procedural-hdlpython-integration.html
---

<div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-hEeOagYDfLk/XPxNuGhOaUI/AAAAAAAAClM/sbguSr-QWLUfNyxFFR8RnViMLjxwhln9wCLcBGAs/s1600/splash.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://1.bp.blogspot.com/-hEeOagYDfLk/XPxNuGhOaUI/AAAAAAAAClM/sbguSr-QWLUfNyxFFR8RnViMLjxwhln9wCLcBGAs/s1600/splash.png" /></a></div><br /><br /><div>As I mentioned in my <a href="https://bitsbytesgates.blogspot.com/2019/06/functional-verification-and-ecosystem.html">last post</a>, I've been looking at using Python for more tasks, including functional verification. My go-to languages for functional verification have traditionally been SystemVerilog for professional work, and C++ when I'm working on a personal project. I've started doing more of my small-application development in Python (often as an alternative to C++), and have wondered whether I could also migrate my testbench development from C++ to Python as well.</div><div><br /></div><div>This blog post provides an introduction to an integration I created between Python and an hardware descriptin language (HDL) simulation environment called <a href="https://github.com/fvutils/py-hpi">Py-HPI</a> (for Python HDL Procedural Interface). I'm far from the first to create an integration between Python and an HDL simulator (I'm aware of at least one formal project, and several others users that have written about their integration work), so what is different about <a href="https://github.com/fvutils/py-hpi/">Py-HPI</a>?</div><div><br /></div><div>Well, two things, really in my opinion:&nbsp;</div><div><ul><li>Py-HPI integrates at the procedural level, which means Python can directly call tasks in the HDL environment instead of interacting with signals in the HDL environment.&nbsp;</li><li>Py-HPI provides a high degree of automation for setting up this procedural-level integration.</li></ul><div>In this blog post, I will be describing the user experience in using Py-HPI. In future blog posts, I'll walk through how Py-HPI integrates on my <a href="https://github.com/mballance/fwrisc">go-to project for playing with verification technologies</a>, and I'll go more in-depth on how Bus Functional Models (BFMs) and testbench environments are developed for Py-HPI.</div></div><div><br /></div><h2>Py-HPI: The Big Picture</h2><div><br /></div><div style="text-align: center;"><img height="270" src="https://raw.githubusercontent.com/fvutils/py-hpi/master/docs/block_diagram.png" width="400" /></div><div style="text-align: left;">The structure of a Py-HPI enabled testbench is shown above. The key elements are described below</div><div style="text-align: left;"><ul><li><b>Testbench (Python)</b> -- This is Python code the user writes to interact with the design running within the HDL simulation environment</li><li><b>Simulator Support</b> -- This is C/C++ code generated by Py-HPI that implements the integration with a specific type of simulator. In general, this code is independent of the specific testbench</li><li><b>Testbench Wrapper</b> -- This is C code generated by Py-HPI that implements the testbench specifics of the integration between Python and the HDL environment</li><li><b>Bus Functional Models (BFMs)</b> -- BFMs written in HDL (eg SystemVerilog) implement the translation between task calls and signal activity and vice versa.</li></ul><div>Currently, Py-HPI supports standard SystemVerilog-DPI simulators (eg Modelsim) as well as Verilator. More integrations are planned, including support for Verilog simulators like Icarus Verilog.</div></div><h2>Py-HPI: A Small Example</h2><div style="text-align: center;"><img height="281" src="https://raw.githubusercontent.com/fvutils/py-hpi/master/docs/bfm_example_block_diagram.png" width="400" /></div><div style="text-align: left;"><br /></div><div style="text-align: left;">One easy way to get a sense for the user experience when using Py-HPI is to walk through the steps to run a very simple testbench environment. One of the <a href="https://github.com/fvutils/py-hpi/tree/master/ve/unit/bfm">Py-HPI examples</a> provides just such a testbench.</div><div style="text-align: left;">The structure of this testbench environment is shown above. The Python portion of the testbench drives the SystemVerilog HDL testbench via two bus functional models that are instanced in the SystemVerilog environment.</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Python Testbench</h3><div>First, let's take a look at the Python testbench code, which you can find <a href="https://github.com/fvutils/py-hpi/blob/master/ve/unit/bfm/my_tb.py">here</a>:</div><div style="text-align: left;"><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; overflow-wrap: normal; overflow: auto; padding: 16px; word-break: normal;"><pre style="color: #333333; line-height: 16.25px;"><span style="color: #008800; font-weight: bold;">def</span> <span style="color: #0066bb; font-weight: bold;">thread_func_1</span>():<br />  <span style="color: #007020;">print</span>(<span style="background-color: #fff0f0;">"thread_func_1"</span>)<br />  my_bfm = hpi.rgy.bfm_list[<span style="color: #0000dd; font-weight: bold;">0</span>]<br />  <span style="color: #008800; font-weight: bold;">for</span> i <span style="color: black; font-weight: bold;">in</span> <span style="color: #007020;">range</span>(<span style="color: #0000dd; font-weight: bold;">1000</span>):<br />    my_bfm.xfer(i*<span style="color: #0000dd; font-weight: bold;">2</span>)<br /><br /><span style="color: #008800; font-weight: bold;">def</span> <span style="color: #0066bb; font-weight: bold;">thread_func_2</span>():<br />  <span style="color: #007020;">print</span>(<span style="background-color: #fff0f0;">"thread_func_2"</span>)<br />  my_bfm = hpi.rgy.bfm_list[<span style="color: #0000dd; font-weight: bold;">1</span>]<br />  <span style="color: #008800; font-weight: bold;">for</span> i <span style="color: black; font-weight: bold;">in</span> <span style="color: #007020;">range</span>(<span style="color: #0000dd; font-weight: bold;">1000</span>):<br />    my_bfm.xfer(i)<br /><br /><span style="color: #555555; font-weight: bold;">@hpi</span>.entry<br /><span style="color: #008800; font-weight: bold;">def</span> <span style="color: #0066bb; font-weight: bold;">run_my_tb</span>():<br />    <span style="color: #007020;">print</span>(<span style="background-color: #fff0f0;">"run_my_tb - bfms: "</span> + <span style="color: #007020;">str</span>(<span style="color: #007020;">len</span>(hpi.rgy.bfm_list)))<br /><br />    <span style="color: #008800; font-weight: bold;">with</span> hpi.fork() <span style="color: #008800; font-weight: bold;">as</span> f:<br />      f.task(<span style="color: #008800; font-weight: bold;">lambda</span>: thread_func_1());<br />      f.task(<span style="color: #008800; font-weight: bold;">lambda</span>: thread_func_2());<br /><br />    <span style="color: #007020;">print</span>(<span style="background-color: #fff0f0;">"end of run_my_tb"</span>);</pre></pre></div>Execution starts in the <i>run_my_tb()</i>method (which is marked by a special Python decorator <i>hpi.entry</i>, to identify it as a valid entry point) which starts two threads and waits for them to complete. Each of the thread methods (thread_func_1 and thread_func_2) obtain a handle to one of the BFM instances and call the BFM's API to perform data transfers in the SystemVerilog testbench environment.<br />In a way, it's almost identical to what I would write in either C++ or SystemVerilog. In a way, that's kind of the point from my perspective.<br /><br /><h3>Running the Testbench</h3><div>Okay, now that we know what the Python side of the testbench looks like, let's see the commands used to create and compile the files necessary to run a simulation. These commands are in the <a href="https://github.com/fvutils/py-hpi/blob/master/ve/unit/bfm/runit_vl.sh">runit_vl.sh</a> script inside the example directory. In this case, I'll show the commands required to run Py-HPI with the Verilator simulator. The example also provides a script (runit_ms.vl) that runs the same example with Modelsim.</div><div><br /></div><h4>Create the Simulation Support Files</h4><div>We first need to create the simulation-support files. Since we're targeting the Verilator simulator, we need to run the 'gen-launcher-vl' subcommand implemented by the Py-HPI library.</div><div><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; overflow-wrap: normal; overflow: auto; padding: 16px; word-break: normal;">python3 -m hpi gen-launcher-vl top -clk clk=1ns</pre></div><div>Verilator is a bit of an outlier, in that the simulation-support files are specific to the HDL design being simulated. Consequently, we need to specify the name of the top Verilog module and the clock name and period.</div><div><br /><h4>Create the Testbench Wrapper</h4></div><div>Now, we need to create the Testbench wrapper file that will support the specific BFMs instantiated inside the testbench.&nbsp;</div><div><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; overflow-wrap: normal; overflow: auto; padding: 16px; word-break: normal;">python3 -m hpi -m my_tb gen-bfm-wrapper simple_bfm -type sv-dpi<br />python3 -m hpi -m my_tb gen-dpi</pre></div><h4><span style="font-weight: 400;">Because the Verilator simulator supports DPI, we generate a DPI-based testbench wrapper for our testbench that uses a single BFM. The resulting testbench wrapper is implemented in C and provides the connection between SystemVerilog and Python for our BFM.</span></h4><h4><b>Compile Everything</b></h4><div>This step is very specific to the simulator being used.&nbsp;</div><div><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; overflow-wrap: normal; overflow: auto; padding: 16px; word-break: normal;"><span class="pl-c" style="box-sizing: border-box; color: #6a737d;"><span class="pl-c" style="box-sizing: border-box;">#</span> Query required compilation/linker flags from Python</span><br />CFLAGS=<span class="pl-s" style="box-sizing: border-box; color: #032f62;"><span class="pl-pds" style="box-sizing: border-box;">"</span><span class="pl-smi" style="box-sizing: border-box; color: #24292e;">${CFLAGS}</span> <span class="pl-s" style="box-sizing: border-box;"><span class="pl-pds" style="box-sizing: border-box;">`</span>python3-config --cflags<span class="pl-pds" style="box-sizing: border-box;">`</span></span><span class="pl-pds" style="box-sizing: border-box;">"</span></span><br />LDFLAGS=<span class="pl-s" style="box-sizing: border-box; color: #032f62;"><span class="pl-pds" style="box-sizing: border-box;">"</span><span class="pl-smi" style="box-sizing: border-box; color: #24292e;">${LDFLAGS}</span> <span class="pl-s" style="box-sizing: border-box;"><span class="pl-pds" style="box-sizing: border-box;">`</span>python3-config --ldflags<span class="pl-pds" style="box-sizing: border-box;">`</span></span><span class="pl-pds" style="box-sizing: border-box;">"</span></span><br /><br />verilator --cc --exe -Wno-fatal --trace \<br /> top.sv simple_bfm.sv \<br /> launcher_vl.cpp pyhpi_dpi.c \<br /> -CFLAGS <span class="pl-s" style="box-sizing: border-box; color: #032f62;"><span class="pl-pds" style="box-sizing: border-box;">"</span><span class="pl-smi" style="box-sizing: border-box; color: #24292e;">${CFLAGS}</span><span class="pl-pds" style="box-sizing: border-box;">"</span></span> -LDFLAGS <span class="pl-s" style="box-sizing: border-box; color: #032f62;"><span class="pl-pds" style="box-sizing: border-box;">"</span><span class="pl-smi" style="box-sizing: border-box; color: #24292e;">${LDFLAGS}</span><span class="pl-pds" style="box-sizing: border-box;">"</span></span><br /><br />make -C obj_dir -f Vtop.mk</pre></div><div>Since we're using Verilator, we need to run Verilator to compile the HDL files and the simulator-support and testbench wrapper C/C++ files. Verilator generates C++ source and a Makefile to build the final simulator image. Our last step is to build the Verilator simulation image using the Verilator-created Makefile.</div><div><br /></div><h4>Run it!</h4><div>Finally, we can run our simulation.</div><div><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; overflow-wrap: normal; overflow: auto; padding: 16px; word-break: normal;">./obj_dir/Vtop +hpi.load=my_tb +vl.timeout=1ms +vl.trace</pre>We pass a few additional plusargs to enable specific behavior:<br /><br /><ul><li>The +hpi.load=my_tb specifies the Python module to load</li><li>The +vl.timeout=1ms specifies that the simulation should run for a maximum of 1ms. Other simulators will, of course, provide different mechanisms for doing this</li><li>The +vl.trace argument specifies that waveforms should be created. Other simulators will provide different ways of turning on tracing.</li></ul><div>So, all in all, Py-HPI makes it quite easy to connect a Python testbench to an HDL simulator at the procedural level.</div></div><h2>Conclusion</h2></div><div>In this blog post, I introduced <a href="https://github.com/fvutils/py-hpi">Py-HPI</a>, a procedural interface between Python and an HDL testbench environment along with an overview of the user experience when creating and running a testbench with Py-HPI. In my next post, I'll look at a Py-HPI testbench for my FWRISC RISC-V core and compare the new Python testbench with the existing C++ testbench. Until then, feel free to check out the Py-HPI library on GitHub (<a href="https://github.com/fvutils/py-hpi">https://github.com/fvutils/py-hpi</a>) and I'd be interested to hear your experiences in using Python for functional verification.</div><div><br /></div><div><br /></div><div><div class="separator" style="clear: both;"><b><i>Disclaimer</i></b></div><div class="separator" style="clear: both;"><i>The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</i></div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;"><br /></div></div>