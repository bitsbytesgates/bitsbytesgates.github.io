---
layout: post
title: 'SoC Integration Testing: Hw/Sw Coordination (Part 2)'
date: '2021-04-18T09:01:00.000-07:00'
author: Matthew Ballance
tags:
- PyBFMs
- SoC
- BFMs
- Software-Driven Verification
- Bus Functional Models
- System-Level Verification
modified_time: '2021-04-18T09:01:23.981-07:00'
thumbnail: https://1.bp.blogspot.com/-ZBoJb1TpY0c/YHs7BEuD-CI/AAAAAAAADpQ/-6mLIuhpgRA-EWwhuCzgZf8AZAwIXyQagCLcBGAsYHQ/s72-c/splash.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-8108144240203267066
blogger_orig_url: https://bitsbytesgates.blogspot.com/2021/04/soc-integration-testing-hwsw.html
---

<p style="text-align: center;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ZBoJb1TpY0c/YHs7BEuD-CI/AAAAAAAADpQ/-6mLIuhpgRA-EWwhuCzgZf8AZAwIXyQagCLcBGAsYHQ/s540/splash.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://1.bp.blogspot.com/-ZBoJb1TpY0c/YHs7BEuD-CI/AAAAAAAADpQ/-6mLIuhpgRA-EWwhuCzgZf8AZAwIXyQagCLcBGAsYHQ/s16000/splash.png" /></a></div><br /><p></p><p></p><div>Controlling the outside world -- specifically interface BFMs -- from embedded software is critical to SoC integration tests that exercise interface IP. <a href="https://bitsbytesgates.blogspot.com/2021/03/soc-integration-testing-hwsw-test.html">In the last post</a>, we showed how to pass data from embedded software to Python by tracing execution of the processor core and reading the mirrored values of registers and memory to obtain parameter values. While functional, doing things in this way is highly specific to one message-passing approach and is pretty labor intensive. In this post, we'll add some abstraction and automation to improve usability and scalability.</div><div><br /></div><div><br /></div><div><b>Design Goals</b></div><div><b><br /></b></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-dUWSpyHCvZM/YHtJyOtv5LI/AAAAAAAADqA/TjNZGDS5mlEztLbKRmkwP9oJynFYFSjcwCLcBGAsYHQ/s384/HvlRpc_Diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="363" data-original-width="384" src="https://1.bp.blogspot.com/-dUWSpyHCvZM/YHtJyOtv5LI/AAAAAAAADqA/TjNZGDS5mlEztLbKRmkwP9oJynFYFSjcwCLcBGAsYHQ/s16000/HvlRpc_Diagram.png" /></a></div><br /><b><br /></b></div><div>While we're initially focused on providing a nice automated way to communicate between embedded software and the test harness in a simulation environment, the design goals go beyond this. The diagram above shows the basic architecture. <i>Endpoints&nbsp;</i>provide a portal for one environment to call APIs in another environment. Each <i>endpoint</i>&nbsp;supports a known set of APIs, and different endpoints will support different sets of APIs.&nbsp;</div><div><br /></div><div>Each environment interacts with APIs on an endpoint without needing to know how communication is implemented. For example, execution trace might be used to implement processor to Python communication in a simulation-based environment. When the design is synthesized to FPGA, communication might be implemented via an external interface. With appropriate abstraction, neither the test software running on the processor nor the Python test code should need to change despite the fact that data is being moved in very different ways.&nbsp;</div><div><br /></div><div>In order for this to be feasible, we'll need to collect some meta-data about the APIs.</div><div><br /></div><div><br /></div><div><b>Example</b></div><div><b><br /></b></div><div>I always find an example to be helpful, so let's look at the enhancements to the flow in the context of a simple example.</div><div>&nbsp;</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-LNqDqp1S2pU/YHtC6-hfN6I/AAAAAAAADpk/L_J_vgTSKC8JzKu_f3xusMbk0BKkHRcQACLcBGAsYHQ/s276/Example_Diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="276" data-original-width="264" src="https://1.bp.blogspot.com/-LNqDqp1S2pU/YHtC6-hfN6I/AAAAAAAADpk/L_J_vgTSKC8JzKu_f3xusMbk0BKkHRcQACLcBGAsYHQ/s0/Example_Diagram.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><br /></div>The diagram above shows the key elements of a very small SoC called <a href="https://github.com/mballance/tiny-soc">Tiny SoC</a>. We can test many aspects of integration using just software on the processor. For example, we can read registers in the peripheral devices and check that they are correct. We can carry out DMA transfers. But, we need to control the outside world when testing the full path from software through the UART and SPI devices.</div><div><br /></div><div>Bus functional models (BFMs) or Verification IP (VIP) provide very effective ways to interact with interface protocols from testbench code. What we need in addition is a way to control these BFMs from the software running on the core in the design.</div><div><b><br /></b></div><div><b><br /></b></div><div><b>Capturing the API</b></div><div><br /></div><div>Let's focus on the UART for now. Our <a href="https://github.com/pybfms/pybfms-uart">UART BFM</a> provides a detailed API for configuring individual attributes of the UART protocol (eg baud-rate divisor) and for interacting with the UART protocol a <a href="https://github.com/pybfms/pybfms-uart/blob/9a8ae924a8a599239e5efdde42f2b66f6d4d2440/src/uart_bfms/uart_bfm.py#L31-L52">byte at a time</a>. That's fine for IP-level testing, but is a bit too low-level for software-driven testing.</div><div><br /></div><div>For software-driven testing, we want to instruct the BFM to do some reasonable amount of work and let it go. To help with this, the UART BFM defines a <a href="https://github.com/pybfms/pybfms-uart/blob/master/src/uart_bfms/uart_bfm_sw_api.py">higher-level API</a> intended for use by software.&nbsp;</div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-4GIcjAmaI3g/YHtF85dMLLI/AAAAAAAADpw/h4Nc63Uaaswm_ul2AnSNK99cObt56LygwCLcBGAsYHQ/s549/HigherLevel_Tx.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="134" data-original-width="549" src="https://1.bp.blogspot.com/-4GIcjAmaI3g/YHtF85dMLLI/AAAAAAAADpw/h4Nc63Uaaswm_ul2AnSNK99cObt56LygwCLcBGAsYHQ/s16000/HigherLevel_Tx.PNG" /></a></div><br /><div>An example of that higher-level API is shown above. Calling the <i>uart_bfm_tx_bytes_incr</i>&nbsp;API causes the BFM to begin sending a stream of bytes starting with a specific value and incrementing. There is another API that instructs the BFM to expect to receive a stream of bytes sent by the software running on the processor.</div><div><br /></div><div>To enable automation, we describe the Python API that we will call from embedded software using special annotations. We collect related APIs together in a class, and identify whether these methods are <i>exported</i>&nbsp;by the Python environment and will be called by the embedded software, or are <i>imported </i>by the Python and will be called by Python code.&nbsp;</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-IBOvEpdd1XQ/YHtIA434IzI/AAAAAAAADp4/iGDmoLXzeow-JvqBmClH2aUUm8WG4nEsQCLcBGAsYHQ/s641/ApiClass.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="436" data-original-width="641" src="https://1.bp.blogspot.com/-IBOvEpdd1XQ/YHtIA434IzI/AAAAAAAADp4/iGDmoLXzeow-JvqBmClH2aUUm8WG4nEsQCLcBGAsYHQ/s16000/ApiClass.PNG" /></a></div><br /><div>Since we want embedded software to call this API, the API is considered to be <i>exported</i>&nbsp;by Python. You can also see the configuration function that updates the UART's configuration (eg baud rate).</div><div><br /></div><div>Each of the method parameters is given a Python3 type annotation. This enables the Python libraries to know the type of each parameter and collect the right data to pass when the functions are called.&nbsp;</div><div><br /></div><div>On the C side, we simply need to have functions with the same signature as what we've captured in the Python API definition.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-BcFSME3qtEM/YHtSAPXzGGI/AAAAAAAADqQ/rTs8AdskVfE-hvhdKPerdP_Mm3jK4D28ACLcBGAsYHQ/s446/C_API.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="446" data-original-width="411" src="https://1.bp.blogspot.com/-BcFSME3qtEM/YHtSAPXzGGI/AAAAAAAADqQ/rTs8AdskVfE-hvhdKPerdP_Mm3jK4D28ACLcBGAsYHQ/s16000/C_API.PNG" /></a></div><div><br /></div>While the code shown above (<a href="https://github.com/pybfms/pybfms-uart/blob/master/src/uart_bfms/share/sw/c/uart_bfm.c">link</a>) is hand-coded, we could generate it automatically based on what is specified in the Python API definition.&nbsp;<br /><div><br /></div><div><br /></div><div><b>Connecting to Implementation: Python</b></div><div><b><br /></b></div><div>Connecting all of this up on the Python side involves connecting the relevant BFMs and API implementations together.&nbsp;</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-4fZcuLXRITI/YHtP3vlx8fI/AAAAAAAADqI/yNvW6xx40_AwxSEqmr5QJpUmGyG_xuSqwCLcBGAsYHQ/s498/Connect_Python.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="322" data-original-width="498" src="https://1.bp.blogspot.com/-4fZcuLXRITI/YHtP3vlx8fI/AAAAAAAADqI/yNvW6xx40_AwxSEqmr5QJpUmGyG_xuSqwCLcBGAsYHQ/s16000/Connect_Python.PNG" /></a></div><div><br /></div>The snippet above is from the cocotb test that runs when a baremetal software test is run (<a href="https://github.com/mballance/tiny-soc/blob/main/verilog/common/python/tiny_soc_tests/baremetal.py">link</a>). At the beginning of simulation, the test locates the relevant BFMs. The <i>u_dbg_bfm</i>&nbsp;is the tracer BFM that monitors execution of software on the processor core. This BFM implements an <i>Endpoint</i>, as shown in the diagram at the beginning of the post. The <i>u_uart_bfm</i>&nbsp;is the BFM connected to the UART interface on TinySoC.&nbsp;<div><br /></div><div>Once we have all the BFMs, we can create an instance of the higher-level UART BFM API (<i>uart_bfm_sw</i>) and tell the debug BFM that it should handle the embedded software calling these APIs.<br /><div><br /></div><div><br /></div><div><b>Example C-Test</b></div><div>With the BFMs connected on the Python side, we can now focus on how to interact with the BFM from the software test.</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-2JkVBKqE8Ok/YHtS02o9uUI/AAAAAAAADqY/v_kJYqUAKJwyWcLyPikPhfHHHL19A3tTgCLcBGAsYHQ/s557/RxTest.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="557" data-original-width="536" src="https://1.bp.blogspot.com/-2JkVBKqE8Ok/YHtS02o9uUI/AAAAAAAADqY/v_kJYqUAKJwyWcLyPikPhfHHHL19A3tTgCLcBGAsYHQ/s16000/RxTest.PNG" /></a></div>The software test snippet above transmits some data via the UART to the waiting UART BFM to check (<a href="https://github.com/pybfms/pybfms-uart/blob/master/src/uart_bfms/share/sw/c/uart_bfm.c">link</a>). Before we can send data, both the UART IP and the external BFM need to be configured in the same way. We program the UART IP via its registers, and call the <i>uart_bfm_config</i>&nbsp;function to cause the corresponding Python method to be invoked. This will cause the UART BFM mode to be configured.</div><div><br /></div><div>Next, we call the <i>uart_bfm_rx_bytes_incr </i>to tell the UART BFM that it should expect to receive 20 bytes. It should expect the first byte to have a value 10 and subsequent bytes to increment by one. By telling the BFM what to expect, our test is self-checking and the required amount of interaction is small.</div><div><br /></div><div>Finally, we again interact with the UART IP actually send the data that the BFM is expecting.&nbsp;<br /></div><div><br /></div><div><b>Next Steps</b></div><div>The API definition and Endpoint architecture described in the post above provides a modular way to capture the APIs used to communicate across environments. Because the API signature is captured in machine-readable way, it also enables the use of automation when implementing the APIs for different environments.&nbsp;</div><div><br /></div><div>As I mentioned at the beginning of the post, the API and Endpoint architecture is designed so it can be applied in many verification environments -- it's certainly not restricted to just communicating between embedded software test and the test harness. I've been interested for a while in methodology for creating and verifying firmware along with the IP that it controls such that it's ready to go when SoC-integration testing begins. My next post will begin exploring how to create, verify, and deliver firmware along with an IP.</div><div><br /></div><div><b><i>References</i></b></div><p></p><ul style="text-align: left;"><li>pybfms-uart --&nbsp;<a href="https://github.com/pybfms/pybfms-uart">https://github.com/pybfms/pybfms-uart</a></li><li>hvl-rpc --&nbsp;<a href="https://github.com/fvutils/pyhvl-rpc">https://github.com/fvutils/pyhvl-rpc</a></li><li>tiny-soc --&nbsp;<a href="https://github.com/mballance/tiny-soc">https://github.com/mballance/tiny-soc</a></li></ul><p></p><p><br /></p><div class="separator" style="background-color: white; clear: both; color: #666666; font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 13.2px;"><b><i>Disclaimer</i></b></div><div><div class="separator" style="background-color: white; clear: both; color: #666666; font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 13.2px;"><i>The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</i></div></div><div class="separator" style="background-color: white; clear: both; color: #666666; font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 13.2px;"><i><br /></i></div></div>