---
layout: post
title: 'PyVSC: Working with Coverage Data'
date: '2022-06-12T16:01:00.005-07:00'
author: Matthew Ballance
tags:
- functional coverage
- Python
- Functional Verification
modified_time: '2022-06-12T19:45:43.440-07:00'
thumbnail: https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjq5wnj9yN65OUU7dsp8gm5PRovjwCZlQubAsXkkaEis47rG46JBgh0gaNcbGqXjUX0HbjZQd1nRKrIChY0X6x_pVn_vbvGHNWxKyFDRiEATtKA-HWvSGjqViM03kqSmXfOsXtEI1NrobfqM6Q1E-rAkNKXk4RqeJfAIR3Wi_tLDYutBFSiDxMU2VjOFg/s72-c/pyvsc_coverage.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-4339569767190659846
blogger_orig_url: https://bitsbytesgates.blogspot.com/2022/06/pyvsc-working-with-coverage-data.html
---

<p>&nbsp;</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjq5wnj9yN65OUU7dsp8gm5PRovjwCZlQubAsXkkaEis47rG46JBgh0gaNcbGqXjUX0HbjZQd1nRKrIChY0X6x_pVn_vbvGHNWxKyFDRiEATtKA-HWvSGjqViM03kqSmXfOsXtEI1NrobfqM6Q1E-rAkNKXk4RqeJfAIR3Wi_tLDYutBFSiDxMU2VjOFg/s540/pyvsc_coverage.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjq5wnj9yN65OUU7dsp8gm5PRovjwCZlQubAsXkkaEis47rG46JBgh0gaNcbGqXjUX0HbjZQd1nRKrIChY0X6x_pVn_vbvGHNWxKyFDRiEATtKA-HWvSGjqViM03kqSmXfOsXtEI1NrobfqM6Q1E-rAkNKXk4RqeJfAIR3Wi_tLDYutBFSiDxMU2VjOFg/s16000/pyvsc_coverage.png" /></a></div><br /><p></p><p>I’ve been investing some time in documentation updates this weekend, after a couple of <a href="https://github.com/fvutils/pyvsc">PyVSC</a> users pointed out some under-described aspects of the PyVSC coverage flow. Given that these areas were under-documented in the past, it seemed a good opportunity to highlight what can be done with functional coverage data once it is sampled by a PyVSC covergroup.</p><p>So, we’ve described some functional coverage goals using a PyVSC covergroup and coverpoints, created a covergroup instance, and sampled some coverage data – perhaps it was randomly-generated stimulus or data sampled from a monitor. What now?</p><p><b>Runtime Coverage API</b></p><p>One simple thing we can do is to query coverage achieved using the coverage APIs implemented by PyVSC covergroup classes. The `get_coverage` method returns the coverage achieved by all instances of a covergroup type. The `get_inst_coverage` method returns the coverage achieved by the specified covergroup instance.</p><p>Let’s look at an example:</p><div class="separator" style="clear: both; text-align: left;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgp4sxGCmgvfSB9S5pp78tiKP9ANcuyBKm63jyX6Ba4FzkbWym3MKXtZm7XHklK37Q85x1d-B2WjNvVk4emQP6dQqtWWRBFb1QXRiB2osalTHrhv1_QJqVGejSBiGVBm4-z0QpU_wXceqAAilxYOfPOTI9aFJac3NmpNevdRnePWsu78MXv-8kluu0ppA/s696/CoverageMethodsExample.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="446" data-original-width="696" height="410" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgp4sxGCmgvfSB9S5pp78tiKP9ANcuyBKm63jyX6Ba4FzkbWym3MKXtZm7XHklK37Q85x1d-B2WjNvVk4emQP6dQqtWWRBFb1QXRiB2osalTHrhv1_QJqVGejSBiGVBm4-z0QpU_wXceqAAilxYOfPOTI9aFJac3NmpNevdRnePWsu78MXv-8kluu0ppA/w640-h410/CoverageMethodsExample.png" width="640" /></a></div><br /><p>In the example above, we define a covergroup with a coverpoint that contains four bins (1, 2, 4, 8). We create two instances of this covergroup and sample them with two different values. After each call to sample, we display the coverage achieved by all instances of the covergroup (type coverage) and the coverage achieved by each instance.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg2qk4RnWoLhRiXIiobU0GG5RUXFb-vzkDOOWbZxIQJEE9LIgaPJHgdw39_4zxORd4TArXagA9F8oeCRqPX_huZZNdsISo9EBDq4p2wpwTKlm4_AvW7DLRbrY871A7AWpp7WBCClI1FiPQhtevTqBZKKcNEvvCXTHgGa_Zyk-dINdavQtYNqhb7E8Zvmw/s696/CoverageMethodsExample_output.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="60" data-original-width="696" height="55" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg2qk4RnWoLhRiXIiobU0GG5RUXFb-vzkDOOWbZxIQJEE9LIgaPJHgdw39_4zxORd4TArXagA9F8oeCRqPX_huZZNdsISo9EBDq4p2wpwTKlm4_AvW7DLRbrY871A7AWpp7WBCClI1FiPQhtevTqBZKKcNEvvCXTHgGa_Zyk-dINdavQtYNqhb7E8Zvmw/w640-h55/CoverageMethodsExample_output.png" width="640" /></a></div><br /><p>The output from this example is shown above. After sampling the first covergroup, the coverage achieved for that, and all, instances is 25% since one of four bins was hit. After sampling the second covergroup, the coverage achieved for that covergroup instance is also 25%. Because two different bins are hit between the two covergroup instances, two of four bins are hit (50%) for type coverage.</p><p><br /></p><p><b>Runtime Coverage Reports</b></p><p>Another way to look at collected coverage is via a coverage report. PyVSC provides two methods that are nearly identical for obtaining a textual coverage report:</p><p></p><ul style="text-align: left;"><li>get_coverage_report – Returns the report as a string</li><li>report_coverage – Writes the report to a string (stdout by default)</li></ul><p></p><p>Both of these methods accept a keyword parameter named ‘details’ which controls whether bin hits are reported or just the top-level coverage achieved. Let’s look at a derivative of the first example to better understand the textual coverage report options.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjRCPcddPWGxNhpIXiH6rLaOqn_mExL05U8D8FGs2S_j4b6sNzqrzZNGd7oc7DeAAznwyc625pf5FePHsBmfrNXm2iHnbIeCxwU_ivnGg6XRTLA_dtbUyVPRhPK3k1kVmvedG07N5xB_1Won8A0oDH3ECbnODzM4NrETSJ5Mmt2yl73YCOVpxgLQR-mmg/s695/CoverageReportExample.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="396" data-original-width="695" height="364" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjRCPcddPWGxNhpIXiH6rLaOqn_mExL05U8D8FGs2S_j4b6sNzqrzZNGd7oc7DeAAznwyc625pf5FePHsBmfrNXm2iHnbIeCxwU_ivnGg6XRTLA_dtbUyVPRhPK3k1kVmvedG07N5xB_1Won8A0oDH3ECbnODzM4NrETSJ5Mmt2yl73YCOVpxgLQR-mmg/w640-h364/CoverageReportExample.png" width="640" /></a></div><br /><p>This example is nearly identical to the first one, but with calls to ‘report_coverage’ instead of calls to the covergroup get_coverage methods.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjdCGkZXcD3sQrlwTpP0rZV5xdOBlI95xSCqcq0mR9pAhpIHb32K82BLuZvwxq7xaFCo7xryzLMcwcZhZSOpHkIYgWdqjisDqq-E7089ddMUZ1vS85LNACJh7JFmz9fXMME4bXGS9gXXWc3CxuJy6VQHCPkI6QFxHJH6DEk2-QbrvJszihsWpkEgtqgqA/s694/CoverageReportExample_output.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="509" data-original-width="694" height="470" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjdCGkZXcD3sQrlwTpP0rZV5xdOBlI95xSCqcq0mR9pAhpIHb32K82BLuZvwxq7xaFCo7xryzLMcwcZhZSOpHkIYgWdqjisDqq-E7089ddMUZ1vS85LNACJh7JFmz9fXMME4bXGS9gXXWc3CxuJy6VQHCPkI6QFxHJH6DEk2-QbrvJszihsWpkEgtqgqA/w640-h470/CoverageReportExample_output.png" width="640" /></a></div><br /><p>The output from running this example is shown above. When reporting ‘details’ is enabled, the content of each coverage bin is reported. When reporting ‘details’ is disabled, only the top-level coverage achieved is reported. Displaying a coverage report with details is often helpful for confirming the correctness of a coverage model during development.</p><p><br /></p><p><b>Saving Coverage Data</b></p><p>The <a href="https://github.com/fvutils/pyucis">PyUCIS library</a> implements a Python interface to coverage data via the <a href="https://www.accellera.org/downloads/standards/ucis">Accellera UCIS</a> data model. It implements an object-oriented interface to coverage data, in addition to the Python equivalent of the UCIS C API. PyVSC uses the PyUCIS library to save coverage data, and can do so in a couple of interesting ways. Coverage data is written via the vsc.write_coverage_db method.</p><p>PyVSC can save coverage data to the XML interchange format defined by the UCIS standard. This is the default operation model for write_coverage_db. The example below shows saving it to a file named&nbsp; ‘cov.xml’.&nbsp;</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiv9Ox2BndFzQFeA46VCxqyroz3t-tNew5qvX0tu6xOiqxs83CdOn2jTq6mB_XxE3wsLjewGA1A4TdhpMRBk9SK1FE2uJl5UX-2zKQ9KElZunwOqpCiIKtJR5WgUGBjdn9kmzVap71ITuLTxE1zNrRRAKtR9KETlHXt0lzhEgQ1TDjdK34802Hu0_y_5Q/s698/CoverageSave_xml.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="332" data-original-width="698" height="304" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiv9Ox2BndFzQFeA46VCxqyroz3t-tNew5qvX0tu6xOiqxs83CdOn2jTq6mB_XxE3wsLjewGA1A4TdhpMRBk9SK1FE2uJl5UX-2zKQ9KElZunwOqpCiIKtJR5WgUGBjdn9kmzVap71ITuLTxE1zNrRRAKtR9KETlHXt0lzhEgQ1TDjdK34802Hu0_y_5Q/w640-h304/CoverageSave_xml.png" width="640" /></a></div><br /><p>PyVSC can also save coverage data to a custom database format, provided the tool that implements that database implements the UCIS C API. The example below saves coverage data to a custom database using the UCIS C API implemented in the shared library named ‘libucis.so’.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg1XaHSaOJZFYZ7xXLeQykKEXpAIkqXy69KBbpgxUAbjfjq7LL3hKaYm8UfihtSpZdmWiDVx9MtxhSOBQ28JnD5oQSaMtwXHtsW2DYgK30APCv78PAAW6WW_FtsIDUeiay1Tgd-sCUfRfSHCY4FDVQ7VfBWdL3OkYceMQZDHUgrhNj00A70KeKlaYW_WQ/s699/CoverageSave_ucis.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="330" data-original-width="699" height="302" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg1XaHSaOJZFYZ7xXLeQykKEXpAIkqXy69KBbpgxUAbjfjq7LL3hKaYm8UfihtSpZdmWiDVx9MtxhSOBQ28JnD5oQSaMtwXHtsW2DYgK30APCv78PAAW6WW_FtsIDUeiay1Tgd-sCUfRfSHCY4FDVQ7VfBWdL3OkYceMQZDHUgrhNj00A70KeKlaYW_WQ/w640-h302/CoverageSave_ucis.png" width="640" /></a></div><br /><p>Both of these paths to saving coverage may provide ways to bring coverage data collected by PyVSC into coverage-analysis flows implemented by commercial EDA tools. Check your tool’s documentation and/or check with your application engineer to understand which options may be available. Feel free to report what works for you on the <a href="https://github.com/fvutils/pyvsc/discussions">PyVSC discussion forum</a> so that others can benefit as well.</p><p><b>Viewing Coverage Data</b></p><p>Obviously, you can use commercial EDA tools to view coverage data from PyVSC if your tool provides a path to bring UCIS XML in, or if it implements the UCIS C API. <a href="https://github.com/fvutils/pyucis-viewer">PyUCIS Viewer</a> provides a very simple open-source graphical application for viewing coverage in UCIS XML format.&nbsp;</p><p>To use PyUCIS Viewer, save coverage data in UCIS XML interchange format, then run PyUICIS Viewer on that XML file:</p><p><span style="font-family: courier;">% pyucis-viewer cov.xml</span></p><p>A simple tree-based graphical viewer will open to show type and instance coverage.&nbsp;</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyl0Aq9crAVbgEDjUxRerI8F_fGYYudJiKtinT634Xb9HxvehdeaPSIhEPcm2AJhPakC36tHA5EmWFZnkCVKSh7PX0geeo34oaTlByWx1o13cfj8nj29Dj17Omvz-BmVWxQrpM-h26voDzzMpfec7idota5KvUW96RgrVbFMoLqvVVyf--L5g-mH7lNA/s893/RISCV-DV_Coverage.PNG" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="721" data-original-width="893" height="516" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyl0Aq9crAVbgEDjUxRerI8F_fGYYudJiKtinT634Xb9HxvehdeaPSIhEPcm2AJhPakC36tHA5EmWFZnkCVKSh7PX0geeo34oaTlByWx1o13cfj8nj29Dj17Omvz-BmVWxQrpM-h26voDzzMpfec7idota5KvUW96RgrVbFMoLqvVVyf--L5g-mH7lNA/w640-h516/RISCV-DV_Coverage.PNG" width="640" /></a></div><br /><p><b>Conclusion</b></p><p>There are several options for viewing and manipulating coverage once it has been collected via a covergroup modeled with PyVSC. In a future post, we’ll look at some additional manipulation and reporting options being implemented within <a href="https://github.com/fvutils/pyucis">PyUCIS</a>.&nbsp;</p><p>Until then, check out the latest additions to the <a href="https://fvutils.github.io/pyvsc/">PyVSC documentation</a> and raise questions and issues on the<a href="https://github.com/fvutils/pyvsc"> PyVSC GitHub</a> page.</p><p><br /></p><div style="text-align: center;">Copyright 2022 Matthew Ballance</div><div><p style="font-variant-east-asian: normal; font-variant-numeric: normal; line-height: 16px; margin-bottom: 0in;"><span style="color: #666666;"><span face="Trebuchet MS, Trebuchet, Verdana, sans-serif"><span style="font-size: 9pt;"><i><span style="background: rgb(255, 255, 255);">The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</span></i></span></span></span></p></div><div><br /></div>