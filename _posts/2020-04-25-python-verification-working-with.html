---
layout: post
title: 'Python Verification: Working with Coverage Data'
date: '2020-04-25T18:38:00.001-07:00'
author: Matthew Ballance
tags:
- functional coverage
- Python
- Cocotb
- PyVSC
- UCIS
- constrained random
- Accellera
modified_time: '2020-04-25T18:38:37.778-07:00'
thumbnail: https://1.bp.blogspot.com/-PCp3xC32PWs/XqTlJm0XgfI/AAAAAAAAC7A/J4RwJlYZtWgHDRQaz6V0vTh4IxQX8n1CwCLcBGAsYHQ/s72-c/splash.png
blogger_id: tag:blogger.com,1999:blog-142675602739945566.post-806412704696948975
blogger_orig_url: https://bitsbytesgates.blogspot.com/2020/04/python-verification-working-with.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-PCp3xC32PWs/XqTlJm0XgfI/AAAAAAAAC7A/J4RwJlYZtWgHDRQaz6V0vTh4IxQX8n1CwCLcBGAsYHQ/s1600/splash.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="540" src="https://1.bp.blogspot.com/-PCp3xC32PWs/XqTlJm0XgfI/AAAAAAAAC7A/J4RwJlYZtWgHDRQaz6V0vTh4IxQX8n1CwCLcBGAsYHQ/s1600/splash.png" /></a></div><br /><br />Before jumping into this week's post, I wanted to offer a bit of an apology to my readers. I recently realized that, despite being a Google property, Blogger only notifies authors of comments for moderation if the author has specifically registered a 'moderator' email with the site. So, apologies to those of you that have commented on posts directly on the Blogger site and watched those comments hang out in limbo indefinitely. I should now receive notifications of new comments.<br /><br />In my <a href="https://bitsbytesgates.blogspot.com/2020/04/python-verification-and-stimulus.html">last post</a>, we looked at modeling and sampling functional coverage in Python using the Python Verification Stimulus and Coverage (PyVSC). In that post, I showed how a textual coverage report could be generated to the console by calling an API. But, there is much more that we want to do with functional coverage data. The key question is: how do we store and manipulate it?<br /><br /><h3>Storing Coverage Data</h3><div>There are two big motivations for storing coverage data. The first is that we often wish to aggregate coverage across a large number of tool runs. In order to do that, we need a way to persist the coverage data collected by each individual tool run. The second is that we want to run analysis on the collected and aggregated coverage data. We want a way to browse through the data interactively, and create nice-looking reports and charts.</div><div><br /></div><ul><ul><ul></ul></ul></ul><h3>Standard Coverage Models</h3><div>Storing coverage data isn't much different than storing any other data. The first big question to answer is whether there is a standard way of of representing the data, or whether we need to invent one. While I've certainly had fun in the past inventing new formats for representing and storing data, considering all the requirements and designing in appropriate features to represent all the key features of a given type of data is a time consuming problem. Certainly something that should be undertaken as a last resort.</div><div><br /></div><div>The good news is that there are several existing formats for representing coverage. The bad news is that the vast majority are focused on representing code coverage data (eg <a href="https://cobertura.github.io/cobertura/">Coburtura</a>), not functional coverage data. That said, there is one industry standard for representing functional coverage and code coverage: <a href="https://www.accellera.org/downloads/standards/ucis">Accellera Unified Coverage Interoperability Standard</a>.&nbsp;</div><div><br /></div><div>While the&nbsp; UCIS defines several things, it doesn't define a standard database format. That said, what it does define is very useful. Specifically it defines:</div><ul><li>A data model for representing functional coverage, code coverage, and assertion coverage</li><li>A C-style API for accessing and modifying this data model</li><li>An XML interchange format to assist in moving data from one database implementation to another. In a pinch, the XML interchange format can even be used as a very simplistic database.</li></ul><div>Design is tough, so it's almost always most efficient to make use of the work of a committee of smart and capable people instead of starting over. UCIS is certainly not perfect. There are some "bugs" in the spec, and some internal inconsistencies. That said, it's far better than starting with a blank sheet of paper. The next challenge was adapting UCIS to Python.</div><ul><ul><ul></ul></ul></ul><h3>PyUCIS Library</h3><div>Much of my work recently has been in Python, so I wanted a way to work with the UCIS data model in Python. The <a href="https://github.com/fvutils/pyucis">PyUCIS library</a>&nbsp;is a pure-Python library for working with the UCIS data model. A block diagram of the architecture is shown below.&nbsp;</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-5FQxSojHcr0/XqTbGueCh7I/AAAAAAAAC6k/pu_lSRcIEnMK19ItUP36u6LgIfJkwzhswCLcBGAsYHQ/s1600/PyUCIS_Diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="499" data-original-width="1090" height="291" src="https://1.bp.blogspot.com/-5FQxSojHcr0/XqTbGueCh7I/AAAAAAAAC6k/pu_lSRcIEnMK19ItUP36u6LgIfJkwzhswCLcBGAsYHQ/s640/PyUCIS_Diagram.png" width="640" /></a></div><div><br /></div><h4>Front-End API</h4><div>The core of the PyUCIS library is an implementation of the UCIS API. Remember that the API defined by the UCIS is a C-style API, while Python is much more object-oriented. I initially decided to implement just an object-oriented version of the UCIS API, but then realized that reusing existing code snippets written in C would be much harder without an implementation of the C-style API. Fortunately, building a C-style compatibility API on top of the object-oriented one was fairly straightforward.</div><div><br /></div><h4>Backend</h4><div>The PyUCIS library uses a back-end to store the data being accessed via the front-end API. The PyUCIS library currently implements two back ends: an in-memory back-end, and an interface to existing C-API implementations of the UCIS API.</div><div><br /></div><div>The in-memory back-end stores coverage data in Python data structures. While it's not possible to persist the data model directly, the contents can be saved to and restored from the XML interchange format specified by the UCIS.</div><div><br /></div><div>The C-library back-end uses the <a href="https://docs.python.org/3/library/ctypes.html">Python ctypes library</a>&nbsp;to call the UCIS C API as implemented by a tool-specific shared library. This allows PyUCIS to access data in databases implemented by tools that support UCIS.</div><div><br /></div><div>While PyUCIS doesn't currently implement its own native database for storing coverage data, it's likely that it will in the future. Fortunately, Python provides an SQLite database as part of the core interpreter installation. Stay tuned here.</div><div><br /></div><h4>Built-in Apps</h4><div>The final part of the PyUCIS library are a set of built-in apps. These are used to perform simple manipulations on the coverage data and create outputs. Currently, PyUCIS only contains one built-in app: reading and writing the UCIS XML interchange format. That said, there are a couple planned on the roadmap:</div><div><ul><li>A merge app to combine data from multiple UCIS data models</li><li>A report app to produce a textual or HTML coverage report</li></ul></div><div><br /></div><ul><ul><ul></ul></ul></ul><h3>PyUCIS Apps</h3><div>The top layer of the PyUCIS architecture diagram are external applications that use the PyUCIS API. At the moment, there is only one and it's a proof of concept. <a href="https://github.com/fvutils/pyucis-viewer">PyUCIS Viewer</a>&nbsp;is a Python Qt5-based GUI for viewing coverage data.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-QGGohth8vXY/XqTEUMyjfYI/AAAAAAAAC6I/1tIWcWMCylAvWcjbWOULt2B68M5g0QvBQCLcBGAsYHQ/s1600/PyUCIS_Viewer.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="386" data-original-width="649" height="237" src="https://1.bp.blogspot.com/-QGGohth8vXY/XqTEUMyjfYI/AAAAAAAAC6I/1tIWcWMCylAvWcjbWOULt2B68M5g0QvBQCLcBGAsYHQ/s400/PyUCIS_Viewer.PNG" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div>While the viewer is certainly primitive (and incomplete) at the moment, hopefully this provides some ideas for what can be done with the data accessed via the PyUCIS API.</div><br /><h3>Next Steps</h3><div>PyUCIS is a pretty early-stage tool. I'm using it to save coverage data from the PyVSC library, and to produce some simple text coverage reports, but there's still quite a bit to do. As always, if you'd like to contribute to this or other projects, I'd welcome the help.&nbsp;</div><div>In the next post, I'll return the <a href="https://github.com/fvutils/pyvsc">Python Verification Stimulus and Coverage</a> (PyVSC) library to look at modeling constrained-random stimulus. Until then, stay safe!</div><div><br /></div><pre style="box-sizing: border-box; color: #404040; font-size: 12px; line-height: 1.4; overflow: auto; padding: 12px;"><span class="p" style="box-sizing: border-box;"><div class="separator" style="clear: both; color: black; font-family: &quot;Times New Roman&quot;; font-size: medium; white-space: normal;"><br /><b><i>Disclaimer</i></b></div><br /><div class="separator" style="clear: both; color: black; font-family: &quot;Times New Roman&quot;; font-size: medium; white-space: normal;"><br /><i>The views and opinions expressed above are solely those of the author and do not represent those of my employer or any other party.</i></div><br /></span></pre>